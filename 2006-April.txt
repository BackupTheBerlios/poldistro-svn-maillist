From panosl at berlios.de  Tue Apr 18 19:34:58 2006
From: panosl at berlios.de (panosl at berlios.de)
Date: Tue, 18 Apr 2006 19:34:58 +0200
Subject: [Poldistro-svn] r1236 - trunk
Message-ID: <200604181734.k3IHYw9L002392@sheep.berlios.de>

Author: panosl
Date: 2006-04-18 19:34:32 +0200 (Tue, 18 Apr 2006)
New Revision: 1236

Added:
   trunk/uomul/
Log:




From panosl at berlios.de  Tue Apr 18 19:40:50 2006
From: panosl at berlios.de (panosl at berlios.de)
Date: Tue, 18 Apr 2006 19:40:50 +0200
Subject: [Poldistro-svn] r1237 - trunk/uomul
Message-ID: <200604181740.k3IHeoYH004689@sheep.berlios.de>

Author: panosl
Date: 2006-04-18 19:40:34 +0200 (Tue, 18 Apr 2006)
New Revision: 1237

Added:
   trunk/uomul/LICENSE
   trunk/uomul/README
   trunk/uomul/index.py
   trunk/uomul/skills.py
   trunk/uomul/sound.py
   trunk/uomul/statics.py
Log:
initial uomul upload

Added: trunk/uomul/LICENSE
===================================================================
--- trunk/uomul/LICENSE	2006-04-18 17:34:32 UTC (rev 1236)
+++ trunk/uomul/LICENSE	2006-04-18 17:40:34 UTC (rev 1237)
@@ -0,0 +1,340 @@
+		    GNU GENERAL PUBLIC LICENSE
+		       Version 2, June 1991
+
+ Copyright (C) 1989, 1991 Free Software Foundation, Inc.
+ 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+			    Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+License is intended to guarantee your freedom to share and change free
+software--to make sure the software is free for all its users.  This
+General Public License applies to most of the Free Software
+Foundation's software and to any other program whose authors commit to
+using it.  (Some other Free Software Foundation software is covered by
+the GNU Lesser General Public License instead.)  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+this service if you wish), that you receive source code or can get it
+if you want it, that you can change the software or use pieces of it
+in new free programs; and that you know you can do these things.
+
+  To protect your rights, we need to make restrictions that forbid
+anyone to deny you these rights or to ask you to surrender the rights.
+These restrictions translate to certain responsibilities for you if you
+distribute copies of the software, or if you modify it.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must give the recipients all the rights that
+you have.  You must make sure that they, too, receive or can get the
+source code.  And you must show them these terms so they know their
+rights.
+
+  We protect your rights with two steps: (1) copyright the software, and
+(2) offer you this license which gives you legal permission to copy,
+distribute and/or modify the software.
+
+  Also, for each author's protection and ours, we want to make certain
+that everyone understands that there is no warranty for this free
+software.  If the software is modified by someone else and passed on, we
+want its recipients to know that what they have is not the original, so
+that any problems introduced by others will not reflect on the original
+authors' reputations.
+
+  Finally, any free program is threatened constantly by software
+patents.  We wish to avoid the danger that redistributors of a free
+program will individually obtain patent licenses, in effect making the
+program proprietary.  To prevent this, we have made it clear that any
+patent must be licensed for everyone's free use or not licensed at all.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+		    GNU GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License applies to any program or other work which contains
+a notice placed by the copyright holder saying it may be distributed
+under the terms of this General Public License.  The "Program", below,
+refers to any such program or work, and a "work based on the Program"
+means either the Program or any derivative work under copyright law:
+that is to say, a work containing the Program or a portion of it,
+either verbatim or with modifications and/or translated into another
+language.  (Hereinafter, translation is included without limitation in
+the term "modification".)  Each licensee is addressed as "you".
+
+Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running the Program is not restricted, and the output from the Program
+is covered only if its contents constitute a work based on the
+Program (independent of having been made by running the Program).
+Whether that is true depends on what the Program does.
+
+  1. You may copy and distribute verbatim copies of the Program's
+source code as you receive it, in any medium, provided that you
+conspicuously and appropriately publish on each copy an appropriate
+copyright notice and disclaimer of warranty; keep intact all the
+notices that refer to this License and to the absence of any warranty;
+and give any other recipients of the Program a copy of this License
+along with the Program.
+
+You may charge a fee for the physical act of transferring a copy, and
+you may at your option offer warranty protection in exchange for a fee.
+
+  2. You may modify your copy or copies of the Program or any portion
+of it, thus forming a work based on the Program, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) You must cause the modified files to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    b) You must cause any work that you distribute or publish, that in
+    whole or in part contains or is derived from the Program or any
+    part thereof, to be licensed as a whole at no charge to all third
+    parties under the terms of this License.
+
+    c) If the modified program normally reads commands interactively
+    when run, you must cause it, when started running for such
+    interactive use in the most ordinary way, to print or display an
+    announcement including an appropriate copyright notice and a
+    notice that there is no warranty (or else, saying that you provide
+    a warranty) and that users may redistribute the program under
+    these conditions, and telling the user how to view a copy of this
+    License.  (Exception: if the Program itself is interactive but
+    does not normally print such an announcement, your work based on
+    the Program is not required to print an announcement.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Program,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Program, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Program.
+
+In addition, mere aggregation of another work not based on the Program
+with the Program (or with a work based on the Program) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may copy and distribute the Program (or a work based on it,
+under Section 2) in object code or executable form under the terms of
+Sections 1 and 2 above provided that you also do one of the following:
+
+    a) Accompany it with the complete corresponding machine-readable
+    source code, which must be distributed under the terms of Sections
+    1 and 2 above on a medium customarily used for software interchange; or,
+
+    b) Accompany it with a written offer, valid for at least three
+    years, to give any third party, for a charge no more than your
+    cost of physically performing source distribution, a complete
+    machine-readable copy of the corresponding source code, to be
+    distributed under the terms of Sections 1 and 2 above on a medium
+    customarily used for software interchange; or,
+
+    c) Accompany it with the information you received as to the offer
+    to distribute corresponding source code.  (This alternative is
+    allowed only for noncommercial distribution and only if you
+    received the program in object code or executable form with such
+    an offer, in accord with Subsection b above.)
+
+The source code for a work means the preferred form of the work for
+making modifications to it.  For an executable work, complete source
+code means all the source code for all modules it contains, plus any
+associated interface definition files, plus the scripts used to
+control compilation and installation of the executable.  However, as a
+special exception, the source code distributed need not include
+anything that is normally distributed (in either source or binary
+form) with the major components (compiler, kernel, and so on) of the
+operating system on which the executable runs, unless that component
+itself accompanies the executable.
+
+If distribution of executable or object code is made by offering
+access to copy from a designated place, then offering equivalent
+access to copy the source code from the same place counts as
+distribution of the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  4. You may not copy, modify, sublicense, or distribute the Program
+except as expressly provided under this License.  Any attempt
+otherwise to copy, modify, sublicense or distribute the Program is
+void, and will automatically terminate your rights under this License.
+However, parties who have received copies, or rights, from you under
+this License will not have their licenses terminated so long as such
+parties remain in full compliance.
+
+  5. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Program or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Program (or any work based on the
+Program), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Program or works based on it.
+
+  6. Each time you redistribute the Program (or any work based on the
+Program), the recipient automatically receives a license from the
+original licensor to copy, distribute or modify the Program subject to
+these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties to
+this License.
+
+  7. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Program at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Program by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Program.
+
+If any portion of this section is held invalid or unenforceable under
+any particular circumstance, the balance of the section is intended to
+apply and the section as a whole is intended to apply in other
+circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system, which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  8. If the distribution and/or use of the Program is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Program under this License
+may add an explicit geographical distribution limitation excluding
+those countries, so that distribution is permitted only in or among
+countries not thus excluded.  In such case, this License incorporates
+the limitation as if written in the body of this License.
+
+  9. The Free Software Foundation may publish revised and/or new versions
+of the General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Program
+specifies a version number of this License which applies to it and "any
+later version", you have the option of following the terms and conditions
+either of that version or of any later version published by the Free
+Software Foundation.  If the Program does not specify a version number of
+this License, you may choose any version ever published by the Free Software
+Foundation.
+
+  10. If you wish to incorporate parts of the Program into other free
+programs whose distribution conditions are different, write to the author
+to ask for permission.  For software which is copyrighted by the Free
+Software Foundation, write to the Free Software Foundation; we sometimes
+make exceptions for this.  Our decision will be guided by the two goals
+of preserving the free status of all derivatives of our free software and
+of promoting the sharing and reuse of software generally.
+
+			    NO WARRANTY
+
+  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
+FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
+OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
+PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
+OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
+TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
+PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
+REPAIR OR CORRECTION.
+
+  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
+REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
+INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
+OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
+TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
+YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
+PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGES.
+
+		     END OF TERMS AND CONDITIONS
+
+	    How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the program's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+
+
+Also add information on how to contact you by electronic and paper mail.
+
+If the program is interactive, make it output a short notice like this
+when it starts in an interactive mode:
+
+    Gnomovision version 69, Copyright (C) year name of author
+    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, the commands you use may
+be called something other than `show w' and `show c'; they could even be
+mouse-clicks or menu items--whatever suits your program.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a "copyright disclaimer" for the program, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
+  `Gnomovision' (which makes passes at compilers) written by James Hacker.
+
+  <signature of Ty Coon>, 1 April 1989
+  Ty Coon, President of Vice
+
+This General Public License does not permit incorporating your program into
+proprietary programs.  If your program is a subroutine library, you may
+consider it more useful to permit linking proprietary applications with the
+library.  If this is what you want to do, use the GNU Lesser General
+Public License instead of this License.

Added: trunk/uomul/README
===================================================================

Added: trunk/uomul/index.py
===================================================================
--- trunk/uomul/index.py	2006-04-18 17:34:32 UTC (rev 1236)
+++ trunk/uomul/index.py	2006-04-18 17:40:34 UTC (rev 1237)
@@ -0,0 +1,17 @@
+from struct import unpack
+
+
+class Index:
+	def __init__(self, fname):
+		self.entries = self.__getEntries(fname)
+
+	def __getEntries(self, fname):
+		li = []
+		fsock = open(fname, 'rb')
+		data = fsock.read()
+		fsock.close()
+		data = unpack(str(len(data)/4)+'i', data)
+		for i in range(0, len(data), 3):
+			li.append(data[i:i+3])
+		return li
+

Added: trunk/uomul/skills.py
===================================================================
--- trunk/uomul/skills.py	2006-04-18 17:34:32 UTC (rev 1236)
+++ trunk/uomul/skills.py	2006-04-18 17:40:34 UTC (rev 1237)
@@ -0,0 +1,38 @@
+from index import Index
+
+
+def getData(file):
+	fsock = open(file, 'rb')
+	data = fsock.read()
+	fsock.close()
+	return data
+
+
+class Skills(Index):
+	def __init__(self, file='skills.mul', indexfile='Skills.idx'):
+		Index.__init__(self, indexfile)
+		self.data = getData(file)
+		self.count = len(self.entries)
+	
+	def getSkill(self, id):
+		'''Get skill name, and if active or not
+		returns dict'''
+		skill = {}
+		skill['action'] = self.data[self.entries[id][0]]
+		skill['name'] = 'a'
+		return skill
+	
+	def getSkills(self):
+		pass
+
+
+class SkillGrp:
+	def __init__(self, file):
+		self.data = getData(file)
+		self.count = self.getCount()
+		pass
+
+	def getCount():
+		count = unpack('i', self.data[:4][0])
+		return count
+

Added: trunk/uomul/sound.py
===================================================================
--- trunk/uomul/sound.py	2006-04-18 17:34:32 UTC (rev 1236)
+++ trunk/uomul/sound.py	2006-04-18 17:40:34 UTC (rev 1237)
@@ -0,0 +1,7 @@
+from index import Index
+
+
+class Sound:
+	def __init__(self):
+		pass
+

Added: trunk/uomul/statics.py
===================================================================
--- trunk/uomul/statics.py	2006-04-18 17:34:32 UTC (rev 1236)
+++ trunk/uomul/statics.py	2006-04-18 17:40:34 UTC (rev 1237)
@@ -0,0 +1,7 @@
+from index import Index
+
+
+class Statics:
+	def __init__(self):
+		pass
+



From panosl at berlios.de  Wed Apr 19 02:20:25 2006
From: panosl at berlios.de (panosl at berlios.de)
Date: Wed, 19 Apr 2006 02:20:25 +0200
Subject: [Poldistro-svn] r1238 - trunk/uomul
Message-ID: <200604190020.k3J0KPlX020597@sheep.berlios.de>

Author: panosl
Date: 2006-04-19 02:20:14 +0200 (Wed, 19 Apr 2006)
New Revision: 1238

Modified:
   trunk/uomul/skills.py
Log:
Fixed Skills.getSkill(id) and base of Skills.getSkills(), still need alot of work and cleanup.

Modified: trunk/uomul/skills.py
===================================================================
--- trunk/uomul/skills.py	2006-04-18 17:40:34 UTC (rev 1237)
+++ trunk/uomul/skills.py	2006-04-19 00:20:14 UTC (rev 1238)
@@ -1,4 +1,5 @@
 from index import Index
+from struct import unpack
 
 
 def getData(file):
@@ -17,13 +18,18 @@
 	def getSkill(self, id):
 		'''Get skill name, and if active or not
 		returns dict'''
+		sidx = self.entries[id]
+		skillt = unpack('b'+str(sidx[1]-1)+'s', self.data[sidx[0]:sidx[0]+sidx[1]])
 		skill = {}
-		skill['action'] = self.data[self.entries[id][0]]
-		skill['name'] = 'a'
+		skill['action'] = skillt[0]
+		skill['name'] = skillt[1][:-1]
 		return skill
 	
 	def getSkills(self):
-		pass
+		#TODO: Calculate the _actual_ range of the index, 'cause last
+		# seem to be empty.
+		skills = [self.getSkill(skill) for skill in range(0, 15)]
+		return skills
 
 
 class SkillGrp:



From panosl at berlios.de  Wed Apr 19 11:32:20 2006
From: panosl at berlios.de (panosl at berlios.de)
Date: Wed, 19 Apr 2006 11:32:20 +0200
Subject: [Poldistro-svn] r1239 - trunk/uomul
Message-ID: <200604190932.k3J9WKa6007984@sheep.berlios.de>

Author: panosl
Date: 2006-04-19 11:31:59 +0200 (Wed, 19 Apr 2006)
New Revision: 1239

Modified:
   trunk/uomul/skills.py
Log:


Modified: trunk/uomul/skills.py
===================================================================
--- trunk/uomul/skills.py	2006-04-19 00:20:14 UTC (rev 1238)
+++ trunk/uomul/skills.py	2006-04-19 09:31:59 UTC (rev 1239)
@@ -26,19 +26,13 @@
 		return skill
 	
 	def getSkills(self):
-		#TODO: Calculate the _actual_ range of the index, 'cause last
-		# seem to be empty.
+		#TODO: Calculate the _actual_ range of the index, 'cause index
+		# seems to have alot of empty stuff.
 		skills = [self.getSkill(skill) for skill in range(0, 15)]
 		return skills
 
 
 class SkillGrp:
-	def __init__(self, file):
+	def __init__(self, file='SkillGrp.mul'):
 		self.data = getData(file)
-		self.count = self.getCount()
-		pass
 
-	def getCount():
-		count = unpack('i', self.data[:4][0])
-		return count
-



From panosl at berlios.de  Wed Apr 19 15:17:40 2006
From: panosl at berlios.de (panosl at berlios.de)
Date: Wed, 19 Apr 2006 15:17:40 +0200
Subject: [Poldistro-svn] r1240 - trunk/uomul
Message-ID: <200604191317.k3JDHeV0003939@sheep.berlios.de>

Author: panosl
Date: 2006-04-19 15:17:01 +0200 (Wed, 19 Apr 2006)
New Revision: 1240

Modified:
   trunk/uomul/README
Log:


Modified: trunk/uomul/README
===================================================================
--- trunk/uomul/README	2006-04-19 09:31:59 UTC (rev 1239)
+++ trunk/uomul/README	2006-04-19 13:17:01 UTC (rev 1240)
@@ -0,0 +1,2 @@
+panos at polserver.com
+



From panosl at berlios.de  Thu Apr 20 14:23:22 2006
From: panosl at berlios.de (panosl at berlios.de)
Date: Thu, 20 Apr 2006 14:23:22 +0200
Subject: [Poldistro-svn] r1241 - trunk/uomul
Message-ID: <200604201223.k3KCNMRE004733@sheep.berlios.de>

Author: panosl
Date: 2006-04-20 14:23:15 +0200 (Thu, 20 Apr 2006)
New Revision: 1241

Modified:
   trunk/uomul/skills.py
Log:
Various improvements to skills.py, predetermine the length of skills.

Modified: trunk/uomul/skills.py
===================================================================
--- trunk/uomul/skills.py	2006-04-19 13:17:01 UTC (rev 1240)
+++ trunk/uomul/skills.py	2006-04-20 12:23:15 UTC (rev 1241)
@@ -13,11 +13,18 @@
 	def __init__(self, file='skills.mul', indexfile='Skills.idx'):
 		Index.__init__(self, indexfile)
 		self.data = getData(file)
-		self.count = len(self.entries)
+		self.max = self.__getMax()
+
+	def __getMax(self):
+		'''Determine the max number of skills'''
+		valid = [entry for entry in self.entries if entry[0] > -1]
+		return len(valid)
 	
 	def getSkill(self, id):
 		'''Get skill name, and if active or not
 		returns dict'''
+		if id > self.max-1:
+			return
 		sidx = self.entries[id]
 		skillt = unpack('b'+str(sidx[1]-1)+'s', self.data[sidx[0]:sidx[0]+sidx[1]])
 		skill = {}
@@ -25,10 +32,11 @@
 		skill['name'] = skillt[1][:-1]
 		return skill
 	
+	def setSkill(self, id, name, action):
+		'''Replace an already existing skill, with a new one.'''
+
 	def getSkills(self):
-		#TODO: Calculate the _actual_ range of the index, 'cause index
-		# seems to have alot of empty stuff.
-		skills = [self.getSkill(skill) for skill in range(0, 15)]
+		skills = [self.getSkill(skill) for skill in range(0, self.max)]
 		return skills
 
 



From panosl at berlios.de  Thu Apr 20 14:36:34 2006
From: panosl at berlios.de (panosl at berlios.de)
Date: Thu, 20 Apr 2006 14:36:34 +0200
Subject: [Poldistro-svn] r1242 - trunk/uomul
Message-ID: <200604201236.k3KCaYdq011479@sheep.berlios.de>

Author: panosl
Date: 2006-04-20 14:36:28 +0200 (Thu, 20 Apr 2006)
New Revision: 1242

Modified:
   trunk/uomul/skills.py
Log:
throw an exception rather than just return.

Modified: trunk/uomul/skills.py
===================================================================
--- trunk/uomul/skills.py	2006-04-20 12:23:15 UTC (rev 1241)
+++ trunk/uomul/skills.py	2006-04-20 12:36:28 UTC (rev 1242)
@@ -24,9 +24,11 @@
 		'''Get skill name, and if active or not
 		returns dict'''
 		if id > self.max-1:
-			return
+			#TODO Define a custom class Exception SkillError
+			raise NameError('Skill ID is out of range.')
 		sidx = self.entries[id]
-		skillt = unpack('b'+str(sidx[1]-1)+'s', self.data[sidx[0]:sidx[0]+sidx[1]])
+		skillt = unpack('b'+str(sidx[1]-1)+'s',
+			self.data[sidx[0]:sidx[0]+sidx[1]])
 		skill = {}
 		skill['action'] = skillt[0]
 		skill['name'] = skillt[1][:-1]



From panosl at berlios.de  Thu Apr 20 16:16:00 2006
From: panosl at berlios.de (panosl at berlios.de)
Date: Thu, 20 Apr 2006 16:16:00 +0200
Subject: [Poldistro-svn] r1243 - trunk/uomul
Message-ID: <200604201416.k3KEG0L4009945@sheep.berlios.de>

Author: panosl
Date: 2006-04-20 16:15:55 +0200 (Thu, 20 Apr 2006)
New Revision: 1243

Modified:
   trunk/uomul/skills.py
Log:
trying to add custom skill support

Modified: trunk/uomul/skills.py
===================================================================
--- trunk/uomul/skills.py	2006-04-20 12:36:28 UTC (rev 1242)
+++ trunk/uomul/skills.py	2006-04-20 14:15:55 UTC (rev 1243)
@@ -30,12 +30,17 @@
 		skillt = unpack('b'+str(sidx[1]-1)+'s',
 			self.data[sidx[0]:sidx[0]+sidx[1]])
 		skill = {}
-		skill['action'] = skillt[0]
+		skill['active'] = skillt[0]
 		skill['name'] = skillt[1][:-1]
 		return skill
 	
-	def setSkill(self, id, name, action):
+	def setSkill(self, id, name, active):
 		'''Replace an already existing skill, with a new one.'''
+		entries = self.entries[:]
+		idxold = entries.pop(id)
+		idxnew = (idxold[0], len(name), 0)
+		entries.insert(id, idxnew)
+		return entries
 
 	def getSkills(self):
 		skills = [self.getSkill(skill) for skill in range(0, self.max)]



From panosl at berlios.de  Thu Apr 20 16:26:39 2006
From: panosl at berlios.de (panosl at berlios.de)
Date: Thu, 20 Apr 2006 16:26:39 +0200
Subject: [Poldistro-svn] r1244 - trunk/uomul
Message-ID: <200604201426.k3KEQdsW015770@sheep.berlios.de>

Author: panosl
Date: 2006-04-20 16:26:34 +0200 (Thu, 20 Apr 2006)
New Revision: 1244

Modified:
   trunk/uomul/skills.py
Log:
variable naming

Modified: trunk/uomul/skills.py
===================================================================
--- trunk/uomul/skills.py	2006-04-20 14:15:55 UTC (rev 1243)
+++ trunk/uomul/skills.py	2006-04-20 14:26:34 UTC (rev 1244)
@@ -17,6 +17,7 @@
 
 	def __getMax(self):
 		'''Determine the max number of skills'''
+		# if index lookup is -1 it's invalid
 		valid = [entry for entry in self.entries if entry[0] > -1]
 		return len(valid)
 	
@@ -26,12 +27,12 @@
 		if id > self.max-1:
 			#TODO Define a custom class Exception SkillError
 			raise NameError('Skill ID is out of range.')
-		sidx = self.entries[id]
-		skillt = unpack('b'+str(sidx[1]-1)+'s',
-			self.data[sidx[0]:sidx[0]+sidx[1]])
+		skillidx = self.entries[id]
+		unpacked = unpack('b'+str(skillidx[1]-1)+'s',
+			self.data[skillidx[0]:skillidx[0]+skillidx[1]])
 		skill = {}
-		skill['active'] = skillt[0]
-		skill['name'] = skillt[1][:-1]
+		skill['active'] = unpacked[0]
+		skill['name'] = unpacked[1][:-1]
 		return skill
 	
 	def setSkill(self, id, name, active):



From panosl at berlios.de  Thu Apr 20 18:09:59 2006
From: panosl at berlios.de (panosl at berlios.de)
Date: Thu, 20 Apr 2006 18:09:59 +0200
Subject: [Poldistro-svn] r1245 - trunk/uomul
Message-ID: <200604201609.k3KG9xPN025836@sheep.berlios.de>

Author: panosl
Date: 2006-04-20 18:09:57 +0200 (Thu, 20 Apr 2006)
New Revision: 1245

Modified:
   trunk/uomul/skills.py
Log:
skills.idx updates successfully on skill editing. Now have to figure out data (skills.mul) update.

Modified: trunk/uomul/skills.py
===================================================================
--- trunk/uomul/skills.py	2006-04-20 14:26:34 UTC (rev 1244)
+++ trunk/uomul/skills.py	2006-04-20 16:09:57 UTC (rev 1245)
@@ -14,6 +14,7 @@
 		Index.__init__(self, indexfile)
 		self.data = getData(file)
 		self.max = self.__getMax()
+		self.newentries = []
 
 	def __getMax(self):
 		'''Determine the max number of skills'''
@@ -36,17 +37,25 @@
 		return skill
 	
 	def setSkill(self, id, name, active):
-		'''Replace an already existing skill, with a new one.'''
-		entries = self.entries[:]
-		idxold = entries.pop(id)
+		'''Replace an already existing skill, with a new one'''
+		if len(self.newentries) == 0:
+			self.newentries = self.entries[:]
+		self.newentries = [list(entry) for entry in self.newentries]
+		idxold = self.newentries.pop(id)
 		idxnew = (idxold[0], len(name), 0)
-		entries.insert(id, idxnew)
-		return entries
+		self.newentries.insert(id, idxnew)
+		temp = idxold[1] - idxnew[1]
+		for i in range(id+1, self.max):
+			self.newentries[i][0] += temp
+		return self.newentries
 
 	def getSkills(self):
 		skills = [self.getSkill(skill) for skill in range(0, self.max)]
 		return skills
 
+	def writeSkills(self, entries=self.newentries, data):
+		fsock = open('Skills.idx', 'w')
+		fsock.close()
 
 class SkillGrp:
 	def __init__(self, file='SkillGrp.mul'):



From panosl at berlios.de  Fri Apr 21 13:45:54 2006
From: panosl at berlios.de (panosl at berlios.de)
Date: Fri, 21 Apr 2006 13:45:54 +0200
Subject: [Poldistro-svn] r1246 - trunk/uomul
Message-ID: <200604211145.k3LBjsA1020371@sheep.berlios.de>

Author: panosl
Date: 2006-04-21 13:45:40 +0200 (Fri, 21 Apr 2006)
New Revision: 1246

Modified:
   trunk/uomul/skills.py
Log:
data update works, but it breaks the new index

Modified: trunk/uomul/skills.py
===================================================================
--- trunk/uomul/skills.py	2006-04-20 16:09:57 UTC (rev 1245)
+++ trunk/uomul/skills.py	2006-04-21 11:45:40 UTC (rev 1246)
@@ -1,5 +1,5 @@
 from index import Index
-from struct import unpack
+from struct import unpack, pack
 
 
 def getData(file):
@@ -15,6 +15,7 @@
 		self.data = getData(file)
 		self.max = self.__getMax()
 		self.newentries = []
+		self.newdata = ''
 
 	def __getMax(self):
 		'''Determine the max number of skills'''
@@ -28,9 +29,9 @@
 		if id > self.max-1:
 			#TODO Define a custom class Exception SkillError
 			raise NameError('Skill ID is out of range.')
-		skillidx = self.entries[id]
-		unpacked = unpack('b'+str(skillidx[1]-1)+'s',
-			self.data[skillidx[0]:skillidx[0]+skillidx[1]])
+		skillsidx = self.entries[id]
+		unpacked = unpack('b'+str(skillsidx[1]-1)+'s',
+			self.data[skillsidx[0]:skillsidx[0]+skillsidx[1]])
 		skill = {}
 		skill['active'] = unpacked[0]
 		skill['name'] = unpacked[1][:-1]
@@ -40,22 +41,29 @@
 		'''Replace an already existing skill, with a new one'''
 		if len(self.newentries) == 0:
 			self.newentries = self.entries[:]
+		if len(self.newdata) == 0:
+			self.newdata = self.data[:]
 		self.newentries = [list(entry) for entry in self.newentries]
 		idxold = self.newentries.pop(id)
-		idxnew = (idxold[0], len(name), 0)
-		self.newentries.insert(id, idxnew)
+		idxnew = [idxold[0], len(name), 0]
+		idxntemp = idxnew[:]
+		idxntemp[1] += 2
+		self.newentries.insert(id, idxntemp)
 		temp = idxold[1] - idxnew[1]
 		for i in range(id+1, self.max):
 			self.newentries[i][0] += temp
-		return self.newentries
+		packed = pack('b'+str(idxnew[1])+'s', active, name) + '\x00'
+		temp = self.newdata[:idxold[0]] + packed + self.newdata[idxold[0]+idxold[1]:]
+		self.newdata = temp
+		return packed
 
 	def getSkills(self):
 		skills = [self.getSkill(skill) for skill in range(0, self.max)]
 		return skills
 
-	def writeSkills(self, entries=self.newentries, data):
-		fsock = open('Skills.idx', 'w')
-		fsock.close()
+	#def writeSkills(self, entries=self.newentries, data=self.newdata):
+	#	fsock = open('Skills.idx', 'w')
+	#	fsock.close()
 
 class SkillGrp:
 	def __init__(self, file='SkillGrp.mul'):



From panosl at berlios.de  Mon Apr 24 01:35:07 2006
From: panosl at berlios.de (panosl at berlios.de)
Date: Mon, 24 Apr 2006 01:35:07 +0200
Subject: [Poldistro-svn] r1247 - trunk/uomul
Message-ID: <200604232335.k3NNZ7Bp026609@sheep.berlios.de>

Author: panosl
Date: 2006-04-24 01:34:59 +0200 (Mon, 24 Apr 2006)
New Revision: 1247

Modified:
   trunk/uomul/skills.py
Log:
skills.setSkill() works! Next stop, writeSkills(), to allow to write to the actual binary files.

Modified: trunk/uomul/skills.py
===================================================================
--- trunk/uomul/skills.py	2006-04-21 11:45:40 UTC (rev 1246)
+++ trunk/uomul/skills.py	2006-04-23 23:34:59 UTC (rev 1247)
@@ -49,13 +49,13 @@
 		idxntemp = idxnew[:]
 		idxntemp[1] += 2
 		self.newentries.insert(id, idxntemp)
-		temp = idxold[1] - idxnew[1]
+		temp = idxntemp[1] - idxold[1]
 		for i in range(id+1, self.max):
 			self.newentries[i][0] += temp
 		packed = pack('b'+str(idxnew[1])+'s', active, name) + '\x00'
 		temp = self.newdata[:idxold[0]] + packed + self.newdata[idxold[0]+idxold[1]:]
 		self.newdata = temp
-		return packed
+		return
 
 	def getSkills(self):
 		skills = [self.getSkill(skill) for skill in range(0, self.max)]
@@ -69,3 +69,7 @@
 	def __init__(self, file='SkillGrp.mul'):
 		self.data = getData(file)
 
+
+if __name__ == '__main__':
+	s = Skills()
+



From panosl at berlios.de  Mon Apr 24 19:32:59 2006
From: panosl at berlios.de (panosl at berlios.de)
Date: Mon, 24 Apr 2006 19:32:59 +0200
Subject: [Poldistro-svn] r1248 - trunk/uomul
Message-ID: <200604241732.k3OHWxac021617@sheep.berlios.de>

Author: panosl
Date: 2006-04-24 19:32:50 +0200 (Mon, 24 Apr 2006)
New Revision: 1248

Modified:
   trunk/uomul/skills.py
Log:
writeSkills() works and data gets flush, but the formatting of skills.mul seems to get borked, will have to look into it.

Modified: trunk/uomul/skills.py
===================================================================
--- trunk/uomul/skills.py	2006-04-23 23:34:59 UTC (rev 1247)
+++ trunk/uomul/skills.py	2006-04-24 17:32:50 UTC (rev 1248)
@@ -23,6 +23,13 @@
 		valid = [entry for entry in self.entries if entry[0] > -1]
 		return len(valid)
 	
+	def __flushData(self):
+		'''Copy the new data/entries to the cache and clean the new*'''
+		self.entries = self.newentries[:]
+		self.newentries = []
+		self.data = self.newdata[:]
+		self.newdata = ''
+
 	def getSkill(self, id):
 		'''Get skill name, and if active or not
 		returns dict'''
@@ -45,26 +52,32 @@
 			self.newdata = self.data[:]
 		self.newentries = [list(entry) for entry in self.newentries]
 		idxold = self.newentries.pop(id)
-		idxnew = [idxold[0], len(name), 0]
-		idxntemp = idxnew[:]
-		idxntemp[1] += 2
-		self.newentries.insert(id, idxntemp)
-		temp = idxntemp[1] - idxold[1]
+		idxnew = [idxold[0], len(name)+2, 0] # we +2 for action and null char
+		self.newentries.insert(id, idxnew)
+		charodds = idxnew[1] - idxold[1]
 		for i in range(id+1, self.max):
-			self.newentries[i][0] += temp
-		packed = pack('b'+str(idxnew[1])+'s', active, name) + '\x00'
+			self.newentries[i][0] += charodds
+		packed = pack('b'+str(idxnew[1]-2)+'s', active, name) + '\x00'
 		temp = self.newdata[:idxold[0]] + packed + self.newdata[idxold[0]+idxold[1]:]
 		self.newdata = temp
-		return
 
 	def getSkills(self):
 		skills = [self.getSkill(skill) for skill in range(0, self.max)]
 		return skills
 
-	#def writeSkills(self, entries=self.newentries, data=self.newdata):
-	#	fsock = open('Skills.idx', 'w')
-	#	fsock.close()
+	def writeSkills(self, flush=True):
+		'''Write the changes to the files and flush the old data'''
+		idxpacked = pack('%di' % (len(self.newentries)*3),
+			*(i for entry in self.entries for i in entry))
+		fsock = open('Skills.idx', 'w')
+		fsock.write(idxpacked)
+		fsock.close()
+		fsock = open('skills.mul', 'w')
+		fsock.write(self.newdata)
+		fsock.close()
+		self.__flushData()
 
+
 class SkillGrp:
 	def __init__(self, file='SkillGrp.mul'):
 		self.data = getData(file)



From panosl at berlios.de  Wed Apr 26 16:00:53 2006
From: panosl at berlios.de (panosl at berlios.de)
Date: Wed, 26 Apr 2006 16:00:53 +0200
Subject: [Poldistro-svn] r1249 - trunk/uomul
Message-ID: <200604261400.k3QE0rmP013162@sheep.berlios.de>

Author: panosl
Date: 2006-04-26 16:00:34 +0200 (Wed, 26 Apr 2006)
New Revision: 1249

Added:
   trunk/uomul/__init__.py
Modified:
   trunk/uomul/index.py
   trunk/uomul/skills.py
   trunk/uomul/sound.py
   trunk/uomul/statics.py
Log:
nothing serious.

Added: trunk/uomul/__init__.py
===================================================================

Modified: trunk/uomul/index.py
===================================================================
--- trunk/uomul/index.py	2006-04-24 17:32:50 UTC (rev 1248)
+++ trunk/uomul/index.py	2006-04-26 14:00:34 UTC (rev 1249)
@@ -1,3 +1,4 @@
+#
 from struct import unpack
 
 


Property changes on: trunk/uomul/index.py
___________________________________________________________________
Name: svn:keywords
   + __init__.py

Modified: trunk/uomul/skills.py
===================================================================
--- trunk/uomul/skills.py	2006-04-24 17:32:50 UTC (rev 1248)
+++ trunk/uomul/skills.py	2006-04-26 14:00:34 UTC (rev 1249)
@@ -1,3 +1,5 @@
+# $Id$
+
 from index import Index
 from struct import unpack, pack
 
@@ -3,4 +5,5 @@
 
 def getData(file):
+	''''''
 	fsock = open(file, 'rb')
 	data = fsock.read()
@@ -10,6 +13,7 @@
 
 
 class Skills(Index):
+	'''TODO'''
 	def __init__(self, file='skills.mul', indexfile='Skills.idx'):
 		Index.__init__(self, indexfile)
 		self.data = getData(file)
@@ -37,7 +41,8 @@
 			#TODO Define a custom class Exception SkillError
 			raise NameError('Skill ID is out of range.')
 		skillsidx = self.entries[id]
-		unpacked = unpack('b'+str(skillsidx[1]-1)+'s',
+		unpacked = unpack('b%ds' % (skillsidx[1]-1),
+		#unpacked = unpack('b'+str(skillsidx[1]-1)+'s',
 			self.data[skillsidx[0]:skillsidx[0]+skillsidx[1]])
 		skill = {}
 		skill['active'] = unpacked[0]
@@ -62,6 +67,7 @@
 		self.newdata = temp
 
 	def getSkills(self):
+		'''Get a list of all the skills'''
 		skills = [self.getSkill(skill) for skill in range(0, self.max)]
 		return skills
 
@@ -79,10 +85,7 @@
 
 
 class SkillGrp:
+	'''TODO'''
 	def __init__(self, file='SkillGrp.mul'):
 		self.data = getData(file)
 
-
-if __name__ == '__main__':
-	s = Skills()
-


Property changes on: trunk/uomul/skills.py
___________________________________________________________________
Name: svn:keywords
   + __init__.py


Property changes on: trunk/uomul/sound.py
___________________________________________________________________
Name: svn:keywords
   + __init__.py


Property changes on: trunk/uomul/statics.py
___________________________________________________________________
Name: svn:keywords
   + __init__.py



From panosl at berlios.de  Wed Apr 26 16:11:36 2006
From: panosl at berlios.de (panosl at berlios.de)
Date: Wed, 26 Apr 2006 16:11:36 +0200
Subject: [Poldistro-svn] r1250 - trunk/uomul
Message-ID: <200604261411.k3QEBaBP025348@sheep.berlios.de>

Author: panosl
Date: 2006-04-26 16:11:19 +0200 (Wed, 26 Apr 2006)
New Revision: 1250

Modified:
   trunk/uomul/__init__.py
   trunk/uomul/index.py
   trunk/uomul/skills.py
   trunk/uomul/sound.py
   trunk/uomul/statics.py
Log:



Property changes on: trunk/uomul/__init__.py
___________________________________________________________________
Name: svn:keywords
   + Id


Property changes on: trunk/uomul/index.py
___________________________________________________________________
Name: svn:keywords
   - __init__.py
   + Id


Property changes on: trunk/uomul/skills.py
___________________________________________________________________
Name: svn:keywords
   - __init__.py
   + Id


Property changes on: trunk/uomul/sound.py
___________________________________________________________________
Name: svn:keywords
   - __init__.py
   + Id


Property changes on: trunk/uomul/statics.py
___________________________________________________________________
Name: svn:keywords
   - __init__.py
   + Id



From panosl at berlios.de  Wed Apr 26 16:17:57 2006
From: panosl at berlios.de (panosl at berlios.de)
Date: Wed, 26 Apr 2006 16:17:57 +0200
Subject: [Poldistro-svn] r1251 - trunk/uomul
Message-ID: <200604261417.k3QEHv6c004140@sheep.berlios.de>

Author: panosl
Date: 2006-04-26 16:17:44 +0200 (Wed, 26 Apr 2006)
New Revision: 1251

Added:
   trunk/uomul/AUTHORS
Modified:
   trunk/uomul/README
   trunk/uomul/index.py
   trunk/uomul/skills.py
Log:


Added: trunk/uomul/AUTHORS
===================================================================
--- trunk/uomul/AUTHORS	2006-04-26 14:11:19 UTC (rev 1250)
+++ trunk/uomul/AUTHORS	2006-04-26 14:17:44 UTC (rev 1251)
@@ -0,0 +1,2 @@
+Panos Laganakos <panos at polserver dot com>
+

Modified: trunk/uomul/README
===================================================================
--- trunk/uomul/README	2006-04-26 14:11:19 UTC (rev 1250)
+++ trunk/uomul/README	2006-04-26 14:17:44 UTC (rev 1251)
@@ -1,2 +1 @@
-panos at polserver.com
 

Modified: trunk/uomul/index.py
===================================================================
--- trunk/uomul/index.py	2006-04-26 14:11:19 UTC (rev 1250)
+++ trunk/uomul/index.py	2006-04-26 14:17:44 UTC (rev 1251)
@@ -1,4 +1,4 @@
-#
+# $Id$
 from struct import unpack
 
 

Modified: trunk/uomul/skills.py
===================================================================
--- trunk/uomul/skills.py	2006-04-26 14:11:19 UTC (rev 1250)
+++ trunk/uomul/skills.py	2006-04-26 14:17:44 UTC (rev 1251)
@@ -1,5 +1,4 @@
 # $Id$
-
 from index import Index
 from struct import unpack, pack
 



From panosl at berlios.de  Wed Apr 26 17:07:09 2006
From: panosl at berlios.de (panosl at berlios.de)
Date: Wed, 26 Apr 2006 17:07:09 +0200
Subject: [Poldistro-svn] r1252 - trunk/uomul
Message-ID: <200604261507.k3QF79LE018911@sheep.berlios.de>

Author: panosl
Date: 2006-04-26 17:07:02 +0200 (Wed, 26 Apr 2006)
New Revision: 1252

Modified:
   trunk/uomul/index.py
   trunk/uomul/skills.py
Log:
writeSkills() works, Cool eh?

Modified: trunk/uomul/index.py
===================================================================
--- trunk/uomul/index.py	2006-04-26 14:17:44 UTC (rev 1251)
+++ trunk/uomul/index.py	2006-04-26 15:07:02 UTC (rev 1252)
@@ -3,16 +3,16 @@
 
 
 class Index:
-	def __init__(self, fname):
-		self.entries = self.__getEntries(fname)
+	def __init__(self, file):
+		self.entries = self.__getEntries(file)
 
-	def __getEntries(self, fname):
-		li = []
-		fsock = open(fname, 'rb')
+	def __getEntries(self, file):
+		entries = []
+		fsock = open(file, 'rb')
 		data = fsock.read()
 		fsock.close()
-		data = unpack(str(len(data)/4)+'i', data)
+		data = unpack('%di' % (len(data)/4), data)
 		for i in range(0, len(data), 3):
-			li.append(data[i:i+3])
-		return li
+			entries.append(data[i:i+3])
+		return entries 
 

Modified: trunk/uomul/skills.py
===================================================================
--- trunk/uomul/skills.py	2006-04-26 14:17:44 UTC (rev 1251)
+++ trunk/uomul/skills.py	2006-04-26 15:07:02 UTC (rev 1252)
@@ -61,7 +61,7 @@
 		charodds = idxnew[1] - idxold[1]
 		for i in range(id+1, self.max):
 			self.newentries[i][0] += charodds
-		packed = pack('b'+str(idxnew[1]-2)+'s', active, name) + '\x00'
+		packed = pack('b%ds' % (idxnew[1]-2), active, name) + '\x00'
 		temp = self.newdata[:idxold[0]] + packed + self.newdata[idxold[0]+idxold[1]:]
 		self.newdata = temp
 
@@ -73,11 +73,11 @@
 	def writeSkills(self, flush=True):
 		'''Write the changes to the files and flush the old data'''
 		idxpacked = pack('%di' % (len(self.newentries)*3),
-			*(i for entry in self.entries for i in entry))
-		fsock = open('Skills.idx', 'w')
+			*(i for entry in self.newentries for i in entry))
+		fsock = open('Skills.idx', 'wb')
 		fsock.write(idxpacked)
 		fsock.close()
-		fsock = open('skills.mul', 'w')
+		fsock = open('skills.mul', 'wb')
 		fsock.write(self.newdata)
 		fsock.close()
 		self.__flushData()



From panosl at berlios.de  Wed Apr 26 20:56:58 2006
From: panosl at berlios.de (panosl at berlios.de)
Date: Wed, 26 Apr 2006 20:56:58 +0200
Subject: [Poldistro-svn] r1253 - trunk/uomul
Message-ID: <200604261856.k3QIuw0n000492@sheep.berlios.de>

Author: panosl
Date: 2006-04-26 20:56:51 +0200 (Wed, 26 Apr 2006)
New Revision: 1253

Modified:
   trunk/uomul/skills.py
   trunk/uomul/sound.py
Log:
minor stuff updated

Modified: trunk/uomul/skills.py
===================================================================
--- trunk/uomul/skills.py	2006-04-26 15:07:02 UTC (rev 1252)
+++ trunk/uomul/skills.py	2006-04-26 18:56:51 UTC (rev 1253)
@@ -4,7 +4,8 @@
 
 
 def getData(file):
-	''''''
+	'''Get the data of a mul file'''
+	#TODO: Probably move this to some place generic
 	fsock = open(file, 'rb')
 	data = fsock.read()
 	fsock.close()
@@ -41,7 +42,6 @@
 			raise NameError('Skill ID is out of range.')
 		skillsidx = self.entries[id]
 		unpacked = unpack('b%ds' % (skillsidx[1]-1),
-		#unpacked = unpack('b'+str(skillsidx[1]-1)+'s',
 			self.data[skillsidx[0]:skillsidx[0]+skillsidx[1]])
 		skill = {}
 		skill['active'] = unpacked[0]
@@ -62,8 +62,8 @@
 		for i in range(id+1, self.max):
 			self.newentries[i][0] += charodds
 		packed = pack('b%ds' % (idxnew[1]-2), active, name) + '\x00'
-		temp = self.newdata[:idxold[0]] + packed + self.newdata[idxold[0]+idxold[1]:]
-		self.newdata = temp
+		tempdata = self.newdata[:idxold[0]] + packed + self.newdata[idxold[0]+idxold[1]:]
+		self.newdata = tempdata
 
 	def getSkills(self):
 		'''Get a list of all the skills'''
@@ -85,6 +85,23 @@
 
 class SkillGrp:
 	'''TODO'''
+	NAME_LEN = 17
+
 	def __init__(self, file='SkillGrp.mul'):
 		self.data = getData(file)
+		self.count = self.__getGroupCount();
+		#self.groupnames = self.__getGroupNames()
 
+	def __getGroupCount(self):
+		count = unpack('i', self.data[:4])
+		return count[0]
+
+	'''def __getGroupNames(self):
+		groupnames = unpack('%ds' % (NAME_LEN*self.count), self.data[self.count:NAME_LEN*self.count])
+		return groupnames'''
+
+	def getGroupName(self, id):
+		if id > count-1:
+			raise NameError('Skill Group ID is out of range.')
+		groupname = unpack('17s', self.data[4+id*17:])
+

Modified: trunk/uomul/sound.py
===================================================================
--- trunk/uomul/sound.py	2006-04-26 15:07:02 UTC (rev 1252)
+++ trunk/uomul/sound.py	2006-04-26 18:56:51 UTC (rev 1253)
@@ -1,7 +1,8 @@
+# $Id$
 from index import Index
 
 
-class Sound:
-	def __init__(self):
-		pass
+class Sound(Index):
+	def __init__(self, file='sound.mul', indexfile='soundidx.mul'):
+		Index.__init__(self, indexfile)
 



From panosl at berlios.de  Thu Apr 27 01:37:13 2006
From: panosl at berlios.de (panosl at berlios.de)
Date: Thu, 27 Apr 2006 01:37:13 +0200
Subject: [Poldistro-svn] r1254 - trunk/uomul
Message-ID: <200604262337.k3QNbDtc028590@sheep.berlios.de>

Author: panosl
Date: 2006-04-27 01:37:02 +0200 (Thu, 27 Apr 2006)
New Revision: 1254

Added:
   trunk/uomul/multi.py
Modified:
   trunk/uomul/__init__.py
   trunk/uomul/index.py
   trunk/uomul/skills.py
   trunk/uomul/sound.py
   trunk/uomul/statics.py
Log:
Updated documentation

Modified: trunk/uomul/__init__.py
===================================================================
--- trunk/uomul/__init__.py	2006-04-26 18:56:51 UTC (rev 1253)
+++ trunk/uomul/__init__.py	2006-04-26 23:37:02 UTC (rev 1254)
@@ -0,0 +1,7 @@
+'''Ultima Online MUL format access.
+
+uomul allows you to access UO's MUL files.
+'''
+
+__version__ = ''
+

Modified: trunk/uomul/index.py
===================================================================
--- trunk/uomul/index.py	2006-04-26 18:56:51 UTC (rev 1253)
+++ trunk/uomul/index.py	2006-04-26 23:37:02 UTC (rev 1254)
@@ -3,6 +3,7 @@
 
 
 class Index:
+	'''TODO'''
 	def __init__(self, file):
 		self.entries = self.__getEntries(file)
 

Added: trunk/uomul/multi.py
===================================================================
--- trunk/uomul/multi.py	2006-04-26 18:56:51 UTC (rev 1253)
+++ trunk/uomul/multi.py	2006-04-26 23:37:02 UTC (rev 1254)
@@ -0,0 +1,9 @@
+# $Id$
+from index import Index
+
+
+class Multi(Index):
+	'''TODO'''
+	def __init__(self, file='Multi.mul', indexfile='Multi.idx'):
+		Index.__init__(self, indexfile)
+


Property changes on: trunk/uomul/multi.py
___________________________________________________________________
Name: svn:keywords
   + Id

Modified: trunk/uomul/skills.py
===================================================================
--- trunk/uomul/skills.py	2006-04-26 18:56:51 UTC (rev 1253)
+++ trunk/uomul/skills.py	2006-04-26 23:37:02 UTC (rev 1254)
@@ -4,7 +4,7 @@
 
 
 def getData(file):
-	'''Get the data of a mul file'''
+	'''Get the data of a file'''
 	#TODO: Probably move this to some place generic
 	fsock = open(file, 'rb')
 	data = fsock.read()
@@ -22,7 +22,10 @@
 		self.newdata = ''
 
 	def __getMax(self):
-		'''Determine the max number of skills'''
+		'''Calculate the max number of skills.
+		@return: then max skill number
+		@rtype: integer
+		'''
 		# if index lookup is -1 it's invalid
 		valid = [entry for entry in self.entries if entry[0] > -1]
 		return len(valid)
@@ -35,8 +38,12 @@
 		self.newdata = ''
 
 	def getSkill(self, id):
-		'''Get skill name, and if active or not
-		returns dict'''
+		'''Get skill name.
+		@param id: the id of the skill who's name we want
+		@type id: integer
+		@return: the name of the skill and if active/passive
+		@rtype: dictionary
+		'''
 		if id > self.max-1:
 			#TODO Define a custom class Exception SkillError
 			raise NameError('Skill ID is out of range.')
@@ -44,12 +51,19 @@
 		unpacked = unpack('b%ds' % (skillsidx[1]-1),
 			self.data[skillsidx[0]:skillsidx[0]+skillsidx[1]])
 		skill = {}
-		skill['active'] = unpacked[0]
+		skill['active'] = bool(unpacked[0])
 		skill['name'] = unpacked[1][:-1]
 		return skill
 	
 	def setSkill(self, id, name, active):
-		'''Replace an already existing skill, with a new one'''
+		'''Replace a skill with a new one.
+		@param id: the id of the skill to replace
+		@type id: integer
+		@param name: the name of new skill
+		@type name: string
+		@param active: wether the skill is active/passive
+		@type active: boolean
+		'''
 		if len(self.newentries) == 0:
 			self.newentries = self.entries[:]
 		if len(self.newdata) == 0:
@@ -61,7 +75,7 @@
 		charodds = idxnew[1] - idxold[1]
 		for i in range(id+1, self.max):
 			self.newentries[i][0] += charodds
-		packed = pack('b%ds' % (idxnew[1]-2), active, name) + '\x00'
+		packed = pack('b%ds' % (idxnew[1]-2), int(active), name) + '\x00'
 		tempdata = self.newdata[:idxold[0]] + packed + self.newdata[idxold[0]+idxold[1]:]
 		self.newdata = tempdata
 
@@ -71,7 +85,10 @@
 		return skills
 
 	def writeSkills(self, flush=True):
-		'''Write the changes to the files and flush the old data'''
+		'''Write the changes to the files.
+		@param flush: wether to flush the old data on not
+		@type flush: boolean
+		'''
 		idxpacked = pack('%di' % (len(self.newentries)*3),
 			*(i for entry in self.newentries for i in entry))
 		fsock = open('Skills.idx', 'wb')
@@ -80,7 +97,8 @@
 		fsock = open('skills.mul', 'wb')
 		fsock.write(self.newdata)
 		fsock.close()
-		self.__flushData()
+		if flush is True:
+			self.__flushData()
 
 
 class SkillGrp:

Modified: trunk/uomul/sound.py
===================================================================
--- trunk/uomul/sound.py	2006-04-26 18:56:51 UTC (rev 1253)
+++ trunk/uomul/sound.py	2006-04-26 23:37:02 UTC (rev 1254)
@@ -3,6 +3,7 @@
 
 
 class Sound(Index):
+	''''''
 	def __init__(self, file='sound.mul', indexfile='soundidx.mul'):
 		Index.__init__(self, indexfile)
 

Modified: trunk/uomul/statics.py
===================================================================
--- trunk/uomul/statics.py	2006-04-26 18:56:51 UTC (rev 1253)
+++ trunk/uomul/statics.py	2006-04-26 23:37:02 UTC (rev 1254)
@@ -1,7 +1,7 @@
 from index import Index
 
 
-class Statics:
-	def __init__(self):
-		pass
+class Statics(Index):
+	def __init__(self, file='', indexfile=''):
+		Index.__self__(self, indexfile)
 



From panosl at berlios.de  Fri Apr 28 16:27:45 2006
From: panosl at berlios.de (panosl at berlios.de)
Date: Fri, 28 Apr 2006 16:27:45 +0200
Subject: [Poldistro-svn] r1255 - trunk/uomul
Message-ID: <200604281427.k3SERjlK000024@sheep.berlios.de>

Author: panosl
Date: 2006-04-28 16:27:34 +0200 (Fri, 28 Apr 2006)
New Revision: 1255

Added:
   trunk/uomul/basemul.py
Modified:
   trunk/uomul/__init__.py
   trunk/uomul/index.py
   trunk/uomul/skills.py
Log:
object oriented rewrite

Modified: trunk/uomul/__init__.py
===================================================================
--- trunk/uomul/__init__.py	2006-04-26 23:37:02 UTC (rev 1254)
+++ trunk/uomul/__init__.py	2006-04-28 14:27:34 UTC (rev 1255)
@@ -1,7 +1,7 @@
-'''Ultima Online MUL format access.
+'''Ultima Online MUL.
 
 uomul allows you to access UO's MUL files.
 '''
 
-__version__ = ''
+__version__ = '0.1'
 

Added: trunk/uomul/basemul.py
===================================================================
--- trunk/uomul/basemul.py	2006-04-26 23:37:02 UTC (rev 1254)
+++ trunk/uomul/basemul.py	2006-04-28 14:27:34 UTC (rev 1255)
@@ -0,0 +1,18 @@
+# $Id$
+
+
+class BaseMul:
+	'''TODO'''
+	def __init__(self, datafile=None, indexfile=None):
+		if datafile is not None:
+			self.data = self.__getData
+		if indexfile is not None:
+			self.entries =
+
+	def getData(self, file):
+		'''Get the data of a file'''
+		fsock = open(file, 'rb')
+		data = fsock.read()
+		fsock.close()
+		return data
+


Property changes on: trunk/uomul/basemul.py
___________________________________________________________________
Name: svn:keywords
   + Id

Modified: trunk/uomul/index.py
===================================================================
--- trunk/uomul/index.py	2006-04-26 23:37:02 UTC (rev 1254)
+++ trunk/uomul/index.py	2006-04-28 14:27:34 UTC (rev 1255)
@@ -9,9 +9,7 @@
 
 	def __getEntries(self, file):
 		entries = []
-		fsock = open(file, 'rb')
-		data = fsock.read()
-		fsock.close()
+		data = BaseMul.getData(self, file)
 		data = unpack('%di' % (len(data)/4), data)
 		for i in range(0, len(data), 3):
 			entries.append(data[i:i+3])

Modified: trunk/uomul/skills.py
===================================================================
--- trunk/uomul/skills.py	2006-04-26 23:37:02 UTC (rev 1254)
+++ trunk/uomul/skills.py	2006-04-28 14:27:34 UTC (rev 1255)
@@ -1,125 +1,29 @@
 # $Id$
-from index import Index
-from struct import unpack, pack
 
 
-def getData(file):
-	'''Get the data of a file'''
-	#TODO: Probably move this to some place generic
-	fsock = open(file, 'rb')
-	data = fsock.read()
-	fsock.close()
-	return data
+class Skill:
+	def __init__(self, name, active, id=None):
+		self.id = id
+		self.name = name
+		self.active = active
 
 
-class Skills(Index):
-	'''TODO'''
-	def __init__(self, file='skills.mul', indexfile='Skills.idx'):
-		Index.__init__(self, indexfile)
-		self.data = getData(file)
-		self.max = self.__getMax()
-		self.newentries = []
-		self.newdata = ''
+class SkillGroup:
+	def __init__(self, name, skills=None, id=None):
+		self.id = id
+		self.name = name
+		if skills is None:
+			self.skills = []
+		else:
+			self.skills = skills
 
-	def __getMax(self):
-		'''Calculate the max number of skills.
-		@return: then max skill number
-		@rtype: integer
-		'''
-		# if index lookup is -1 it's invalid
-		valid = [entry for entry in self.entries if entry[0] > -1]
-		return len(valid)
-	
-	def __flushData(self):
-		'''Copy the new data/entries to the cache and clean the new*'''
-		self.entries = self.newentries[:]
-		self.newentries = []
-		self.data = self.newdata[:]
-		self.newdata = ''
+	def addSkill(skill):
+		pass
 
-	def getSkill(self, id):
-		'''Get skill name.
-		@param id: the id of the skill who's name we want
-		@type id: integer
-		@return: the name of the skill and if active/passive
-		@rtype: dictionary
-		'''
-		if id > self.max-1:
-			#TODO Define a custom class Exception SkillError
-			raise NameError('Skill ID is out of range.')
-		skillsidx = self.entries[id]
-		unpacked = unpack('b%ds' % (skillsidx[1]-1),
-			self.data[skillsidx[0]:skillsidx[0]+skillsidx[1]])
-		skill = {}
-		skill['active'] = bool(unpacked[0])
-		skill['name'] = unpacked[1][:-1]
-		return skill
-	
-	def setSkill(self, id, name, active):
-		'''Replace a skill with a new one.
-		@param id: the id of the skill to replace
-		@type id: integer
-		@param name: the name of new skill
-		@type name: string
-		@param active: wether the skill is active/passive
-		@type active: boolean
-		'''
-		if len(self.newentries) == 0:
-			self.newentries = self.entries[:]
-		if len(self.newdata) == 0:
-			self.newdata = self.data[:]
-		self.newentries = [list(entry) for entry in self.newentries]
-		idxold = self.newentries.pop(id)
-		idxnew = [idxold[0], len(name)+2, 0] # we +2 for action and null char
-		self.newentries.insert(id, idxnew)
-		charodds = idxnew[1] - idxold[1]
-		for i in range(id+1, self.max):
-			self.newentries[i][0] += charodds
-		packed = pack('b%ds' % (idxnew[1]-2), int(active), name) + '\x00'
-		tempdata = self.newdata[:idxold[0]] + packed + self.newdata[idxold[0]+idxold[1]:]
-		self.newdata = tempdata
+	def removeSkill(skill):
+		pass
 
-	def getSkills(self):
-		'''Get a list of all the skills'''
-		skills = [self.getSkill(skill) for skill in range(0, self.max)]
-		return skills
 
-	def writeSkills(self, flush=True):
-		'''Write the changes to the files.
-		@param flush: wether to flush the old data on not
-		@type flush: boolean
-		'''
-		idxpacked = pack('%di' % (len(self.newentries)*3),
-			*(i for entry in self.newentries for i in entry))
-		fsock = open('Skills.idx', 'wb')
-		fsock.write(idxpacked)
-		fsock.close()
-		fsock = open('skills.mul', 'wb')
-		fsock.write(self.newdata)
-		fsock.close()
-		if flush is True:
-			self.__flushData()
+class SkillsMul:
+	def __init__(self, file='skills.mul', indexfile='Skills.idx', groupsfile='skillgrp.mul'):
 
-
-class SkillGrp:
-	'''TODO'''
-	NAME_LEN = 17
-
-	def __init__(self, file='SkillGrp.mul'):
-		self.data = getData(file)
-		self.count = self.__getGroupCount();
-		#self.groupnames = self.__getGroupNames()
-
-	def __getGroupCount(self):
-		count = unpack('i', self.data[:4])
-		return count[0]
-
-	'''def __getGroupNames(self):
-		groupnames = unpack('%ds' % (NAME_LEN*self.count), self.data[self.count:NAME_LEN*self.count])
-		return groupnames'''
-
-	def getGroupName(self, id):
-		if id > count-1:
-			raise NameError('Skill Group ID is out of range.')
-		groupname = unpack('17s', self.data[4+id*17:])
-



From panosl at berlios.de  Fri Apr 28 17:25:35 2006
From: panosl at berlios.de (panosl at berlios.de)
Date: Fri, 28 Apr 2006 17:25:35 +0200
Subject: [Poldistro-svn] r1256 - trunk/uomul
Message-ID: <200604281525.k3SFPZlO006535@sheep.berlios.de>

Author: panosl
Date: 2006-04-28 17:25:27 +0200 (Fri, 28 Apr 2006)
New Revision: 1256

Modified:
   trunk/uomul/basemul.py
   trunk/uomul/index.py
   trunk/uomul/skills.py
Log:
basic layout of new uomul.skills

Modified: trunk/uomul/basemul.py
===================================================================
--- trunk/uomul/basemul.py	2006-04-28 14:27:34 UTC (rev 1255)
+++ trunk/uomul/basemul.py	2006-04-28 15:25:27 UTC (rev 1256)
@@ -1,18 +1,21 @@
 # $Id$
 
 
+def getData(file):
+	'''Get the data of a file'''
+	fsock = open(file, 'rb')
+	data = fsock.read()
+	fsock.close()
+	return data
+
+
 class BaseMul:
 	'''TODO'''
 	def __init__(self, datafile=None, indexfile=None):
 		if datafile is not None:
-			self.data = self.__getData
+			self.data = getData(datafile)
 		if indexfile is not None:
-			self.entries =
+			from index import Index
+			idx = Index(indexfile)
+			self.entries = idx.entries
 
-	def getData(self, file):
-		'''Get the data of a file'''
-		fsock = open(file, 'rb')
-		data = fsock.read()
-		fsock.close()
-		return data
-

Modified: trunk/uomul/index.py
===================================================================
--- trunk/uomul/index.py	2006-04-28 14:27:34 UTC (rev 1255)
+++ trunk/uomul/index.py	2006-04-28 15:25:27 UTC (rev 1256)
@@ -1,5 +1,6 @@
 # $Id$
 from struct import unpack
+from basemul import getData
 
 
 class Index:
@@ -9,7 +10,7 @@
 
 	def __getEntries(self, file):
 		entries = []
-		data = BaseMul.getData(self, file)
+		data = getData(file)
 		data = unpack('%di' % (len(data)/4), data)
 		for i in range(0, len(data), 3):
 			entries.append(data[i:i+3])

Modified: trunk/uomul/skills.py
===================================================================
--- trunk/uomul/skills.py	2006-04-28 14:27:34 UTC (rev 1255)
+++ trunk/uomul/skills.py	2006-04-28 15:25:27 UTC (rev 1256)
@@ -1,8 +1,17 @@
 # $Id$
+from basemul import BaseMul, getData
 
 
 class Skill:
 	def __init__(self, name, active, id=None):
+		'''
+		@param name: the name of skill
+		@type name: string
+		@param active: skill status (active/passive)
+		@type active: boolean
+		@param id: the id of the skill
+		@type id: int
+		'''
 		self.id = id
 		self.name = name
 		self.active = active
@@ -24,6 +33,27 @@
 		pass
 
 
-class SkillsMul:
+class SkillsMul(BaseMul):
 	def __init__(self, file='skills.mul', indexfile='Skills.idx', groupsfile='skillgrp.mul'):
+		BaseMul.__init__(self, file, indexfile)
+		groups = SkillGrpMul(groupsfile)
 
+
+class SkillGrpMul(BaseMul):
+	def __init__(self, file='skillgrp.mul'):
+		BaseMul.__init__(self, file)
+		self.count = self.__getCount()
+		self.groups = self.getGroups()
+
+	def __getCount(self):
+		pass
+
+	def getGroups(self):
+		pass
+
+	def addGroup(self):
+		pass
+
+	def removeGroup(self):
+		pass
+



From austin at berlios.de  Sun Apr 30 05:17:05 2006
From: austin at berlios.de (austin at BerliOS)
Date: Sun, 30 Apr 2006 05:17:05 +0200
Subject: [Poldistro-svn] r1257 - trunk/096/pkg/systems/spawnSystem
Message-ID: <200604300317.k3U3H519000434@sheep.berlios.de>

Author: austin
Date: 2006-04-30 05:17:00 +0200 (Sun, 30 Apr 2006)
New Revision: 1257

Modified:
   trunk/096/pkg/systems/spawnSystem/spawnSystem.src
Log:
Comments for whats left to do.

Modified: trunk/096/pkg/systems/spawnSystem/spawnSystem.src
===================================================================
--- trunk/096/pkg/systems/spawnSystem/spawnSystem.src	2006-04-28 15:25:27 UTC (rev 1256)
+++ trunk/096/pkg/systems/spawnSystem/spawnSystem.src	2006-04-30 03:17:00 UTC (rev 1257)
@@ -8,7 +8,21 @@
 
 program SpawnSystem()
 	SS_ReportText("---=[ SPAWNER HAS STARTED UP ]=---");
+	Initialize();
 	
+	while ( 1 )
+		// Go through all realms -> regions -> groups.
+		// Determine if it is time to spawn the group. If so, start its engine.
+		// Save when it needs to run again (polcore().systime)
+		
+		// Determine when this needs to run again (1 second for now cause im lazy)
+		sleep(1);
+	endwhile
+	
+	return 1;
+endprogram
+
+function Initialize()
 	if ( !GetGlobalProperty("SpawnSystem") )
 		var script := Start_Script(":spawnsystem:initializer/firstRun");
 		if ( script.errortext )
@@ -22,4 +36,4 @@
 	endif
 	
 	return 1;
-endprogram
+endfunction



