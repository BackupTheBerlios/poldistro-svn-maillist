<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Poldistro-svn] r56 - in trunk/096/pkg/mobiles: . ai_brain ai_brain/commands ai_brain/commands/gm ai_brain/commands/test ai_brain/config ai_brain/include ai_brain/include/braincore
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/poldistro-svn/2005-September/index.html" >
   <LINK REL="made" HREF="mailto:poldistro-svn%40lists.berlios.de?Subject=Re%3A%20%5BPoldistro-svn%5D%20r56%20-%20in%20trunk/096/pkg/mobiles%3A%20.%20ai_brain%20ai_brain/commands%20ai_brain/commands/gm%20ai_brain/commands/test%20ai_brain/config%20ai_brain/include%20ai_brain/include/braincore&In-Reply-To=%3C200509041630.j84GUxv8004058%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000035.html">
   <LINK REL="Next"  HREF="000036.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Poldistro-svn] r56 - in trunk/096/pkg/mobiles: . ai_brain ai_brain/commands ai_brain/commands/gm ai_brain/commands/test ai_brain/config ai_brain/include ai_brain/include/braincore</H1>
    <B>Austin Heilman at BerliOS</B> 
    <A HREF="mailto:poldistro-svn%40lists.berlios.de?Subject=Re%3A%20%5BPoldistro-svn%5D%20r56%20-%20in%20trunk/096/pkg/mobiles%3A%20.%20ai_brain%20ai_brain/commands%20ai_brain/commands/gm%20ai_brain/commands/test%20ai_brain/config%20ai_brain/include%20ai_brain/include/braincore&In-Reply-To=%3C200509041630.j84GUxv8004058%40sheep.berlios.de%3E"
       TITLE="[Poldistro-svn] r56 - in trunk/096/pkg/mobiles: . ai_brain ai_brain/commands ai_brain/commands/gm ai_brain/commands/test ai_brain/config ai_brain/include ai_brain/include/braincore">austin at berlios.de
       </A><BR>
    <I>Sun Sep  4 18:30:59 CEST 2005</I>
    <P><UL>
        <LI>Previous message: <A HREF="000035.html">[Poldistro-svn] r55 - trunk/096/pkg/mobiles
</A></li>
        <LI>Next message: <A HREF="000036.html">[Poldistro-svn] r57 - trunk/096/pkg/mobiles/ai_brain/include/braincore
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#40">[ date ]</a>
              <a href="thread.html#40">[ thread ]</a>
              <a href="subject.html#40">[ subject ]</a>
              <a href="author.html#40">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: austin
Date: 2005-09-04 18:30:56 +0200 (Sun, 04 Sep 2005)
New Revision: 56

Added:
   trunk/096/pkg/mobiles/ai_brain/
   trunk/096/pkg/mobiles/ai_brain/brain.src
   trunk/096/pkg/mobiles/ai_brain/commands/
   trunk/096/pkg/mobiles/ai_brain/commands/gm/
   trunk/096/pkg/mobiles/ai_brain/commands/gm/attack.src
   trunk/096/pkg/mobiles/ai_brain/commands/gm/cmassacre.src
   trunk/096/pkg/mobiles/ai_brain/commands/gm/createnpc.src
   trunk/096/pkg/mobiles/ai_brain/commands/gm/makeswarm.src
   trunk/096/pkg/mobiles/ai_brain/commands/gm/massacre.src
   trunk/096/pkg/mobiles/ai_brain/commands/gm/npcsleep.src
   trunk/096/pkg/mobiles/ai_brain/commands/gm/npcwipe.src
   trunk/096/pkg/mobiles/ai_brain/commands/gm/puttosleep.src
   trunk/096/pkg/mobiles/ai_brain/commands/gm/removenpc.src
   trunk/096/pkg/mobiles/ai_brain/commands/gm/resetnpcs.src
   trunk/096/pkg/mobiles/ai_brain/commands/gm/restartnpc.src
   trunk/096/pkg/mobiles/ai_brain/commands/gm/sendevent.src
   trunk/096/pkg/mobiles/ai_brain/commands/test/
   trunk/096/pkg/mobiles/ai_brain/commands/test/cfgtest.src
   trunk/096/pkg/mobiles/ai_brain/config/
   trunk/096/pkg/mobiles/ai_brain/config/hatelist.cfg
   trunk/096/pkg/mobiles/ai_brain/config/icp.cfg
   trunk/096/pkg/mobiles/ai_brain/docs/
   trunk/096/pkg/mobiles/ai_brain/include/
   trunk/096/pkg/mobiles/ai_brain/include/braincore/
   trunk/096/pkg/mobiles/ai_brain/include/braincore/error.inc
   trunk/096/pkg/mobiles/ai_brain/include/braincore/eventProcessor.inc
   trunk/096/pkg/mobiles/ai_brain/include/braincore/movement.inc
   trunk/096/pkg/mobiles/ai_brain/include/braincore/setup.inc
   trunk/096/pkg/mobiles/ai_brain/include/eventid.inc
   trunk/096/pkg/mobiles/ai_brain/include/npcCommands.inc
   trunk/096/pkg/mobiles/ai_brain/include/npcError.inc
   trunk/096/pkg/mobiles/ai_brain/include/npcNerves.inc
   trunk/096/pkg/mobiles/ai_brain/include/npcSettings.inc
   trunk/096/pkg/mobiles/ai_brain/include/npcUtil.inc
   trunk/096/pkg/mobiles/ai_brain/pkg.cfg
Log:


Added: trunk/096/pkg/mobiles/ai_brain/brain.src
===================================================================
--- trunk/096/pkg/mobiles/ai_brain/brain.src	2005-09-04 16:28:05 UTC (rev 55)
+++ trunk/096/pkg/mobiles/ai_brain/brain.src	2005-09-04 16:30:56 UTC (rev 56)
@@ -0,0 +1,53 @@
+/*===============================================================
+* Current Version
+* BRAIN.SRC - v5.0
+* Updated 9/1/2005 6:20AM
+*
+* NPC AI-Script to control all non-setup actions. Acts as the &quot;brain&quot;
+* and fires off external scripts that act as the &quot;nerves&quot; of the NPC.
+*
+* -- Revision v1.0 --
+* Austin:
+*  Created include file
+===============================================================*/
+
+use uo;
+use os;
+use npc;
+use cfgfile;
+use polsys;
+
+include &quot;include/sysEvent&quot;;
+include &quot;:ai_brain:include/braincore/error&quot;;
+include &quot;:ai_brain:include/braincore/eventProcessor&quot;;
+include &quot;:ai_brain:include/braincore/movement&quot;;
+include &quot;:ai_brain:include/braincore/setup&quot;;
+include &quot;:ai_brain:include/eventid&quot;;
+include &quot;:ai_brain:include/npcCommands&quot;;
+include &quot;:ai_brain:include/npcNerves&quot;;
+include &quot;:ai_brain:include/npcSettings&quot;;
+include &quot;:ai_brain:include/npcUtil&quot;;
+
+//
+// * Global variables
+//
+var npc := Self();
+var idle_ticks := 0;
+var sleep_mode := 0;
+var g_settings := dictionary; //&quot;setting name&quot;-&gt;value
+var g_scripts := dictionary; // &quot;script type&quot;-&gt;value{.flags, .script}
+var g_nerves := dictionary; // &quot;nerve name&quot;-&gt;value{.flags, .pid}
+
+program BrainAI()
+	//Run setup steps for the npc.
+	set_critical(1);
+	InitializeSettings();
+	InitializeEvents();
+	set_critical(1);
+	StartupScripts();
+	
+	while ( npc )
+		var ev := Wait_For_Event(g_settings[&quot;cycle_wait&quot;]);
+		ProcessEvent(ev);
+	endwhile
+endprogram

Added: trunk/096/pkg/mobiles/ai_brain/commands/gm/attack.src
===================================================================
--- trunk/096/pkg/mobiles/ai_brain/commands/gm/attack.src	2005-09-04 16:28:05 UTC (rev 55)
+++ trunk/096/pkg/mobiles/ai_brain/commands/gm/attack.src	2005-09-04 16:30:56 UTC (rev 56)
@@ -0,0 +1,23 @@
+//Example: .attack -&gt; Makes an npc attack another mobile.
+use uo;
+use os;
+
+include &quot;:ai_brain:include/NPC_Commands&quot;;
+
+program MakeAttack(who)
+	SendSysMessage(who, &quot;Select an npc (attacker).&quot;);
+	var targ := target(who);
+	if ( !targ.npctemplate ) 
+		SendSysMessage(who, &quot;Cancelled&quot;);
+		return 0;
+	endif
+	
+	SendSysMessage(who, &quot;Select a mobile (defender).&quot;);
+	var targ2 := target(who);
+	if ( !targ2.IsA(POLCLASS_MOBILE) )
+		SendSysMessage(who, &quot;Cancelled&quot;);
+		return 0;
+	endif
+	
+	AI_Attack(targ, targ2);
+endprogram

Added: trunk/096/pkg/mobiles/ai_brain/commands/gm/cmassacre.src
===================================================================
--- trunk/096/pkg/mobiles/ai_brain/commands/gm/cmassacre.src	2005-09-04 16:28:05 UTC (rev 55)
+++ trunk/096/pkg/mobiles/ai_brain/commands/gm/cmassacre.src	2005-09-04 16:30:56 UTC (rev 56)
@@ -0,0 +1,19 @@
+//Example: .massacre [radius] - Kills npcs within the radius and leaves the corpses.
+use uo;
+
+include &quot;:gumps:include/requestgump&quot;;
+
+program Massacre(who, range)
+	
+	range := CInt(range);
+	if ( !range )
+		range := CInt(RequestGump(who, &quot;Enter the radius to kill npcs.&quot;, &quot;&quot;, 0));
+	endif
+	
+	foreach mobile in ListMobilesNearLocationEX(who.x, who.y, who.z, CInt(range), LISTEX_FLAG_NORMAL+LISTEX_FLAG_HIDDEN, who.realm)
+		if ( mobile.npctemplate )
+			ApplyRawDamage(mobile, 6000);
+		endif
+		sleepms(2);
+	endforeach
+endprogram
\ No newline at end of file

Added: trunk/096/pkg/mobiles/ai_brain/commands/gm/createnpc.src
===================================================================
--- trunk/096/pkg/mobiles/ai_brain/commands/gm/createnpc.src	2005-09-04 16:28:05 UTC (rev 55)
+++ trunk/096/pkg/mobiles/ai_brain/commands/gm/createnpc.src	2005-09-04 16:30:56 UTC (rev 56)
@@ -0,0 +1,257 @@
+use uo;
+use os;
+
+include &quot;:datafile:include/datafile&quot;;
+include &quot;:gumps:include/gumps&quot;;
+include &quot;:gumps:include/gumps_ex&quot;;
+
+const UNCACHE_BTN	:= 0xF000000;
+const DEFAULT_CATEGORY	:= &quot;None&quot;;
+
+var data_file := DFOpenDataFile(&quot;:ai_brain:createnpc&quot;, DF_CREATE);
+
+program MakeNPC(who, template)
+	if ( !template )
+		template := SelectTemplateFromGump(who);
+		if ( !template )
+			return 0;
+		endif
+	endif
+	
+	var targ := TargetCoordinates(who);
+	if ( !targ )
+		SendSysMessage(who, &quot;Cancelled&quot;);
+		return 0;
+	endif
+
+	var npc := CreateNPCFromTemplate(template, targ.x, targ.y, targ.z, 0, who.realm);
+	npc.facing := who.facing;
+	if ( npc.errortext )
+		SendSysMessage(who, &quot;Error creating NPC [&quot;+template+&quot;] -&gt; &quot;+npc.errortext);
+		return 0;
+	endif
+endprogram
+
+function SelectTemplateFromGump(who)
+	var input := GFSendGump(who, RetrieveGump(&quot;Index&quot;));
+	if ( !input )
+		SendSysMessage(who, &quot;Cancelled&quot;);
+		return 0;
+	elseif ( input[UNCACHE_BTN] )
+		foreach elem_name in DFGetElemNames(data_file)
+			data_file.DeleteElement(elem_name);
+			sleepms(2);
+		endforeach
+		
+		SendSysMessage(who, &quot;All createnpc data uncached.&quot;);
+		return 0;
+	endif
+		
+	var category_names := GetCategoryNames();
+	input := GFSendGump(who, BuildNPCGump(category_names[input[0]]));
+	if ( !input )
+		SendSysMessage(who, &quot;Cancelled&quot;);
+		return 0;
+	endif
+	
+	var elem_names := GetConfigStringKeys(ReadConfigFile(&quot;::npcdesc&quot;));
+	return elem_names[input[0]];
+endfunction
+
+function RetrieveGump(category_name)
+	if ( category_name == &quot;Index&quot; )
+		var data_elem := DFFindElement(data_file, &quot;Index&quot;);
+		var gump := data_elem.GetProp(&quot;Gump&quot;);
+		if ( !gump )
+			gump := BuildIndexGump();
+		endif
+		
+		return gump;
+	else
+		var data_elem := DFFindElement(data_file, category_name);
+		var gump := data_elem.GetProp(&quot;Gump&quot;);
+		if ( !gump )
+			gump := BuildNPCGump(category_name);
+		endif
+		
+		return gump;
+	endif
+endfunction
+
+function GetCategoryNames()
+	var data_elem := DFFindElement(data_file, &quot;Index&quot;);
+	var category_names := data_elem.GetProp(&quot;CategoryNames&quot;);
+	if ( !category_names )
+		category_names := SetupCategoryNames();
+	endif
+	
+	return category_names;
+endfunction
+
+function SetupCategoryNames()
+	var category_names := (SortNPCs().keys());
+	var data_elem := DFFindElement(data_file, &quot;Index&quot;, DF_CREATE);
+	data_elem.SetProp(&quot;CategoryNames&quot;, category_names);
+	
+	return category_names;
+endfunction
+
+function BuildIndexGump()
+	Set_Priority(100);
+	var category_names := GetCategoryNames();
+	
+	var data_elem := DFFindElement(data_file, &quot;Index&quot;, DF_CREATE);
+	data_elem.SetProp(&quot;CategoryNames&quot;, category_names);
+	
+	var bkgnd_silvertrim := GFCfgConst(&quot;BackGrounds&quot;, &quot;SILVERTRIM&quot;);
+	var bkgnd_dark_stone := GFCfgConst(&quot;BackGrounds&quot;, &quot;DARK_STONE&quot;);
+	
+	var gump := GFCreateGump();
+	GFPage(gump, 0);
+	GFResizePic(gump, 0, 0, bkgnd_silvertrim, 300, 480);
+	GFResizePic(gump, 10, 10, bkgnd_dark_stone, 280, 460);
+	var y_pos := 40;
+	var counter := 1;
+	var page_num := 1;
+	GFTextMid(gump, 10, 15, 280, 2100, &quot;NPC Categories&quot;);
+	
+	/////
+	GFAddButton(gump, 158, 445, 4002, 4003, GF_CLOSE_BTN, UNCACHE_BTN);
+	GFTextLine(gump, 193, 445, 2100, &quot;Uncache data&quot;);
+	/////
+	
+	GFPage(gump, page_num);
+	foreach category_name in (category_names)
+		GFAddButton(gump, 20, y_pos+3, 2117, 2118, GF_CLOSE_BTN, (_category_name_iter));
+		GFTextLine(gump, 40, y_pos, 2100, category_name);
+		y_pos := y_pos+20;
+		counter := counter+1;
+		
+		if ( counter &gt; 20 )
+			counter := 1;
+			y_pos := 40;
+			GFAddButton(gump, 265, 445, 2648, 2649, GF_PAGE_BTN, page_num+1);
+			page_num := page_num+1;
+			GFPage(gump, page_num);
+			GFAddButton(gump, 265, 15, 2650, 2651, GF_PAGE_BTN, page_num-1);
+		endif
+		sleepms(2);
+	endforeach
+	data_elem.SetProp(&quot;Gump&quot;, gump);
+	
+	return gump;
+endfunction
+
+function BuildNPCGump(category_name)
+	Set_Priority(100);
+	
+	var npc_list := SortNPCs();
+	if ( !npc_list.Exists(category_name) )
+		//Nifty new trick below.
+		return error{&quot;errortext&quot;:=&quot;Category name does not exist.&quot;};
+	endif
+	
+	var data_elem := DFFindElement(data_file, Lower(category_name), DF_CREATE);	
+	npc_list := npc_list[category_name];
+
+	var bkgnd_silvertrim := GFCfgConst(&quot;BackGrounds&quot;, &quot;SILVERTRIM&quot;);
+	var bkgnd_dark_stone := GFCfgConst(&quot;BackGrounds&quot;, &quot;DARK_STONE&quot;);
+	
+	var gump := GFCreateGump();
+	GFPage(gump, 0);
+	GFResizePic(gump, 0, 0, bkgnd_silvertrim, 300, 480);
+	GFResizePic(gump, 10, 10, bkgnd_dark_stone, 280, 460);
+	var y_pos := 40;
+	var counter := 1;
+	var page_num := 1;
+	GFTextMid(gump, 10, 15, 280, 2100, &quot;NPC List - &quot;+category_name);
+	GFPage(gump, page_num);
+	foreach template in (npc_list[category_name])
+		GFAddButton(gump, 20, y_pos+3, 2117, 2118, GF_CLOSE_BTN, template.pos);
+		GFTextLine(gump, 40, y_pos, template.color, template.name);
+		y_pos := y_pos+20;
+		counter := counter+1;
+
+		if ( counter &gt; 21 )
+			counter := 1;
+			y_pos := 40;
+			GFAddButton(gump, 265, 445, 2648, 2649, GF_PAGE_BTN, page_num+1);
+			page_num := page_num+1;
+			GFPage(gump, page_num);
+			GFAddButton(gump, 265, 15, 2650, 2651, GF_PAGE_BTN, page_num-1);
+		endif
+		sleepms(2);
+	endforeach
+	data_elem.SetProp(&quot;Gump&quot;, gump);
+	
+	return gump;
+endfunction
+
+function SortNPCs()
+	var data_elem := DFFindElement(data_file, &quot;Index&quot;, DF_CREATE);
+	var categories :=  data_elem.GetProp(&quot;NPCListSorted&quot;);
+	if ( categories )
+		return categories;
+	endif
+		
+	var npc_config := ReadConfigFile(&quot;::npcdesc&quot;);
+	var cfg_keys := GetConfigStringKeys(npc_config);
+
+	categories := dictionary;
+	categories[DEFAULT_CATEGORY] := array{};
+
+	foreach template_name in (cfg_keys)
+		var cfg_elem := npc_config[template_name];
+		var template := struct;
+		template.+name :=template_name;
+		template.+pos :=_template_name_iter;
+		template.+color :=GetNameColor(npc_config[template_name].alignment);
+
+		if ( !cfg_elem.category )
+			categories[DEFAULT_CATEGORY].append(template);
+		else
+			if ( Lower(TypeOf(categories[cfg_elem.category])) != &quot;array&quot; )
+				categories[cfg_elem.category] := array{};
+			endif
+
+			categories[cfg_elem.category].append(template);
+		endif
+		sleepms(2);
+	endforeach
+	
+	// This function is time consuming.. so its results get saved.	
+	data_elem.SetProp(&quot;NPCListSorted&quot;, categories);
+
+	return categories;
+endfunction
+
+function GetNameColor(reputation)
+	var reputation_cfg := ReadConfigFile(&quot;::repsys&quot;);
+	//We know the config is there - core won't start without it.
+	var reputation_elem := reputation_cfg[&quot;NameColoring&quot;];
+	if ( !reputation_elem )
+		/*
+		 * In most shards the config is setup as
+		 * NameColoring
+		 * {
+		 * // Information here
+		 * }
+		 * **---=[! Needs to be changed to !]=---**
+		 * NameColoring NameColoring
+		 * {
+		 * //Information here
+		 * }
+		 */
+		SysLog(&quot;Unable to read in repsys.cfg elem [NameColoring] -&gt;&quot;+reputation_elem.errortext);
+		SysLog(&quot;You probably don't have an elem name set for it. Thats naughty!&quot;);
+		return 0;
+	endif
+	
+	case ( reputation )
+		&quot;good&quot;:		return (GetConfigInt(reputation_elem, &quot;innocent&quot;)-1);
+		&quot;neutral&quot;:	return (GetConfigInt(reputation_elem, &quot;attackable&quot;)-1);
+		&quot;evil&quot;:		return (GetConfigInt(reputation_elem, &quot;murderer&quot;)-1);
+		 // No alignment for an npc is considered neutral
+		default: 	return (GetConfigInt(reputation_elem, &quot;attackable&quot;)-1);
+	endcase
+endfunction

Added: trunk/096/pkg/mobiles/ai_brain/commands/gm/makeswarm.src
===================================================================
--- trunk/096/pkg/mobiles/ai_brain/commands/gm/makeswarm.src	2005-09-04 16:28:05 UTC (rev 55)
+++ trunk/096/pkg/mobiles/ai_brain/commands/gm/makeswarm.src	2005-09-04 16:30:56 UTC (rev 56)
@@ -0,0 +1,60 @@
+//Example: .makeswarm [templateate] [radius] - Makes npcs on every tile in the radius around you.
+
+use uo;
+use util;
+use os;
+use util;
+
+include &quot;:gumps:include/requestgump&quot;;
+
+program MakeSwarm(who, text)
+
+	var template:=0, radius:=0;
+	if ( text ) 
+		text := SplitWords(text);
+		template := text[1];
+		radius := CInt(text[2]);
+	endif
+		
+	if ( !template )
+		template := RequestGump(who, &quot;Enter the npc template name to use.&quot;, &quot;&quot;);
+		if ( !template )
+			SendSysMessage(who, &quot;Cancelled.&quot;);
+			return 0;
+		endif
+	endif
+	if ( !radius )
+		if ( !radius )
+			radius := CInt(RequestGump(who, &quot;Enter the radius to create npcs.&quot;, &quot;&quot;, 1));
+		endif
+		if ( !radius )
+			SendSysMessage(who, &quot;Radius is less than 1. Setting to 1.&quot;);
+			radius := 1;
+		endif
+	endif
+	if ( radius &gt; 10 ) // 100 npcs
+		SendSysMessage(who, &quot;Radius exceeds 10 spaces. Setting to 10.&quot;);
+		radius := 10;
+	endif
+	
+	var start_x := who.x - CInt(radius);
+	var start_y := who.y - CInt(radius);
+	var end_x := who.x + CInt(radius);
+	var end_y := who.y + CInt(radius);
+
+	var x, y;
+	var created := 0;
+	
+	for ( x:=start_x; x&lt;=end_x; x:=x+1 )
+		for ( y:=start_y; y&lt;=end_y; y:=y+1 )
+			var npc := CreateNPCFromTemplate(template, x, y, who.z, who.realm);
+			if ( npc )
+				created := created+1;
+			endif
+			
+			sleepms(3);
+		endfor
+	endfor
+	
+	SendSysMessage(who, &quot;Done making npc swarm. Created [&quot;+created+&quot;] npcs.&quot;);
+endprogram        

Added: trunk/096/pkg/mobiles/ai_brain/commands/gm/massacre.src
===================================================================
--- trunk/096/pkg/mobiles/ai_brain/commands/gm/massacre.src	2005-09-04 16:28:05 UTC (rev 55)
+++ trunk/096/pkg/mobiles/ai_brain/commands/gm/massacre.src	2005-09-04 16:30:56 UTC (rev 56)
@@ -0,0 +1,22 @@
+//Example: .massacre [radius] - Kills npcs within the radius.
+use uo;
+use os;
+
+include &quot;:gumps:include/requestgump&quot;;
+
+program Massacre(who, range)
+	range := CInt(range);
+	if ( !range )
+		range := CInt(RequestGump(who, &quot;Enter the radius to kill npcs.&quot;, &quot;&quot;, 0));
+	endif
+	
+	var mobile_list := ListMobilesNearLocationEX(who.x, who.y, who.z, CInt(range), LISTEX_FLAG_NORMAL+LISTEX_FLAG_HIDDEN, who.realm);
+	
+	foreach mobile in (mobile_list)
+		if ( mobile.npctemplate )
+			SetObjProperty(mobile, &quot;GuardKill&quot;, 1);
+			ApplyRawDamage(mobile, 6000);
+		endif
+		sleepms(2);
+	endforeach
+endprogram

Added: trunk/096/pkg/mobiles/ai_brain/commands/gm/npcsleep.src
===================================================================
--- trunk/096/pkg/mobiles/ai_brain/commands/gm/npcsleep.src	2005-09-04 16:28:05 UTC (rev 55)
+++ trunk/096/pkg/mobiles/ai_brain/commands/gm/npcsleep.src	2005-09-04 16:30:56 UTC (rev 56)
@@ -0,0 +1,33 @@
+//Example: .npcsleep -&gt; Forces all npcs to go to sleep.
+use uo;
+use os;
+use polsys;
+
+include &quot;:gumps:include/requestgump&quot;;
+include &quot;:ai_brain:include/NPC_Commands&quot;;
+
+program PutEveryNPCToSleep(who)
+	var realm_name := RequestGump(who, &quot;Enter the realm name to put npcs to sleep on.&quot;, &quot;&quot;, who.realm);
+	var realm_info := Realms()[realm_name];
+	if ( !realm_info )
+		SendSysMessage(who, &quot;Invalid realm name.&quot;);
+		return 0;
+	endif
+	
+	//To do: Set X2 and Y2 to the realm's maximum values
+	var x1 := 1, y1 := 1, x2 := realm_info.width, y2 := realm_info.height;
+	var z1 := -120, z2 := 120;
+	
+	foreach mobile in ListObjectsInBox(x1, y1, z1, x2, y2, z2, realm_name)
+		if ( mobile.npctemplate )
+			AI_Sleep(mobile);
+		endif
+		
+		sleepms(5);
+		
+		//Clear out event responses the brain sends back to this command.
+		clear_event_queue();
+	endforeach
+	
+	SendSysMessage(who, &quot;Done telling all npcs to sleep.&quot;);
+endprogram
\ No newline at end of file

Added: trunk/096/pkg/mobiles/ai_brain/commands/gm/npcwipe.src
===================================================================
--- trunk/096/pkg/mobiles/ai_brain/commands/gm/npcwipe.src	2005-09-04 16:28:05 UTC (rev 55)
+++ trunk/096/pkg/mobiles/ai_brain/commands/gm/npcwipe.src	2005-09-04 16:30:56 UTC (rev 56)
@@ -0,0 +1,45 @@
+//Example: .npcwipe (x1) (y1) (x2) (y2) -&gt; Removes all npcs.
+use uo;
+use os;
+use polsys;
+
+include &quot;:gumps:include/requestgump&quot;;
+
+program npcwipe(who, text)
+	Set_Priority(100);
+	
+	var realm_name := RequestGump(who, &quot;Enter the realm name to perform the wipe on.&quot;, &quot;&quot;, who.realm);
+	var realm_info := Realms()[realm_name];
+	if ( !realm_info )
+		SendSysMessage(who, &quot;Invalid realm name.&quot;);
+		return 0;
+	endif
+	
+	var x1 := 1, y1 := 1, x2 := realm_info.width, y2 := realm_info.height;
+	var z1 := -120, z2 := 120;
+			
+	if ( x2 &gt; realm_info.width )
+		SendSysMessage(who, &quot;Error - X coordinate exceeds [&quot;+realm_info.width+&quot;] for realm [&quot;+realm_name+&quot;]&quot;);
+		return 0;
+	elseif ( y2 &gt; realm_info.height )
+		SendSysMessage(who, &quot;Error - Y coordinate exceeds [&quot;+realm_info.height+&quot;] for realm [&quot;+realm_name+&quot;]&quot;);
+		return 0;
+	endif
+					
+	SendSysMessage(who, &quot;Starting npc wiper [&quot; + x1 + &quot; &quot; + y1 + &quot; &quot; + x2 + &quot; &quot; + y2 + &quot;] on realm [&quot;+realm_name+&quot;]&quot;);
+	SysLog(&quot;Starting npc wiper [&quot; + x1 + &quot; &quot; + y1 + &quot; &quot; + x2 + &quot; &quot; + y2 + &quot;] on realm [&quot;+realm_name+&quot;]&quot;);
+	
+	var count := 0;
+	foreach thing in ListObjectsInBox(x1, y1, z1, x2, y2, z2, realm_name)
+		if ( thing.npctemplate )
+			SetObjProperty(thing, &quot;GuardKill&quot;, 1);
+			ApplyRawDamage(thing, 6000);
+			count := count + 1;
+			sleepms(4);
+		endif
+		sleepms(5);
+	endforeach
+	
+	SendSysMessage(who, &quot;Killed &quot; + count + &quot; NPCs&quot;);
+	SysLog(&quot;Killed &quot; + count + &quot; NPCs&quot;);
+endprogram

Added: trunk/096/pkg/mobiles/ai_brain/commands/gm/puttosleep.src
===================================================================
--- trunk/096/pkg/mobiles/ai_brain/commands/gm/puttosleep.src	2005-09-04 16:28:05 UTC (rev 55)
+++ trunk/096/pkg/mobiles/ai_brain/commands/gm/puttosleep.src	2005-09-04 16:30:56 UTC (rev 56)
@@ -0,0 +1,26 @@
+//Example: .puttosleep -&gt; Puts targetted NPC to sleep.
+use uo;
+use os;
+
+include &quot;:ai_brain:NPC_Commands&quot;;
+include &quot;include/messages&quot;;
+include &quot;include/localization&quot;;
+
+
+program command_puttosleep(who)
+	var mobile; := target(who);
+
+	SendMessage(who, MSG_TARGET_MOB, {}, MSG_COMMAND);
+
+	if ((mobile := Target(who, TGTOPT_NOCHECK_LOS)) == 0)
+		SendMessage(who, MSG_CANCELLED, {}, MSG_COMMAND);
+	endif
+
+	if (!mobile.IsA(POLCLASS_NPC))
+		SendMessage(who, MSG_NO_MOB, {}, MSG_COMMAND);
+		return 0;
+	else
+		AI_Sleep(mobile);
+		SendMessage(who, MSG_DONE, {}, MSG_COMMAND);
+	endif
+endprogram
\ No newline at end of file

Added: trunk/096/pkg/mobiles/ai_brain/commands/gm/removenpc.src
===================================================================
--- trunk/096/pkg/mobiles/ai_brain/commands/gm/removenpc.src	2005-09-04 16:28:05 UTC (rev 55)
+++ trunk/096/pkg/mobiles/ai_brain/commands/gm/removenpc.src	2005-09-04 16:30:56 UTC (rev 56)
@@ -0,0 +1,38 @@
+//Example: .removenpc [npc template] -&gt; Removes every npc of that type.
+use uo;
+use os;
+use polsys;
+
+include &quot;:gumps:include/requestgump&quot;;
+
+program NPCWipe(who, template)
+	if ( !template )
+		template := RequestGump(who, &quot;Enter the npc template name to remove.&quot;);
+		if ( !template )
+			SendSysMessage(who, &quot;Cancelled.&quot;);
+			return 0;
+		endif
+	endif
+	template := Lower(template);
+		
+	var realm_name := RequestGump(who, &quot;Enter the realm name to perform the wipe on.&quot;, &quot;&quot;, who.realm);
+	var realm_info := Realms()[realm_name];
+	if ( !realm_info )
+		SendSysMessage(who, &quot;Invalid realm name.&quot;);
+		return 0;
+	endif
+	
+	var x1 := 1, y1 := 1, x2 := realm_info.width, y2 := realm_info.height;
+	var z1 := -120, z2 := 120;
+	
+	var count := 0;
+	foreach thing in ListObjectsInBox(x1, y1, z1, x2, y2, z2, realm_name)
+		if ( Lower(thing.npctemplate) == template )
+			SetObjProperty(thing, &quot;GuardKill&quot;, 1);
+			ApplyRawDamage(thing, 8000);
+			count := count + 1;
+		endif
+		sleepms(2);
+	endforeach
+	SendSysMessage(who, &quot;Killed &quot; + count + &quot; NPCs&quot;);
+endprogram

Added: trunk/096/pkg/mobiles/ai_brain/commands/gm/resetnpcs.src
===================================================================
--- trunk/096/pkg/mobiles/ai_brain/commands/gm/resetnpcs.src	2005-09-04 16:28:05 UTC (rev 55)
+++ trunk/096/pkg/mobiles/ai_brain/commands/gm/resetnpcs.src	2005-09-04 16:30:56 UTC (rev 56)
@@ -0,0 +1,35 @@
+//Example: .resetnpcs -&gt; Restarts the AI script of every npc on the shard.
+use uo;
+use os;
+use polsys;
+
+include &quot;:ai_brain:include/NPC_Commands&quot;;
+include &quot;:gumps:include/requestgump&quot;;
+
+program ResetAllNPCs(who)
+	var realm_name := RequestGump(who, &quot;Enter the realm name to perform the wipe on.&quot;, &quot;&quot;, who.realm);
+	var realm_info := Realms()[realm_name];
+	if ( !realm_info )
+		SendSysMessage(who, &quot;Invalid realm name.&quot;);
+		return 0;
+	endif
+	
+	SysLog(&quot;Starting NPC AI reset.&quot;);
+	SendSysMessage(who, &quot;Starting NPC AI reset.&quot;);
+	
+	var x1 := 1, y1 := 1, x2 := realm_info.width, y2 := realm_info.height;
+	var z1 := -120, z2 := 120;
+	
+	foreach mobile in ListObjectsInBox( x1, y1, z1, x2, y2, z2)
+		if (mobile.npctemplate)
+			RestartScript(mobile);
+			sleepms(5);
+			
+			//Clear out event responses the brain sends back to this command.
+			clear_event_queue();
+		endif
+	endforeach
+	
+	SendSysMessage(who, &quot;Done restarting all npcs.&quot;);
+	SysLog(&quot;Finished restarting all npcs.&quot;);
+endprogram
\ No newline at end of file

Added: trunk/096/pkg/mobiles/ai_brain/commands/gm/restartnpc.src
===================================================================
--- trunk/096/pkg/mobiles/ai_brain/commands/gm/restartnpc.src	2005-09-04 16:28:05 UTC (rev 55)
+++ trunk/096/pkg/mobiles/ai_brain/commands/gm/restartnpc.src	2005-09-04 16:30:56 UTC (rev 56)
@@ -0,0 +1,8 @@
+use uo;
+
+program FixAI(who)
+	var targ := target(who);
+	var result := RestartScript(targ);
+	
+	SendSysMessage(who, &quot;Result of RestartScript(&quot;+targ.name+&quot;) -&gt;&quot;+result);
+endprogram
\ No newline at end of file

Added: trunk/096/pkg/mobiles/ai_brain/commands/gm/sendevent.src
===================================================================
--- trunk/096/pkg/mobiles/ai_brain/commands/gm/sendevent.src	2005-09-04 16:28:05 UTC (rev 55)
+++ trunk/096/pkg/mobiles/ai_brain/commands/gm/sendevent.src	2005-09-04 16:30:56 UTC (rev 56)
@@ -0,0 +1,27 @@
+//Example: .sendevent [event] -&gt; Sends an event to the targetted npc.
+use uo;
+use os;
+
+include &quot;:gumps:include/requestgump&quot;;
+
+program ControlNPC(who, event)
+	if ( !event )
+		event := CInt(RequestGump(who, &quot;Enter event value&quot;, &quot;Place a + or - at the begining if it is a number.&quot;));
+	endif
+	
+	if ( event[1] in {&quot;+&quot;, &quot;-&quot;})
+		event := CInt(event);
+	endif
+
+	var ev := struct;
+	ev.+source := who;
+	ev.+type := event;
+	
+	var targ := target(who);
+	if ( targ )
+		SendEvent(targ, ev);
+		SendSysMessage(who, &quot;Event sent as &quot;+TypeOf(event)+&quot;)&quot;);
+	else
+		SendSysMessage(who, &quot;Cancelled&quot;);
+	endif
+endprogram
\ No newline at end of file

Added: trunk/096/pkg/mobiles/ai_brain/commands/test/cfgtest.src
===================================================================
--- trunk/096/pkg/mobiles/ai_brain/commands/test/cfgtest.src	2005-09-04 16:28:05 UTC (rev 55)
+++ trunk/096/pkg/mobiles/ai_brain/commands/test/cfgtest.src	2005-09-04 16:30:56 UTC (rev 56)
@@ -0,0 +1,44 @@
+use uo;
+use os;
+use cfgfile;
+
+include &quot;:ai_brain:include/npcSettings&quot;;
+include &quot;:ai_brain:include/npcUtil&quot;;
+
+unload_scripts(&quot;&quot;);
+
+program CfgTest(who, template)
+	if  ( !template )
+		SendSysMessage(who, &quot;Error - no NPC template name was entered.&quot;);
+		return 0;
+	endif
+			
+	ShowInfo(who, &quot;###############&quot;);
+	
+	var settings := NPC_LoadTemplateSettings(template);
+	settings := NPC_GetDefaultSettings(settings);
+	foreach key in ( settings.keys() )
+		ShowInfo(who, &quot;settings[&quot;+key+&quot;] == &quot;+settings[key]);
+		sleepms(10);
+	endforeach
+	
+	ShowInfo(who, &quot;----&quot;);
+	
+	var scripts := NPC_LoadScriptSettings(template);
+	foreach key in ( scripts.keys() )
+		ShowInfo(who, &quot;scripts [&quot;+key+&quot;] == &quot;+scripts[key]);
+		sleepms(10);
+	endforeach
+	
+	ShowInfo(who, &quot;###############&quot;);
+	
+	UnloadConfigFile(&quot;::npcdesc&quot;);
+	
+endprogram
+
+function ShowInfo(who, line)
+	Print(&quot;&quot;+line);
+	SendSysMessage(who, &quot;&quot;+line, 3, 2101);
+	
+	return 1;
+endfunction

Added: trunk/096/pkg/mobiles/ai_brain/config/hatelist.cfg
===================================================================
--- trunk/096/pkg/mobiles/ai_brain/config/hatelist.cfg	2005-09-04 16:28:05 UTC (rev 55)
+++ trunk/096/pkg/mobiles/ai_brain/config/hatelist.cfg	2005-09-04 16:30:56 UTC (rev 56)
@@ -0,0 +1,10 @@
+HateList Dog
+{
+	Hates	cat
+	Hates	bird
+	Hates	chicken
+}
+
+HateList Wolf
+{
+	Hates	C
\ No newline at end of file

Added: trunk/096/pkg/mobiles/ai_brain/config/icp.cfg
===================================================================
--- trunk/096/pkg/mobiles/ai_brain/config/icp.cfg	2005-09-04 16:28:05 UTC (rev 55)
+++ trunk/096/pkg/mobiles/ai_brain/config/icp.cfg	2005-09-04 16:30:56 UTC (rev 56)
@@ -0,0 +1,30 @@
+ICP Register
+{
+	Name		Brain AI - Krane Edition
+	Version		5.0
+	Description	Advanced artificial intelligence system that allows NPCs to perform multiple actions at the same time. [P]
+	Description	The name gives credit to the Ninja Turtle's villian [P] 
+	Description	sometimes the bad guys deserve respect because of all the crap they put up with.
+	
+	Creator		Austin
+	C_Email		<A HREF="https://lists.berlios.de/mailman/listinfo/poldistro-svn">Austin at tsse.net</A>
+	
+	Maintainer	Austin
+	M_Email		<A HREF="https://lists.berlios.de/mailman/listinfo/poldistro-svn">Austin at tsse.net</A>
+	
+	//Script	cmdlevel path
+			
+	//TextCmd	cmdlevel path
+	TextCmd		3 :control:textcmd/gm/attack
+	TextCmd		3 :control:textcmd/gm/cmassacre
+	TextCmd		3 :control:textcmd/gm/createnpc
+	TextCmd		3 :control:textcmd/gm/makeswarm
+	TextCmd		3 :control:textcmd/gm/massacre
+	TextCmd		3 :control:textcmd/gm/npcsleep
+	TextCmd		3 :control:textcmd/gm/npcwipe
+	TextCmd		3 :control:textcmd/gm/puttosleep
+	TextCmd		3 :control:textcmd/gm/removenpc
+	TextCmd		3 :control:textcmd/gm/resetnpcs
+	TextCmd		3 :control:textcmd/gm/restartnpc
+	TextCmd		3 :control:textcmd/gm/sendevent
+}

Added: trunk/096/pkg/mobiles/ai_brain/include/braincore/error.inc
===================================================================
--- trunk/096/pkg/mobiles/ai_brain/include/braincore/error.inc	2005-09-04 16:28:05 UTC (rev 55)
+++ trunk/096/pkg/mobiles/ai_brain/include/braincore/error.inc	2005-09-04 16:30:56 UTC (rev 56)
@@ -0,0 +1,41 @@
+/*===============================================================
+* Current Version
+* ERROR.INC - v1.0
+* Updated 8/31/2005 5:08AM
+*
+* -- Revision v1.0 --
+* Austin:
+*  Created include file
+===============================================================*/
+
+/*
+ * FatalError(errmsg)
+ *
+ * Purpose
+ * Logs an error message and then kills the npc.
+ *
+ * Parameters
+ * errmsg:	Error message - reason for removing the npc.
+ *
+ * Return value
+ * Always returns 1
+ *
+ */
+function FatalError(errmsg)
+	set_critical(1);
+	
+	PrintTextAbove(npc, errmsg, _DEFAULT_TEXT_FONT, 32);
+	
+	NPC_ErrorSysLog(npc, errmsg);
+	
+	npc.cmdlevel := 1;
+	npc.concealed := 1;
+	
+	npc.disable(&quot;invul&quot;);
+	SetObjProperty(npc, &quot;GuardKill&quot;, 1);
+	ApplyRawDamage(npc, GetVitalMaximumValue(npc, &quot;Hits&quot;));
+	
+	set_critical(0);
+	
+	return 1;
+endfunction

Added: trunk/096/pkg/mobiles/ai_brain/include/braincore/eventProcessor.inc
===================================================================
--- trunk/096/pkg/mobiles/ai_brain/include/braincore/eventProcessor.inc	2005-09-04 16:28:05 UTC (rev 55)
+++ trunk/096/pkg/mobiles/ai_brain/include/braincore/eventProcessor.inc	2005-09-04 16:30:56 UTC (rev 56)
@@ -0,0 +1,299 @@
+/*===============================================================
+* Current Version
+* EVENTPROCESSOR.INC - v1.0
+* Updated 9/1/2005 6:20AM
+*
+* -- Revision v1.0 --
+* Austin:
+*  Created include file
+===============================================================*/
+
+function ProcessEvent(byref event)
+	var old_priority := set_priority(25);
+	
+	case( event.type )
+		//
+		// *Check movement first, since its the event that seems to be sent most often.
+		//
+		
+		// Move NPC
+		// .source	: From/To whom/what?
+		// .speed	: Walk/Run
+		// .direction	: Away/Towards
+		// .loop	: Number of times to attempt to loop the movement.
+		NPCEVENT_MOVE:
+			Movement(event);
+			break;
+			
+		// Instructs the npc to walk toward an XY coordinate.
+		// .x and .y	: From/To  coordinates
+		// .speed	: Walk/Run
+		// .direction	: Away/Towards
+		// .loop	: Number of times to attempt to loop the movement.
+		NPCEVENT_MOVE_XY:
+			MovementXY(event);
+			break;
+			
+		// Wander somewhere
+		// .loop	: Number of times to attept to wander.
+		NPCEVENT_WANDER:
+	   		MovementWander(event);
+	   		break;
+		
+		//
+		// * Check System Events that the core sends.
+		//
+			
+		// Triggered when a mobile enter's the npcs 'area size'.
+		// .source	: What entered the area
+		SYSEVENT_ENTEREDAREA:
+			if ( g_scripts.Exists(&quot;EnterArea&quot;) )
+				var process := GetNerveProcess(npc, &quot;EnterArea&quot;, g_nerves);
+				if ( !process )
+					StartNerve(npc, &quot;EnterArea&quot;, g_scripts[&quot;EnterArea&quot;].script, {event, g_settings, g_scripts}, g_scripts[&quot;EnterArea&quot;].flags, g_nerves);
+				else
+					process.SendEvent(event);
+				endif
+			endif
+			break;
+			
+		// Triggered when a mobile leaves the npc's 'area size'.
+		// .source	: What left the area
+		SYSEVENT_LEFTAREA:
+			if ( g_scripts.Exists(&quot;LeftArea&quot;) )
+				var process := GetNerveProcess(npc, &quot;LeftArea&quot;, g_nerves);
+				if ( !process )
+					StartNerve(npc, &quot;LeftArea&quot;, g_scripts[&quot;LeftArea&quot;].script, {event, g_settings, g_scripts}, g_scripts[&quot;LeftArea&quot;].flags, g_nerves);
+				else
+					process.SendEvent(event);
+				endif
+			endif
+			break;
+			
+		// Someone has changed from blue to gray/red and was already within the ENTERED_AREA range
+		// .source	: What changed criminal status.
+		SYSEVENT_GONE_CRIMINAL:
+			if ( g_scripts.Exists(&quot;ItemGiven&quot;) )
+				var process := GetNerveProcess(npc, &quot;ItemGiven&quot;, g_nerves);
+				if ( !process )
+					StartNerve(npc, &quot;ItemGiven&quot;, g_scripts[&quot;ItemGiven&quot;].script, {event, g_settings, g_scripts}, g_scripts[&quot;ItemGiven&quot;].flags, g_nerves);
+				else
+					process.SendEvent(event);
+				endif
+			endif
+			break;
+			
+		// Sent when something targets the npc to begin combat or
+		// when something has damaged the npc.
+		// .source	: What caused the damage or engaged the npc
+		// For SYSEVENT_DAMAGED
+		// .damaged	: Integer amount of damage.
+		SYSEVENT_ENGAGED:
+		SYSEVENT_DAMAGED:
+			if ( g_scripts.Exists(&quot;Combat&quot;) )
+				if ( (event.source).ISA(POLCLASS_MOBILE) )
+					var process := GetNerveProcess(npc, &quot;Combat&quot;, g_nerves);
+					if ( !process )
+						StartNerve(npc, &quot;Combat&quot;, g_scripts[&quot;Combat&quot;].script, {event, g_settings, g_scripts}, g_scripts[&quot;Combat&quot;].flags, g_nerves);
+					else
+						process.SendEvent(event);
+					endif
+				endif
+			endif
+			break;
+			
+		// Instructs the npc to run its disengage nerve.
+		// When something attacking it goes out of warmode, this is run.
+		// .source	: What was targetting this npc but has now left combat mode.
+		SYSEVENT_DISENGAGED:
+			if ( g_scripts.Exists(&quot;Disengaged&quot;) )
+				var process := GetNerveProcess(npc, &quot;Disengaged&quot;, g_nerves);
+				if ( !process )
+					StartNerve(npc, &quot;Disengaged&quot;, g_scripts[&quot;Disengaged&quot;].script, {event, g_settings, g_scripts}, g_scripts[&quot;Disengaged&quot;].flags, g_nerves);
+				else
+					process.SendEvent(event);
+				endif
+			endif
+			break;
+			
+		// When speech is made by a player, this nerve is used.
+		// Note: The NPC function Say() doesnt yet pass around the speech event.
+		// .source	: Where the speech originated.
+		// .text	: The actual speech
+		// .uc_text	: a &quot;Unicode array&quot; of 2-byte &quot;Big Endian&quot; integers.
+		// .langcode	: a 3-character, uppercase language code.
+		// .texttype	: &quot;yell&quot;, &quot;whisper&quot;, &quot;emote&quot;, &quot;default&quot;.
+		SYSEVENT_SPEECH:
+		SYSEVENT_GHOST_SPEECH:
+			if( g_scripts.Exists(&quot;Listen&quot;) )
+				var process := GetNerveProcess(npc, &quot;Listen&quot;, g_nerves);
+				if ( !process )
+					StartNerve(npc, &quot;Listen&quot;, g_scripts[&quot;Listen&quot;].script, {event, g_settings, g_scripts}, g_scripts[&quot;Listen&quot;].flags, g_nerves);
+				else
+					process.SendEvent(event);
+				endif
+			endif
+			break;
+			
+		// Instructs the npc to run its double click script.
+		// Run when the npc is double clicked by a player.
+		// .source	: What sent the double click
+		SYSEVENT_DOUBLECLICKED:
+			if ( g_scripts.Exists(&quot;DblClick&quot;) )
+				if ( Distance(event.source, npc) &lt;= g_settings[&quot;dbl_click_range&quot;] )
+					var process := GetNerveProcess(npc, &quot;DblClick&quot;, g_nerves);
+					if ( !process )
+						StartNerve(npc, &quot;DblClick&quot;, g_scripts[&quot;DblClick&quot;].script, {event, g_settings, g_scripts}, g_scripts[&quot;DblClick&quot;].flags, g_nerves);
+					else
+						process.SendEvent(event);
+					endif
+				endif
+			endif
+			break;
+			
+		// The NPC is a merchant, and has sold or purchased something.
+		// Both sold and bought events are sent to this same nerve.
+		// The best thing to do is fork it into two functions inside the
+		// nerve script to handle each event type.
+		// MERCHANT_SOLD means the merchant sold an item to the player.
+		// MERCHANT_BOUGHT means the merchatn bought something from the player.
+		//
+		// .source	: Who the merchant is selling to/buying from.
+		// .amount	: Gold amount for the sale/purchase.
+		SYSEVENT_MERCHANT_SOLD:
+		SYSEVENT_MERCHANT_BOUGHT:
+			if ( g_scripts.Exists(&quot;Merchant&quot;) )
+				var process := GetNerveProcess(npc, &quot;Merchant&quot;, g_nerves);
+				if ( !process )
+					StartNerve(npc, &quot;Merchant&quot;, g_scripts[&quot;Merchant&quot;].script, {event, g_settings, g_scripts}, g_scripts[&quot;Merchant&quot;].flags, g_nerves);
+				else
+					process.SendEvent(event);
+				endif
+			endif
+			break;
+			
+		// Someone has dragged an item onto the npc.
+		// .source	: What dragged the item over the npc.
+		// .item	: The item being given to the npc.
+		SYSEVENT_ITEM_GIVEN:
+			if ( g_scripts.Exists(&quot;ItemGiven&quot;) )
+				var process := GetNerveProcess(npc, &quot;ItemGiven&quot;, g_nerves);
+				if ( !process )
+					StartNerve(npc, &quot;ItemGiven&quot;, g_scripts[&quot;ItemGiven&quot;].script, {event, g_settings, g_scripts}, g_scripts[&quot;ItemGiven&quot;].flags, g_nerves);
+				else
+					process.SendEvent(event);
+				endif
+			endif
+			break;
+			
+		//
+		// * Check custom events
+		//
+		//A nerve has instructed the brain to kill another nerve or its self.
+		// .name	: Nerve name
+		NPCEVENT_ENDNERVE:
+			StopNerve(npc, event.name, g_nerves);
+			break;
+			
+		//A nerve has instructed the brain to start another nerve.
+		// .name	: Nerve name
+		// .script	: Nerve script
+		// .data	: array of goodies
+		NPCEVENT_STARTNERVE:
+			StartNerve(npc, event.name, event.script, event.data, event.flags, g_nerves);
+			break;
+			
+		// Set a new opponent!
+		// NOTE: Auto-sets Warmode=1!
+		// .source	: Opponent (mobile)
+		NPCEVENT_OPPONENT:
+			SetOpponent(event.source);
+			break;
+			
+		// Say something
+		// .text	: Speech content
+		// .texttype	: Speech type (&quot;default&quot;, &quot;whisper&quot;, yell&quot;)
+		// .doevent	: Sends SYSEVENT_SPEECH to surrounding npcs
+		NPCEVENT_SPEAK:
+			Say(event.text, event.texttype, event.doevent);
+			break;
+			
+		// Turn toward something
+		// .source	: Target (anything)
+		// .direction	: NETURN_TOWARD or NETURN_AWAY
+		NPCEVENT_TURN:
+			case (event.direction)
+				NETURN_TOWARD:
+					TurnToward(event.source);
+				NETURN_AWAY:
+					TurnAwayFrom(event.source);
+			endcase
+			break;
+			
+		// Face towards or away from XY coordinates.
+		// .x and .y replace .source for TURN_XY
+		// .direction	: NETURN_TOWARD or NETURN_AWAY
+		NPCEVENT_TURN_XY:
+			case (event.direction)
+				NETURN_TOWARD:
+					TurnTowardLocation(event.x, event.y);
+				NETURN_AWAY:
+					TurnAwayFromLocation(event.x, event.y);
+			endcase
+			break;
+			
+		// Set WarMode state
+		// NOTE: Auto-clears Opponent if turned off!
+		// .value : 0=Off. 1=On.
+		NPCEVENT_WARMODE:
+			SetWarmode( event.value );
+			break;
+	   		
+	   	// Force the npc to go into its sleep mode.
+	   	// If the next event in the queue tells it to wake up,
+	   	// this command will be useless.
+	   	NPCEVENT_SLEEP:
+	   		//idle_ticks := g_settings[&quot;idle_ticks&quot;]+1;
+	   		break;
+	   		
+	   	// Force the npc out of sleep mode.
+	   	NPCEVENT_WAKEUP:
+	   		//sleep_mode := 0;
+	   		//idle_ticks := 0;
+	   		break;
+	   		
+	   	// Forward an event from one nerve to another.
+	   	// .NerveName	: The name of the nerve to forward the event to.
+	   	// .mask	: Type of event for the nerve to receive.
+	   	// .data	: Data to forward to the nerve.
+	   	NPCEVENT_FWDNERVE:
+	   	var process := GetNerveProcess(npc, event.NerveName, g_nerves);
+			if ( process )
+				process.SendEvent(event);
+			endif
+			break;
+			
+		// If the event .type is unknown, send it to the
+		// npc's &quot;virtual&quot; nerve if it has one.
+	   	default:
+	   		if ( g_scripts.Exists(&quot;Virtual&quot;) )
+	   			var process := GetNerveProcess(npc, &quot;Virtual&quot;, g_nerves);
+				if ( !process )
+					StartNerve(npc, &quot;Virtual&quot;, g_scripts[&quot;Virtual&quot;].script, {event, g_settings, g_scripts}, g_scripts[&quot;Virtual&quot;].flags, g_nerves);
+				else
+					process.SendEvent(event);
+				endif
+			endif
+			break;
+	   endcase
+
+	   // If the event has a .process member, reply to it by sending
+	   // an event with .type being the NPCEVENT_DONE constant
+	   // and telling it what event it sent that has finished
+	   // being processed.
+	   if ( event.process )
+	   	(event.process).SendEvent(struct{&quot;type&quot;:=NPCEVENT_DONE, &quot;source&quot;:=event.type});
+	   endif
+	   
+	   set_priority(old_priority);
+endfunction

Added: trunk/096/pkg/mobiles/ai_brain/include/braincore/movement.inc
===================================================================
--- trunk/096/pkg/mobiles/ai_brain/include/braincore/movement.inc	2005-09-04 16:28:05 UTC (rev 55)
+++ trunk/096/pkg/mobiles/ai_brain/include/braincore/movement.inc	2005-09-04 16:30:56 UTC (rev 56)
@@ -0,0 +1,168 @@
+/*===============================================================
+* Current Version
+* MOVEMENT.INC - v1.0
+* Updated 9/1/2005 6:42AM
+*
+* -- Revision v1.0 --
+* Austin:
+*  Created include file
+===============================================================*/
+
+/*
+ * Movement(ev)
+ *
+ * Purpose
+ * Handles NPC movenpcnt to/from an object for the brain.
+ *
+ * Parameters
+ * ev:	Strucuture containing event information.
+ *
+ * Return value
+ * Always returns 1
+ *
+ */
+function Movement(ev)
+	var old_pri := set_priority(50);
+	
+	case ( ev.speed )
+		NEMOVE_WALK:
+			case ( ev.direction )
+				NEMOVE_AWAY:
+					repeat
+						WalkAwayFrom(ev.source);
+						sleepms(3);
+					until ( !MoveLoopCheck(ev) );
+				NEMOVE_TOWARD:
+					repeat
+						WalkToward(ev.source);
+						sleepms(3);
+					until ( !MoveLoopCheck(ev) );
+			endcase	
+		NEMOVE_RUN:
+			case( ev.direction )
+				NEMOVE_AWAY:
+					repeat
+						RunAWayFrom(ev.source);
+						sleepms(3);
+					until ( !MoveLoopCheck(ev) );	
+				NEMOVE_TOWARD:
+					repeat
+						RunToward(ev.source);
+						sleepms(3);
+					until ( !MoveLoopCheck(ev) );
+			endcase
+	endcase
+	
+	set_priority(old_pri);
+	
+	return 1;
+endfunction
+
+/*
+ * MovementXY(ev)
+ *
+ * Purpose
+ * Handles NPC movement to/from a coordinate for the brain.
+ *
+ * Parameters
+ * ev:	Strucuture containing event information.
+ *
+ * Return value
+ * Always returns 1
+ *
+ */
+function MovementXY(ev)
+	var old_pri := set_priority(50);
+	
+	case ( ev.speed )
+		NEMOVE_WALK:
+			case ( ev.direction )
+				NEMOVE_AWAY:
+					repeat
+						WalkAwayFromLocation(ev.x, ev.y);
+						sleepms(3);
+					until ( !MoveLoopCheck(ev) );
+				NEMOVE_TOWARD:
+					repeat
+						WalkTowardLocation(ev.x, ev.y);
+						sleepms(3);
+					until ( !MoveLoopCheck(ev) );
+			endcase	
+		NEMOVE_RUN:
+			case( ev.direction )
+				NEMOVE_AWAY:
+					repeat
+						RunAwayFromLocation(ev.x, ev.y);
+						sleepms(3);
+					until ( !MoveLoopCheck(ev) );	
+				NEMOVE_TOWARD:
+					repeat
+						RunTowardLocation(ev.x, ev.y);
+						sleepms(3);
+					until ( !MoveLoopCheck(ev) );
+			endcase
+	endcase
+	
+	set_priority(old_pri);
+	
+	return 1;
+endfunction
+
+/*
+ * MovementWander(ev)
+ *
+ * Purpose
+ * Handles NPC wander movement for the brain.
+ *
+ * Parameters
+ * ev:	Strucuture containing event information.
+ *
+ * Return value
+ * Always returns 1
+ *
+ */
+function MovementWander(ev)
+	repeat
+		Wander();
+		sleepms(3);
+	until ( !MoveLoopCheck(ev) );
+endfunction
+
+/*
+ * MoveLoop(ev)
+ *
+ * Purpose
+ * Determines if the npc should continue trying to move
+ * or if something else needs the brain's attention.
+ *
+ * Parameters
+ * ev:	Strucuture containing event information.
+ *
+ * Return value
+ * Returns 1 if the npc may continue moving.
+ *
+ */
+function MoveLoopCheck(byref ev)
+	if ( Events_Waiting() )
+		return 0;
+	elseif ( ev.loop &lt; 1 )
+		return 0;
+	elseif ( npc.frozen )
+		return 0;
+	elseif ( npc.paralyzed )
+		return 0;
+	endif
+	if ( ev.source )
+		// Dont need to worry about distance in an XY movement check. 
+		// It wont run in circles around XY coordinates like it does an object.
+		if ( ev.direction == NEMOVE_TOWARD )
+			if ( Distance(npc, ev.source) &lt;= 1 )
+				return 0;
+			endif
+		endif
+	endif
+	
+	ev.loop := ev.loop-1;
+	
+	return 1;
+endfunction

Added: trunk/096/pkg/mobiles/ai_brain/include/braincore/setup.inc
===================================================================
--- trunk/096/pkg/mobiles/ai_brain/include/braincore/setup.inc	2005-09-04 16:28:05 UTC (rev 55)
+++ trunk/096/pkg/mobiles/ai_brain/include/braincore/setup.inc	2005-09-04 16:30:56 UTC (rev 56)
@@ -0,0 +1,133 @@
+/*===============================================================
+* Current Version
+* SETUP.INC - v1.0
+* Updated 8/31/2005 4:54AM
+*
+* -- Revision v1.0 --
+* Austin:
+*  Created include file
+===============================================================*/
+
+/*
+ * InitializeSettings()
+ * 
+ * Purpose
+ * Initializes g_settings in the brain.
+ *
+ * Parameters
+ *
+ * Return value
+ * Always returns 1
+ *
+ */
+function InitializeSettings()
+	
+	g_settings := NPC_LoadTemplateSettings(npc);
+	g_settings := NPC_GetDefaultSettings(g_settings);
+	g_settings := NPC_LoadScriptSettings(npc);
+		
+	return 1;
+endfunction
+
+/*
+ * InitializeEvents()
+ *
+ * Purpose
+ * Enables system events the core sends based on g_settings
+ *
+ * Parameters
+ *
+ * Return value
+ * Always returns 1
+ *
+ */
+function InitializeEvents()
+	//
+	// * Events that use the core 'speech' range.
+	//
+	if ( g_scripts.Exists(&quot;Listen&quot;) )
+		if ( g_settings[&quot;HearSpeech&quot;] )
+			EnableEvents(SYSEVENT_SPEECH, g_settings[&quot;ListenRange&quot;]);
+		endif
+		if ( g_settings[&quot;HearGhosts&quot;] )
+			EnableEvents(SYSEVENT_GHOST_SPEECH, g_settings[&quot;ListenRange&quot;]);
+		endif
+	endif
+		
+	//
+	// * Events that use the core 'area size' range.
+	//
+	if ( g_scripts.Exists(&quot;EnterArea&quot;) )
+		EnableEvents(SYSEVENT_ENTEREDAREA, g_settings[&quot;AreaSize&quot;]);
+	endif
+	if ( g_scripts.Exists(&quot;LeftArea&quot;) )
+		EnableEvents(SYSEVENT_LEFTAREA, g_settings[&quot;AreaSize&quot;]);
+	endif
+	if ( g_scripts.Exists(&quot;GoneCriminal&quot;) )
+		EnableEvents(SYSEVENT_GONE_CRIMINAL, g_settings[&quot;AreaSize&quot;]);
+	endif
+	
+	//
+	// * Events that do not have a core range check.
+	//
+	if ( g_scripts.Exists(&quot;DblClick&quot;) )
+		EnableEvents(SYSEVENT_DOUBLECLICKED);
+	endif
+	if ( g_scripts.Exists(&quot;ItemGiven&quot;) )
+		EnableEvents(SYSEVENT_ITEM_GIVEN);
+	endif
+	if ( g_scripts.Exists(&quot;Disengaged&quot;) )
+		EnableEvents(SYSEVENT_DISENGAGED);
+	endif
+	if ( g_scripts.Exists(&quot;Merchant&quot;) )
+		EnableEvents(SYSEVENT_MERCHANT_BOUGHT);
+		EnableEvents(SYSEVENT_MERCHANT_SOLD);
+	endif
+	if ( g_scripts.Exists(&quot;Combat&quot;) )
+		EnableEvents(SYSEVENT_ENGAGED+SYSEVENT_DAMAGED);
+	endif
+	
+	return 1;
+endfunction
+
+/*
+ * StartupScripts()
+ *
+ * Purpose
+ * Runs the restart_script or init_script. Sets up the npc_info cprop.
+ *
+ * Parameters
+ *
+ * Return value
+ * Returns 1 on success
+ *
+ */
+function StartupScripts()
+	if ( GetObjProperty(npc, &quot;npc_info&quot;) )
+		//This can only happen if restart() was done on the npc or when POL starts up.
+		
+		SetWarmode(0);
+		//StopNerves();
+		
+		if ( g_scripts.Exists(&quot;restart_script&quot;) )
+			var restart_script := Run_Script_To_Completion(g_scripts[&quot;restart_script&quot;], {npc, g_settings});
+			if ( restart_script.errortext )
+				FatalError(&quot;Restart script failed:&quot;+restart_script.errortext);
+				return 0;
+			endif
+		endif
+	else
+		var npc_info := struct{&quot;npctemplate&quot;:=npc.npctemplate, &quot;serial&quot;:=npc.serial};
+		SetObjProperty(npc, &quot;npc_info&quot;, npc_info);
+		
+		if ( g_scripts.Exists(&quot;init_script&quot;) )
+			var init_script := Run_Script_To_Completion(g_scripts[&quot;init_script&quot;], {npc, g_settings});
+			if ( init_script.errortext )
+				FatalError(&quot;Init script failed:&quot;+init_script.errortext);
+				return 0;
+			endif
+		endif
+	endif
+	
+	return 1;
+endfunction
\ No newline at end of file

Added: trunk/096/pkg/mobiles/ai_brain/include/eventid.inc
===================================================================
--- trunk/096/pkg/mobiles/ai_brain/include/eventid.inc	2005-09-04 16:28:05 UTC (rev 55)
+++ trunk/096/pkg/mobiles/ai_brain/include/eventid.inc	2005-09-04 16:30:56 UTC (rev 56)
@@ -0,0 +1,70 @@
+/*===============================================================
+* Current Version
+* EVENTID.INC - v1.0
+* Updated 8/31/2005 5:50AM
+*
+* -- Revision v1.0 --
+* Austin:
+*  Created include file
+===============================================================*/
+
+//
+// * Custom brain AI event IDs
+//
+const NPCEVENT_MOVE				:= 0xA00003;	// Has NEMOVE_* helper constants
+const NPCEVENT_OPPONENT				:= 0xA00004;	// Set New Opponent (.source)
+const NPCEVENT_SPEAK				:= 0xA00005;	// Speak (.text)
+const NPCEVENT_TURN				:= 0xA00006;	// Turn towards or away from an object
+const NPCEVENT_WARMODE				:= 0xA00007;	// Set WarMode state (.value=0|1)
+const NPCEVENT_ATTACK				:= 0xA0000A;	// Tell the npc to attack something
+const NPCEVENT_MOVE_XY				:= 0xA0000B;	// Tell the NPC to move to coordinates
+const NPCEVENT_TURN_XY				:= 0xA0000C;	// Tell the NPC to turn towards coordinates
+const NPCEVENT_WANDER				:= 0xA0000D;	// Tell the npc to wander
+
+const NPCEVENT_ENDNERVE				:= 0xA0000F;	// Tell the brain to stop a nerve.
+const NPCEVENT_STARTNERVE			:= 0xA00010;	// Tell the brain to start a nerve.
+const NPCEVENT_DONE				:= 0xA00011;	// Brain tells a nerve that its instruction is done.
+
+const NPCEVENT_SLEEP				:= 0xA00012;	// Tell the brain to go to sleep.
+const NPCEVENT_WAKEUP				:= 0xA00013;	// Tell the brain to wake up.
+
+const NPCEVENT_FWDNERVE				:= 0xA00014;	// Tell the brain to forward an event to a nerve.
+
+//
+// * NPCEVENT_MOVE helper constants (.source = object)
+//
+const NEMOVE_WALK				:= 1;	// .speed (default)
+const NEMOVE_RUN				:= 2;	// .speed
+const NEMOVE_TOWARD 				:= 1;	// .direction (default)
+const NEMOVE_AWAY				:= 2;	// .direction
+
+//
+// * NE_TURN helper constants
+//
+const NETURN_TOWARD				:= 1;
+const NETURN_AWAY				:= 2;
+
+//
+// * AWAKEN CONSTANTS
+// 
+const WAKEUP					:= 0;
+const NOWAKE					:= 1;
+
+//
+// * CLEAR THOUGHT CONSTANTS
+//
+const CLR_BRAIN					:= 1;
+const CLR_NERVE					:= 2;
+const CLR_BOTH					:= 3;
+
+//
+//* NPC.EM constants (only brain can access npc.em)
+//
+// Constants for texttype flags in the AI_Speak() function
+const SPEAK_TEXTTYPE_DEFAULT			:= &quot;default&quot;;
+const SPEAK_TEXTTYPE_WHISPER			:= &quot;whisper&quot;;
+const SPEAK_TEXTTYPE_YELL			:= &quot;yell&quot;;
+
+// Constants for doevent flag in AI_Speak() function
+const SPEAK_DOEVENT_DISABLE			:= 0x0;
+const SPEAK_DOEVENT_ENABLE			:= 0x1;

Added: trunk/096/pkg/mobiles/ai_brain/include/npcCommands.inc
===================================================================
--- trunk/096/pkg/mobiles/ai_brain/include/npcCommands.inc	2005-09-04 16:28:05 UTC (rev 55)
+++ trunk/096/pkg/mobiles/ai_brain/include/npcCommands.inc	2005-09-04 16:30:56 UTC (rev 56)
@@ -0,0 +1,520 @@
+/*===============================================================
+* Current Version
+* NPC_COMMANDS.INC - v1.0
+* Updated 8/31/2005 6:38AM
+*
+* -- Revision v1.0 --
+* Austin:
+*  Created include file
+===============================================================*/
+
+use uo;
+use os;
+
+include &quot;include/sysEvent&quot;;
+include &quot;:ai_brain:include/eventid&quot;;
+
+/////////////////////////////////////////////////////////////////
+// * Function List *
+//
+// AI_Attack(mobile, opponent, no_wake:=WAKEUP)
+// AI_ClearThoughts(mobile, flags)
+// AI_EndNerve(mobile, nerve_name, no_wake:=WAKEUP)
+// AI_Flee(mobile, opponent, no_wake:=WAKEUP)
+// AI_FowardEvent(mobile, nerve_name, mask, data, no_wake:=WAKEUP)
+// AI_Move(mobile, object, to_from:=NEMOVE_TOWARD, speed:=NEMOVE_RUN, no_wake:=WAKEUP, loop:=0)
+// AI_MoveXY(mobile, x, y, to_from:=NEMOVE_TOWARD, speed:=NEMOVE_RUN, no_wake:=WAKEUP, loop:=0)
+// AI_SetOpponent(mobile, opponent, no_wake:=WAKEUP)
+// AI_Sleep(mobile)
+// AI_Speak(mobile, text, text_type:=SPEAK_TEXTTYPE_DEFAULT, do_event:=SPEAK_DOEVENT_DISABLE, no_wake:=WAKEUP)
+// AI_StartNerve(mobile, nerve_name, script_name, data, no_wake:=WAKEUP)
+// AI_Turn(mobile, turn_to, direction:=NETURN_TOWARD, no_wake:=WAKEUP)
+// AI_TurnXY(mobile, x, y, direction:=NETURN_TOWARD, no_wake:=WAKEUP)
+// AI_WakeUp(mobile)
+// AI_Wander(mobile, no_wake:=WAKEUP, loop:=0)
+// AI_WarMode(mobile, mode:=0, no_wake:=WAKEUP)
+// 
+/////////////////////////////////////////////////////////////////
+
+/*
+ * AI_Attack(mobile, opponent, no_wake)
+ *
+ * Purpose
+ * Triggers the npc's combat script on opponent.
+ *
+ * Parameters
+ * mobile:	The npc that will receive the command.
+ * opponent:	What the npc's combat nerve will attack.
+ * no_wake:	Optional wakeup flag:
+ *		WAKEUP - Will stop the sleep script if it is running - Default.
+ *		NOWAKE - Will not stop the sleep script if it is running.
+ *
+ * Return value
+ * Result of SendEvent()
+ *
+ */
+function AI_Attack(mobile, opponent, no_wake:=WAKEUP)
+	var ev		:= struct;
+	ev.+type	:= SYSEVENT_ENGAGED;
+	ev.+source	:= opponent;
+	ev.+WakeUp	:= no_wake;
+	ev.+process	:= GetProcess(GetPid());
+
+	return SendEvent(mobile, ev);
+endfunction
+
+/*
+ * AI_ClearThoughts(mobile, flags)
+ *
+ * Purpose
+ * Clears the event queue for the script calling it and or the brain.
+ *
+ * Parameters
+ * mobile:	A reference to the npc.
+ * flags:	CLR_* flag for what scripts should have their event queues cleared.
+ *		CLR_BRAIN - Clears the brain's queue.
+ *		CLR_NERVE - Clears the nerve's queue.
+ *		CLR_BOTH  - Clears the queue for both.
+ *
+ * Return value
+ * Always returns 1
+ *
+ */
+function AI_ClearThoughts(mobile, flags)
+	var brain	:= flags &amp; CLR_BRAIN;
+	var nerve	:= flags &amp; CLR_NERVE;
+	var both	:= flags &amp; CLR_BOTH;
+
+	if ( both || brain )
+		brain := mobile.process;
+		brain.clear_event_queue();
+	endif
+
+	if ( both || nerve )
+		nerve := GetProcess(GetPid());
+		nerve.clear_event_queue();
+	endif
+
+	return 1;
+endfunction
+
+/*
+ * AI_EndNerve(mobile, nerve_name, no_wake)
+ *
+ * Purpose
+ * Used to tell the brain to stop a nerve script.
+ *
+ * Parameters
+ * mobile:	The npc that will receive the command.
+ * nerve_name:	String containing the name of the nerve (dictionary key).
+ * no_wake:	Optional wakeup flag:
+ *		WAKEUP - Will stop the sleep script if it is running - Default.
+ *		NOWAKE - Will not stop the sleep script if it is running.
+ *
+ * Return value
+ * Result of SendEvent()
+ *
+ */
+function AI_EndNerve(mobile, nerve_name, no_wake:=WAKEUP)
+	var ev		:= struct;
+	ev.+type	:= NPCEVENT_ENDNERVE;
+	ev.+name	:= nerve_name;
+	ev.+WakeUp	:= no_wake;
+	ev.+process	:= GetProcess(GetPid());
+
+	return SendEvent(mobile, ev);
+endfunction
+
+/*
+ * AI_Flee(mobile, opponent, no_wake)
+ *
+ * Purpose
+ * Used to tell the brain to stop a nerve script.
+ *
+ * Parameters
+ * mobile:	The npc that will receive the command.
+ * opponent:	Opponent to flee from.
+ * no_wake:	Optional wakeup flag:
+ *		WAKEUP - Will stop the sleep script if it is running - Default.
+ *		NOWAKE - Will not stop the sleep script if it is running.
+ *
+ * Return value
+ * Result of SendEvent()
+ *
+ */
+function AI_Flee(mobile, opponent, no_wake:=WAKEUP)
+	var ev		:= struct;
+	ev.+type	:= NPCEVENT_FLEE;
+	ev.+source	:= opponent;
+	ev.+WakeUp	:= no_wake;
+	ev.+process	:= GetProcess(GetPid());
+
+	return SendEvent(mobile, ev);
+endfunction
+
+/*
+ * AI_ForwardEvent(mobile, nerve_name, mask, data, no_wake)
+ *
+ * Purpose
+ * Used to send an event from one nerve to another.
+ *
+ * Parameters
+ * mobile:	The npc that will receive the command.
+ * nerve_name:	String containing the name of the nerve to forward the event to (dictionary key).
+ * mask:	The type of event the nerve should handle the forward as. (example: SYSEVENT_LEFTAREA)
+ * data:	Data that the nerve will receive.
+ * no_wake:	Optional wakeup flag:
+ *		WAKEUP - Will stop the sleep script if it is running - Default.
+ *		NOWAKE - Will not stop the sleep script if it is running.
+ *
+ * Return value
+ * Result of SendEvent()
+ *
+ */
+function AI_FowardEvent(mobile, nerve_name, mask, data, no_wake:=WAKEUP)
+	var ev		:= struct;
+	ev.+type	:= NPCEVENT_FWDNERVE;
+	ev.+NerveName	:= nerve_name;
+	ev.+mask	:= mask;
+	ev.+data	:= data;
+	ev.+WakeUp	:= no_wake;
+	ev.+process	:= GetProcess(GetPid());
+
+	return SendEvent(mobile, ev);
+endfunction
+
+/*
+ * AI_Move(mobile, opponent, to_from, speed, no_wake, loop)
+ *
+ * Purpose
+ * Commands an npc to move toward / away from an item or mobile.
+ *
+ * Parameters
+ * mobile:	The npc that will receive the command.
+ * object:	Item or mobile the npc will move away from/toward.
+ * to_from:	Direction the npc will go:
+ *		NEMOVE_TOWARD - Will make the npc move toward the object - Default
+ *		NEMOVE_AWAY   - Will make the npc move away from the object.
+ * speed:	Speed the npc will move at:
+ *		NEMOVE_RUN  - NPC will run
+ *		NEMOVE_WALK - NPC will walk
+ * no_wake:	Optional wakeup flag::
+ *		WAKEUP - Will stop the sleep script if it is running - Default.
+ *		NOWAKE - Will not stop the sleep script if it is running.
+ * loop:	Number of steps for the npc to take toward/away from the object.
+ *		Note: Loop can be interrupted and end prematurely!
+ *
+ * Return value
+ * Result of SendEvent()
+ *
+ */
+function AI_Move(mobile, object, to_from:=NEMOVE_TOWARD, speed:=NEMOVE_RUN, no_wake:=WAKEUP, loop:=0)
+	var ev		:= struct;
+	ev.+type	:= NPCEVENT_MOVE;
+	ev.+source	:= object;
+	ev.+direction	:= to_from;
+	ev.+speed	:= speed;
+	ev.+WakeUp	:= no_wake;
+	ev.+loop	:= loop;
+	ev.+process	:= GetProcess(GetPid());
+
+	return SendEvent(mobile, ev);
+endfunction
+
+/*
+ * AI_MoveXY(mobile, x, y, to_from, speed, no_wake, loop)
+ *
+ * Purpose
+ * Commands an npc to move toward or away from an XY coordinate.
+ *
+ * Parameters
+ * mobile:	The npc that will receive the command.
+ * x:		X coordinate to move away from/toward
+ * y:		Y coordinate to move away from/toward
+ * to_from:	Direction the npc will go:
+ *		NEMOVE_TOWARD - Will make the npc move toward the object - Default
+ *		NEMOVE_AWAY   - Will make the npc move away from the object.
+ * speed:	Speed the npc will move at:
+ *		NEMOVE_RUN  - NPC will run
+ *		NEMOVE_WALK - NPC will walk
+ * no_wake:	Optional wakeup flag::
+ *		WAKEUP - Will stop the sleep script if it is running - Default.
+ *		NOWAKE - Will not stop the sleep script if it is running.
+ * loop:	Number of steps for the npc to take toward/away from the object.
+ *		Note: Loop can be interrupted and end prematurely!
+ *
+ * Return value
+ * Result of SendEvent()
+ *
+ */
+function AI_MoveXY(mobile, x, y, to_from:=NEMOVE_TOWARD, speed:=NEMOVE_RUN, no_wake:=WAKEUP, loop:=0)
+	var ev		:= struct;
+	ev.+type	:= NPCEVENT_MOVE_XY;
+	ev.+x		:= x;
+	ev.+y		:= y;
+	ev.+direction	:= to_from;
+	ev.+speed	:= speed;
+	ev.+WakeUp	:= no_wake;
+	ev.+loop	:= loop;
+	ev.+process	:= GetProcess(GetPid());
+
+	return SendEvent(mobile, ev);
+endfunction
+
+/*
+ * AI_SetOpponent(mobile, opponent, no_wake)
+ *
+ * Purpose
+ * Places the npc into war mode and sets an opponent.
+ *
+ * Parameters
+ * mobile:	The npc that will receive the command.
+ * opponent:	Mobile reference that will be considered an opponent.
+ * no_wake:	Optional wakeup flag:
+ *		WAKEUP - Will stop the sleep script if it is running - Default.
+ *		NOWAKE - Will not stop the sleep script if it is running.
+ *
+ * Return value
+ * Result of SendEvent()
+ *
+ */
+function AI_SetOpponent(mobile, opponent, no_wake:=WAKEUP)
+	var ev		:= struct;
+	ev.+type	:= NPCEVENT_OPPONENT;
+	ev.+source	:= opponent;
+	ev.+WakeUp	:= no_wake;
+	ev.+process	:= GetProcess(GetPid());
+
+	return SendEvent(mobile, ev);
+endfunction
+
+/*
+ * AI_Sleep(mobile)
+ *
+ * Purpose
+ * Instructs the npc to go into sleep mode - shuts down all nerves.
+ *
+ * Parameters
+ * mobile:	The npc that will receive the command.
+ *
+ * Return value
+ * Result of SendEvent()
+ *
+ */
+function AI_Sleep(mobile)
+	var ev		:= struct;
+	ev.+type	:= NPCEVENT_SLEEP;
+	ev.+WakeUp	:= NOWAKE;
+	ev.+process	:= GetProcess(GetPid());
+
+	return SendEvent(mobile, ev);
+endfunction
+
+/*
+ * AI_Speak(mobile, text, text_type, do_event, no_wake)
+ *
+ * Purpose
+ * Commands the NPC to speak.
+ *
+ * Parameters
+ * mobile:	The npc that will receive the command.
+ * text:	The text the npc will speak.
+ * text_type:	text_type for npc.em :
+ *		SPEAK_TEXTTYPE_DEFAULT - Default
+ *		SPEAK_TEXTTYPE_WHISPER
+ *		SPEAK_TEXTTYPE_YELL
+ * do_event:	Flags for sending a system event for speech to surrounding npcs.
+ *		SPEAK_DOEVENT_DISABLE - Default
+ *		SPEAK_DOEVENT_ENABLE
+ * no_wake:	Optional wakeup flag:
+ *		WAKEUP - Will stop the sleep script if it is running - Default.
+ *		NOWAKE - Will not stop the sleep script if it is running.
+ *
+ * Return value
+ * Result of SendEvent()
+ *
+ */
+function AI_Speak(mobile, text, text_type:=SPEAK_TEXTTYPE_DEFAULT, do_event:=SPEAK_DOEVENT_DISABLE, no_wake:=WAKEUP)
+	var ev		:= struct;
+	ev.+type	:= NPCEVENT_SPEAK;
+	ev.+text	:= text;
+	ev.+texttype	:= text_type;
+	ev.+doevent	:= do_event;
+	ev.+WakeUp	:= no_wake;
+	ev.+process	:= GetProcess(GetPid());
+
+	return SendEvent(mobile, ev);
+endfunction
+
+/*
+ * AI_StartNerve(mobile, nerve_name, script_name, data, no_wake)
+ *
+ * Purpose
+ * Used to start a custom nerve up from within a nerve.
+ *
+ * Parameters
+ * mobile:	The npc that will receive the command.
+ * nerve_name:	String containing the name of the nerve (dictionary key).
+ * script_name:	Path of the script to start.
+ * data:	Data to be sent to the nerve once it starts.
+ * no_wake:	Optional wakeup flag:
+ *		WAKEUP - Will stop the sleep script if it is running - Default.
+ *		NOWAKE - Will not stop the sleep script if it is running.
+ *
+ * Return value
+ * Result of SendEvent()
+ *
+ */
+function AI_StartNerve(mobile, nerve_name, script_name, data, no_wake:=WAKEUP)
+	var ev		:= struct;
+	ev.+type	:= NPCEVENT_STARTNERVE;
+	ev.+name	:= nerve_name;
+	ev.+script	:= script_name;
+	ev.+data	:= data;
+	ev.+WakeUp	:= no_wake;
+	ev.+process	:= GetProcess(GetPid());
+
+	return SendEvent(mobile, ev);
+endfunction
+
+/*
+ * AI_Turn(mobile, turn_to, direction, no_wake)
+ *
+ * Purpose
+ * Commands the NPC to face away from / toward an object.
+ *
+ * Parameters
+ * mobile:	The npc that will receive the command.
+ * turn_to:	item or moble reference to turn away from / toward.
+ * direction:	Direction the npc will face:
+ *		NETURN_TOWARD - Will make the npc turn toward the object - Default.
+ 		NETURN_AWAY   - Will make the npc turn away from the object.
+ * no_wake:	Optional wakeup flag:
+ *		WAKEUP - Will stop the sleep script if it is running - Default.
+ *		NOWAKE - Will not stop the sleep script if it is running.
+ *
+ * Return value
+ * Result of SendEvent()
+ *
+ */
+function AI_Turn(mobile, turn_to, direction:=NETURN_TOWARD, no_wake:=WAKEUP)
+	var ev		:= struct;
+	ev.+type	:= NPCEVENT_TURN;
+	ev.+source	:= turn_to;
+	ev.+direction	:= direction;
+	ev.+WakeUp	:= no_wake;
+	ev.+process	:= GetProcess(GetPid());
+
+	return SendEvent(mobile, ev);
+endfunction
+
+/*
+ * AI_TurnXY(mobile, x, y, direction, no_wake)
+ *
+ * Purpose
+ * Commands the NPC to face away from / toward a coordinate.
+ *
+ * Parameters
+ * mobile:	The npc that will receive the command.
+ * x:		X coordinate to turn away from / toward.
+ * y:		Y coordinate to turn away from / toward.
+ * direction:	Direction the npc will face:
+ *		NETURN_TOWARD - Will make the npc turn toward the object - Default.
+ 		NETURN_AWAY   - Will make the npc turn away from the object.
+ * no_wake:	Optional wakeup flag:
+ *		WAKEUP - Will stop the sleep script if it is running - Default.
+ *		NOWAKE - Will not stop the sleep script if it is running.
+ *
+ * Return value
+ * Result of SendEvent()
+ *
+ */
+function AI_TurnXY(mobile, x, y, direction:=NETURN_TOWARD, no_wake:=WAKEUP)
+	var ev		:= struct;
+	ev.+type	:= NPCEVENT_TURN_XY;
+	ev.+x		:= x;
+	ev.+y		:= y;
+	ev.+direction	:= direction;
+	ev.+WakeUp	:= no_wake;
+	ev.+process	:= GetProcess(GetPid());
+
+	return SendEvent(mobile, ev);
+endfunction
+
+/*
+ * AI_WakeUp(mobile)
+ *
+ * Purpose
+ * Sends an event to the npc causing its sleep script to end.
+ *
+ * Parameters
+ * mobile:	The npc that will receive the command.
+ *
+ * Return value
+ * Result of SendEvent()
+ *
+ */
+function AI_WakeUp(mobile)
+	var ev		:= struct;
+	ev.+type	:= NPCEVENT_WAKEUP;
+	ev.+WakeUp	:= WAKEUP;
+	ev.+process	:= GetProcess(GetPid());
+
+	return SendEvent(mobile, ev);
+endfunction
+
+/*
+ * AI_Wander(mobile, opponent, no_wake)
+ *
+ * Purpose
+ * Commands the NPC to wander one step in a random direction.
+ *
+ * Parameters
+ * mobile:	The npc that will receive the command.
+ * no_wake:	Optional wakeup flag:
+ *		WAKEUP - Will stop the sleep script if it is running - Default.
+ *		NOWAKE - Will not stop the sleep script if it is running.
+ * loop:	Number of times to attempt to wander.
+ *		Note: Loop can be interrupted and end prematurely!
+ *
+ * Return value
+ * Result of SendEvent()
+ *
+ */
+function AI_Wander(mobile, no_wake:=WAKEUP, loop:=0)
+	var ev		:= struct;
+	ev.+type	:= NPCEVENT_WANDER;
+	ev.+WakeUp	:= no_wake;
+	ev.+loop	:= CInt(loop);
+	ev.+process	:= GetProcess(GetPid());
+
+	return SendEvent(mobile, ev);
+endfunction
+
+/*
+ * AI_WarMode(mobile, mode, no_wake)
+ *
+ * Purpose
+ * Toggles warmode on the npc. Setting to 0 also clears the opponent.
+ *
+ * Parameters
+ * mobile:	The npc that will receive the command.
+ * mode:	0 - Takes the NPC out of warmode and clears the opponent - Default.
+ *		1 - Places the npc into warmode.
+ * no_wake:	Optional wakeup flag:
+ *		WAKEUP - Will stop the sleep script if it is running - Default.
+ *		NOWAKE - Will not stop the sleep script if it is running.
+ *
+ * Return value
+ * Result of SendEvent()
+ *
+ */
+function AI_WarMode(mobile, mode:=0, no_wake:=WAKEUP)
+	var ev		:= struct;
+	ev.+type	:= NPCEVENT_WARMODE;
+	ev.+value	:= mode;
+	ev.+WakeUp	:= no_wake;
+	ev.+process	:= GetProcess(GetPid());
+
+	return SendEvent(mobile, ev);
+endfunction

Added: trunk/096/pkg/mobiles/ai_brain/include/npcError.inc
===================================================================
--- trunk/096/pkg/mobiles/ai_brain/include/npcError.inc	2005-09-04 16:28:05 UTC (rev 55)
+++ trunk/096/pkg/mobiles/ai_brain/include/npcError.inc	2005-09-04 16:30:56 UTC (rev 56)
@@ -0,0 +1,36 @@
+/*===============================================================
+* Current Version
+* NPC_ERRORS.INC - v1.0
+* Updated 8/31/2005 5:08AM
+*
+* -- Revision v1.0 --
+* Austin:
+*  Created include file
+===============================================================*/
+
+use uo;
+use os;
+
+/*
+ * NPC_ErrorSysLog(errmsg)
+ *
+ * Purpose
+ * Logs an error message.
+ *
+ * Parameters
+ * errmsg:	Error message
+ *
+ * Return value
+ * Always returns 1
+ *
+ */
+function NPC_ErrorSysLog(mobile, errmsg)
+	Set_Critical(1);
+	SysLog(&quot;NPC Template: &quot; + mobile.npctemplate);
+	SysLog(&quot;NPC Name    : &quot; + mobile.name);
+	SysLog(errmsg );
+	SysLog(&quot;------------&quot;);
+	Set_Critical(0);
+	
+	return 1;
+endfunction
\ No newline at end of file

Added: trunk/096/pkg/mobiles/ai_brain/include/npcNerves.inc
===================================================================
--- trunk/096/pkg/mobiles/ai_brain/include/npcNerves.inc	2005-09-04 16:28:05 UTC (rev 55)
+++ trunk/096/pkg/mobiles/ai_brain/include/npcNerves.inc	2005-09-04 16:30:56 UTC (rev 56)
@@ -0,0 +1,213 @@
+/*===============================================================
+* Current Version
+* NERVES.INC - v1.0
+* Updated 9/1/2005 6:15PM
+*
+* -- Revision v1.0 --
+* Austin:
+*  Created include file
+===============================================================*/
+
+use uo;
+use os;
+
+include &quot;:ai_brain:include/npcError&quot;;
+
+/////////////////////////////////////////////////////////////////
+// * Function List *
+//
+// GetNerveFlags(mobile, nerve_name, byref nerve_dict:=0)
+// GetNerveProcess(mobile, nerve_name, byref nerve_dict:=0)
+// LoadNerves(mobile)
+// SaveNerves(mobile, nerve_dict)
+// StartNerve(mobile, nerve_name, nerve_script, data:=array, flags:=NF_NO_FLAGS, byref nerve_dict:=0)
+// StopNerve(mobile, nerve_name, byref nerve_dict:=0)
+//
+/////////////////////////////////////////////////////////////////
+// * Global Varibles *
+//
+// Nerve flags
+const NF_NO_FLAGS		:= 0x0;
+const NF_CONTINUE_ON_SLEEP	:= 0x1;
+//
+/////////////////////////////////////////////////////////////////
+
+/*
+ * LoadNerves()
+ *
+ * Purpose
+ * Loads nerve information for an npc.
+ *
+ * Parameters
+ * mobile:	NPC to get the nerve settings from.
+ *
+ * Return value
+ * Returns a dictionary
+ *
+ */
+function LoadNerves(mobile)
+	var nerve_dict := GetObjProperty(mobile, &quot;#NerveInfo&quot;);
+	if ( Lower(TypeOf(nerve_dict)) != &quot;dictionary&quot; )
+		nerve_dict := dictionary;
+	endif
+
+	return nerve_dict;
+endfunction
+
+/*
+ * SaveNerves(mobile, nerve_dict)
+ *
+ * Purpose
+ * Saves nerve information for an npc.
+ *
+ * Parameters
+ * mobile:	NPC to save the nerve settings on.
+ * nerve_dict:	Dictionary containing nerve information.
+ *
+ * Return value
+ * Returns 1 on success
+ *
+ */
+function SaveNerves(mobile, byref nerve_dict)
+	return SetObjProperty(mobile, &quot;#NerveInfo&quot;, nerve_dict);
+endfunction
+
+/*
+ * GetNerveProcess(mobile, nerve_name, byref nerve_dict)
+ *
+ * Purpose
+ * Retrieves a reference to a running nerve script.
+ *
+ * Parameters
+ * mobile:	NPC to get the nerve information from.
+ * nerve_name:	Name of the nerve to get the information for.
+ * nerve_dict:	Optional parameter. Use if the settings were already loaded for faster access.
+ *
+ * Return value
+ * Returns a script reference.
+ *
+ */
+function GetNerveProcess(mobile, nerve_name, byref nerve_dict:=0)
+	if ( !nerve_dict )
+		nerve_dict := LoadNerves(mobile);
+	endif
+
+	if ( nerve_dict.exists(nerve_name) )
+		return GetProcess(CInt(nerve_dict[nerve_name].pid));
+	else
+		return error{&quot;errortext&quot; := &quot;GetNerveProcess() - Invalid nerve name  [&quot;+nerve_name+&quot;]&quot;};
+	endif
+endfunction
+
+/*
+ * GetNerveFlags(mobile, nerve_name, byref nerve_dict)
+ *
+ * Purpose
+ * Retrieves the flag setting set on a nerve.
+ *
+ * Parameters
+ * mobile:	NPC to get the nerve information from.
+ * nerve_name:	Name of the nerve to get the information for.
+ * nerve_dict:	Optional parameter. Use if the settings were already loaded for faster access.
+ *
+ * Return value
+ * Returns a script reference.
+ *
+ */
+function GetNerveFlags(mobile, nerve_name, byref nerve_dict:=0)
+	if ( !nerve_dict )
+		nerve_dict := LoadNerves(mobile);
+	endif
+
+	if ( nerve_dict.exists(nerve_name) )
+		return GetProcess(CInt(nerve_dict[nerve_name].flags));
+	else
+		return error{&quot;errortext&quot; := &quot;GetNerveProcess() - Invalid nerve name  [&quot;+nerve_name+&quot;]&quot;};
+	endif
+endfunction
+
+/*
+ * StartNerve(mobile, nerve_name, nerve_script, data, flags, byref nerve_dict)
+ *
+ * Purpose
+ * Starts up a nerve script.
+ *
+ * Parameters
+ * mobile:	NPC the nerve will be running for.
+ * nerve_name:	The name the nerve script will be run under. (Example: &quot;CombatScript&quot; or &quot;EnterReact&quot;)
+ * data:	Array of data to send to the nerve script when it starts.
+ * flags:	Can contain anything - but should use NF_* flags for bitwise checks.
+ * nerve_dict:	Optional parameter. Use if the settings were already loaded for faster access.
+ *
+ * Notes:
+ * data[1] - Will contain the mobile argument.
+ * data[2] - Will contain the nerve name argument.
+ * If data is not an array, it will be placed at index[3].
+ * If data is sent as an array, it will begin at the index of [3].
+ *
+ * Return value
+ * Returns a script reference to the nerve script.
+ *
+ */
+function StartNerve(mobile, nerve_name, nerve_script, data:=array, flags:=NF_NO_FLAGS, byref nerve_dict:=0)
+	if ( Lower(TypeOf(data)) != &quot;array&quot;)
+		data := array{data};
+	endif
+	//Mobile is always the begining of the data array.
+	data.Insert(1, mobile);
+	//Nerve name is always the second part of the data array.
+	data.Insert(2, nerve_name);
+
+	var process := start_script(nerve_script, data);
+
+	if ( process.errortext )
+		var errmsg := &quot;StartNerve() [&quot;+nerve_name+&quot;] [&quot;+nerve_script+&quot;] failed to start! -&gt;&quot;+process.errortext;
+		NPC_ErrorSysLog(mobile, errmsg);
+		return error{&quot;errortext&quot;:=errmsg};
+	else
+		//Before setting the new nerve, check if one is already running.
+		if ( nerve_dict.exists(nerve_name) )
+			//Stop the old nerve, before storing the new one.
+			StopNerve(mobile, nerve_name, nerve_dict);
+		endif
+		var nerve_info := struct;
+		nerve_info.+pid := process.pid;
+		nerve_info.+flags := flags;
+		nerve_dict[nerve_name] := nerve_info;
+
+		SaveNerves(mobile, nerve_dict);
+
+		return process;
+	endif
+endfunction
+
+/*
+ * StopNerve(mobile, nerve_name, byref nerve_dict)
+ *
+ * Purpose
+ * Starts up a nerve script.
+ *
+ * Parameters
+ * mobile:	NPC the nerve will be stopped on.
+ * nerve_name:	The name of the nerve script to stop.
+ * nerve_dict:	Optional parameter. Use if the settings were already loaded for faster access.
+ *
+ * Return value
+ * Returns 1 on success.
+ *
+ */
+function StopNerve(mobile, nerve_name, byref nerve_dict:=0)
+	if ( !nerve_dict )
+		nerve_dict := LoadNerves(mobile);
+	endif
+
+	if ( nerve_dict.Exists(nerve_name) )
+		GetNerveProcess(mobile, nerve_name, nerve_dict).kill();
+		nerve_dict.Erase(nerve_name);
+
+		return SaveNerves(mobile, nerve_dict);
+	else
+		return error{&quot;errortext&quot; := &quot;StopNerve() - Invalid nerve name  [&quot;+nerve_name+&quot;]&quot;};
+	endif
+endfunction
+

Added: trunk/096/pkg/mobiles/ai_brain/include/npcSettings.inc
===================================================================
--- trunk/096/pkg/mobiles/ai_brain/include/npcSettings.inc	2005-09-04 16:28:05 UTC (rev 55)
+++ trunk/096/pkg/mobiles/ai_brain/include/npcSettings.inc	2005-09-04 16:30:56 UTC (rev 56)
@@ -0,0 +1,165 @@
+/*===============================================================
+* Current Version
+* NPC_SETTINGS.INC - v1.0
+* Updated 8/30/2005 7:28AM
+*
+* -- Revision v1.0 --
+* Austin:
+*  Created include file
+===============================================================*/
+
+use uo;
+use os;
+use cfgfile;
+
+include &quot;:ai_brain:include/npcUtil&quot;;
+
+/*
+ * NPC_DefaultSettings(settings:=0)
+ *
+ * Purpose
+ * Checks the settings dictionary to make sure required values are set.
+ * If a dictionary is passed, it will check it for required parameters.
+ * If they are not present, they will be set.
+ * Nothing will be overwritten in this function.
+ *
+ * Parameters
+ * settings:	Optional parameter
+ *		Dictionary read in from NPC_GetDefaultSettings()
+ *
+ * Return value
+ * Returns a dictionary
+ *
+ */
+function NPC_GetDefaultSettings(settings:=0)
+	if ( Lower(TypeOf(settings)) != &quot;dictionary&quot; )
+		settings := dictionary;
+	endif
+
+	if ( CInt(settings.exists(&quot;cycle_wait&quot;)) &lt;= 0 )
+		settings[&quot;cycle_wait&quot;] := 10;
+	endif
+	if ( CInt(settings.exists(&quot;sleep_time&quot;)) &lt;= 0 )
+		settings[&quot;sleep_time&quot;] := 1024;
+	endif
+	if ( CInt(settings.exists(&quot;idle_ticks&quot;)) &lt;= 0 )
+		settings[&quot;idle_ticks&quot;] := 5;
+	endif
+
+	return settings;
+endfunction
+
+/*
+ * NPC_LoadTemplateSettings(source)
+ *
+ * Purpose
+ * Loads settings for a template from npcdesc.cfg
+ *
+ * Parameters
+ * source:	Name of the npc template to load settings for.
+ *		Can also be an npc reference - if custom settings should be loaded off it.
+ *
+ * Return value
+ * Returns a dictionary
+ *
+ */
+function NPC_LoadTemplateSettings(source)
+	var template:=source;
+	if ( source.IsA(POLCLASS_NPC) )
+		template := NPC_ParseTemplateName(source.npctemplate);
+	elseif ( !template.package )
+		template := NPC_ParseTemplateName(template);
+	endif
+
+	//
+	// * Load config defaults first
+	//
+	var npc_cfg := ReadConfigFile(template.package+&quot;npcdesc&quot;);
+	var npc_elem := npc_cfg[template.template];
+
+	var setting_list := GetConfigStringDictionary(npc_elem, &quot;AISetting&quot;);
+	
+	var settings := dictionary;
+	foreach setting_name in (setting_list.keys())
+		settings[setting_name] := UnPack(setting_list[setting_name]);
+		sleepms(2);
+	endforeach
+
+	//
+	// * If the source is an npc, check it for custom settings.
+	//
+	if ( source.IsA(POLCLASS_NPC) )
+		var cstm_settings := GetObjProperty(source, &quot;AISettings&quot;);
+		foreach key in (cstm_settings.keys())
+			if ( cstm_settings[key] == error )
+				settings.Erase(key);
+			else
+				settings[key] := cstm_settings[key];
+			endif
+				
+			sleepms(2);
+		endforeach
+	endif
+	
+	return settings;
+endfunction
+
+/*
+ * NPC_LoadScriptSettings(source)
+ *
+ * Purpose
+ * Loads brain AI script settings for an NPC. Gives .script and .flag values for them.
+ *
+ * Parameters
+ * source:	Name of the npc template to load settings for.
+ *		Can also be an npc reference - if custom settings should be loaded off it.
+ *
+ * Return value
+ * Returns a dictionary
+ *
+ */
+function NPC_LoadScriptSettings(source)
+	var template:=source;
+	if ( source.IsA(POLCLASS_NPC) )
+		template := NPC_ParseTemplateName(source.npctemplate);
+	elseif ( !template.package )
+		template := NPC_ParseTemplateName(template);
+	endif
+
+	//
+	// * Load config defaults first
+	//
+	var npc_cfg := ReadConfigFile(template.package+&quot;npcdesc&quot;);
+	var npc_elem := npc_cfg[template.template];
+
+	var script_list := GetConfigStringDictionary(npc_elem, &quot;AIScript&quot;);
+	var flag_list := GetConfigStringDictionary(npc_elem, &quot;AIScriptFlag&quot;);
+
+	var script_settings := dictionary;
+	foreach script_type in (script_list.keys())
+		var temp := struct;
+		temp.+script := script_list[script_type];
+		temp.+flags := 0x0;
+		if ( flag_list[script_type] )
+			temp.flags := UnPack(flag_list[script_type]);
+		endif
+
+		script_settings[script_type] := temp;
+		sleepms(2);
+	endforeach
+
+	//
+	// * If the source is an npc, check it for custom script settings.
+	//   Assumes each key in the dictionary property has a .script and .flags pair already.
+	//
+	if ( source.IsA(POLCLASS_NPC) )
+		var cstm_scripts := GetObjProperty(source, &quot;AIScripts&quot;);
+		foreach key in (cstm_scripts.keys())
+			script_settings[key] := cstm_scripts[key];
+			sleepms(2);
+		endforeach
+	endif
+	
+	return script_settings;
+endfunction
+

Added: trunk/096/pkg/mobiles/ai_brain/include/npcUtil.inc
===================================================================
--- trunk/096/pkg/mobiles/ai_brain/include/npcUtil.inc	2005-09-04 16:28:05 UTC (rev 55)
+++ trunk/096/pkg/mobiles/ai_brain/include/npcUtil.inc	2005-09-04 16:30:56 UTC (rev 56)
@@ -0,0 +1,45 @@
+/*===============================================================
+* Current Version
+* NPC_UTIL.INC - v1.0
+* Updated 8/31/2005 4:23AM
+*
+* -- Revision v1.0 --
+* Austin:
+*  Created include file
+===============================================================*/
+
+/*
+ * NPC_ParseTemplateName(template_name)
+ *
+ * Purpose
+ * Finds the appropriate npcdesc.cfg to load.
+ * This enables npcs to be placed in packages and not just the ::npcdesc file.
+ * ReadConfigFile(&quot;:*:npcdesc&quot;) does not work in this case because packaged npcs
+ * have the package name at the begining of their .npctemplate member. Reading the
+ * specific config file - helps to avoid possible elem name collisions.
+ *
+ * Parameters
+ * template_name:	Name of the npc template to parse
+ *
+ * Return value
+ * Returns struct .package .template
+ *
+ */
+function NPC_ParseTemplateName(template_name)
+	//Find positions of &quot;:&quot; characters
+	var colon_a := Find(template_name, &quot;:&quot;, 1);
+	var colon_b := Find(template_name, &quot;:&quot;, 2);
+
+	var parsed := struct{&quot;package&quot;, &quot;template&quot;};
+
+	if ( !colon_a || !colon_b )
+		//Not a complete package name - use default npcdesc.cfg
+		parsed.package := &quot;::&quot;;
+		parsed.template := template_name;
+	else
+		parsed.package := template_name[colon_a, colon_b];
+		parsed.template := template_name[colon_b+1, Len(template_name)];
+	endif
+
+	return parsed;
+endfunction

Added: trunk/096/pkg/mobiles/ai_brain/pkg.cfg
===================================================================
--- trunk/096/pkg/mobiles/ai_brain/pkg.cfg	2005-09-04 16:28:05 UTC (rev 55)
+++ trunk/096/pkg/mobiles/ai_brain/pkg.cfg	2005-09-04 16:30:56 UTC (rev 56)
@@ -0,0 +1,14 @@
+Enabled		1
+Name		ai_brain
+
+Version		5.0
+
+CoreRequired	96
+Requires	gumps 1.5
+
+Creator		Austin Heilman
+Email		<A HREF="https://lists.berlios.de/mailman/listinfo/poldistro-svn">Austin at tsse.net</A>
+Maintainer	Austin Heilman
+Email		<A HREF="https://lists.berlios.de/mailman/listinfo/poldistro-svn">Austin at tsse.net</A>
+
+#Conflicts none


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000035.html">[Poldistro-svn] r55 - trunk/096/pkg/mobiles
</A></li>
	<LI>Next message: <A HREF="000036.html">[Poldistro-svn] r57 - trunk/096/pkg/mobiles/ai_brain/include/braincore
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#40">[ date ]</a>
              <a href="thread.html#40">[ thread ]</a>
              <a href="subject.html#40">[ subject ]</a>
              <a href="author.html#40">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/poldistro-svn">More information about the Poldistro-svn
mailing list</a><br>
</body></html>
