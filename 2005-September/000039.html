<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Poldistro-svn] r54 - in trunk/096/pkg/mobiles: . ai_brain ai_brain/include ai_brain/include/braincore
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/poldistro-svn/2005-September/index.html" >
   <LINK REL="made" HREF="mailto:poldistro-svn%40lists.berlios.de?Subject=Re%3A%20%5BPoldistro-svn%5D%20r54%20-%20in%20trunk/096/pkg/mobiles%3A%20.%20ai_brain%20ai_brain/include%20ai_brain/include/braincore&In-Reply-To=%3C200509041617.j84GHf3M000043%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000034.html">
   <LINK REL="Next"  HREF="000035.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Poldistro-svn] r54 - in trunk/096/pkg/mobiles: . ai_brain ai_brain/include ai_brain/include/braincore</H1>
    <B>Austin Heilman at BerliOS</B> 
    <A HREF="mailto:poldistro-svn%40lists.berlios.de?Subject=Re%3A%20%5BPoldistro-svn%5D%20r54%20-%20in%20trunk/096/pkg/mobiles%3A%20.%20ai_brain%20ai_brain/include%20ai_brain/include/braincore&In-Reply-To=%3C200509041617.j84GHf3M000043%40sheep.berlios.de%3E"
       TITLE="[Poldistro-svn] r54 - in trunk/096/pkg/mobiles: . ai_brain ai_brain/include ai_brain/include/braincore">austin at berlios.de
       </A><BR>
    <I>Sun Sep  4 18:17:41 CEST 2005</I>
    <P><UL>
        <LI>Previous message: <A HREF="000034.html">[Poldistro-svn] r53 - trunk/096/pkg/mobiles
</A></li>
        <LI>Next message: <A HREF="000035.html">[Poldistro-svn] r55 - trunk/096/pkg/mobiles
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#39">[ date ]</a>
              <a href="thread.html#39">[ thread ]</a>
              <a href="subject.html#39">[ subject ]</a>
              <a href="author.html#39">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: austin
Date: 2005-09-04 18:17:40 +0200 (Sun, 04 Sep 2005)
New Revision: 54

Added:
   trunk/096/pkg/mobiles/ai_brain/
   trunk/096/pkg/mobiles/ai_brain/brain.src
   trunk/096/pkg/mobiles/ai_brain/include/
   trunk/096/pkg/mobiles/ai_brain/include/braincore/
   trunk/096/pkg/mobiles/ai_brain/include/braincore/error.inc
   trunk/096/pkg/mobiles/ai_brain/include/braincore/eventProcessor.inc
   trunk/096/pkg/mobiles/ai_brain/include/braincore/movement.inc
   trunk/096/pkg/mobiles/ai_brain/include/braincore/setup.inc
   trunk/096/pkg/mobiles/ai_brain/include/eventid.inc
   trunk/096/pkg/mobiles/ai_brain/include/npcCommands.inc
   trunk/096/pkg/mobiles/ai_brain/include/npcError.inc
   trunk/096/pkg/mobiles/ai_brain/include/npcNerves.inc
   trunk/096/pkg/mobiles/ai_brain/include/npcSettings.inc
   trunk/096/pkg/mobiles/ai_brain/include/npcUtil.inc
   trunk/096/pkg/mobiles/ai_brain/pkg.cfg
Log:


Added: trunk/096/pkg/mobiles/ai_brain/brain.src
===================================================================
--- trunk/096/pkg/mobiles/ai_brain/brain.src	2005-09-04 16:15:18 UTC (rev 53)
+++ trunk/096/pkg/mobiles/ai_brain/brain.src	2005-09-04 16:17:40 UTC (rev 54)
@@ -0,0 +1,53 @@
+/*===============================================================
+* Current Version
+* BRAIN.SRC - v5.0
+* Updated 9/1/2005 6:20AM
+*
+* NPC AI-Script to control all non-setup actions. Acts as the &quot;brain&quot;
+* and fires off external scripts that act as the &quot;nerves&quot; of the NPC.
+*
+* -- Revision v1.0 --
+* Austin:
+*  Created include file
+===============================================================*/
+
+use uo;
+use os;
+use npc;
+use cfgfile;
+use polsys;
+
+include &quot;include/sysEvent&quot;;
+include &quot;:ai_brain:include/braincore/error&quot;;
+include &quot;:ai_brain:include/braincore/eventProcessor&quot;;
+include &quot;:ai_brain:include/braincore/movement&quot;;
+include &quot;:ai_brain:include/braincore/setup&quot;;
+include &quot;:ai_brain:include/eventid&quot;;
+include &quot;:ai_brain:include/npcCommands&quot;;
+include &quot;:ai_brain:include/npcNerves&quot;;
+include &quot;:ai_brain:include/npcSettings&quot;;
+include &quot;:ai_brain:include/npcUtil&quot;;
+
+//
+// * Global variables
+//
+var npc := Self();
+var idle_ticks := 0;
+var sleep_mode := 0;
+var g_settings := dictionary; //&quot;setting name&quot;-&gt;value
+var g_scripts := dictionary; // &quot;script type&quot;-&gt;value{.flags, .script}
+var g_nerves := dictionary; // &quot;nerve name&quot;-&gt;value{.flags, .pid}
+
+program BrainAI()
+	//Run setup steps for the npc.
+	set_critical(1);
+	InitializeSettings();
+	InitializeEvents();
+	set_critical(1);
+	StartupScripts();
+	
+	while ( npc )
+		var ev := Wait_For_Event(g_settings[&quot;cycle_wait&quot;]);
+		ProcessEvent(ev);
+	endwhile
+endprogram

Added: trunk/096/pkg/mobiles/ai_brain/include/braincore/error.inc
===================================================================
--- trunk/096/pkg/mobiles/ai_brain/include/braincore/error.inc	2005-09-04 16:15:18 UTC (rev 53)
+++ trunk/096/pkg/mobiles/ai_brain/include/braincore/error.inc	2005-09-04 16:17:40 UTC (rev 54)
@@ -0,0 +1,41 @@
+/*===============================================================
+* Current Version
+* ERROR.INC - v1.0
+* Updated 8/31/2005 5:08AM
+*
+* -- Revision v1.0 --
+* Austin:
+*  Created include file
+===============================================================*/
+
+/*
+ * FatalError(errmsg)
+ *
+ * Purpose
+ * Logs an error message and then kills the npc.
+ *
+ * Parameters
+ * errmsg:	Error message - reason for removing the npc.
+ *
+ * Return value
+ * Always returns 1
+ *
+ */
+function FatalError(errmsg)
+	set_critical(1);
+	
+	PrintTextAbove(npc, errmsg, _DEFAULT_TEXT_FONT, 32);
+	
+	NPC_ErrorSysLog(npc, errmsg);
+	
+	npc.cmdlevel := 1;
+	npc.concealed := 1;
+	
+	npc.disable(&quot;invul&quot;);
+	SetObjProperty(npc, &quot;GuardKill&quot;, 1);
+	ApplyRawDamage(npc, GetVitalMaximumValue(npc, &quot;Hits&quot;));
+	
+	set_critical(0);
+	
+	return 1;
+endfunction

Added: trunk/096/pkg/mobiles/ai_brain/include/braincore/eventProcessor.inc
===================================================================
--- trunk/096/pkg/mobiles/ai_brain/include/braincore/eventProcessor.inc	2005-09-04 16:15:18 UTC (rev 53)
+++ trunk/096/pkg/mobiles/ai_brain/include/braincore/eventProcessor.inc	2005-09-04 16:17:40 UTC (rev 54)
@@ -0,0 +1,299 @@
+/*===============================================================
+* Current Version
+* EVENTPROCESSOR.INC - v1.0
+* Updated 9/1/2005 6:20AM
+*
+* -- Revision v1.0 --
+* Austin:
+*  Created include file
+===============================================================*/
+
+function ProcessEvent(byref event)
+	var old_priority := set_priority(25);
+	
+	case( event.type )
+		//
+		// *Check movement first, since its the event that seems to be sent most often.
+		//
+		
+		// Move NPC
+		// .source	: From/To whom/what?
+		// .speed	: Walk/Run
+		// .direction	: Away/Towards
+		// .loop	: Number of times to attempt to loop the movement.
+		NPCEVENT_MOVE:
+			Movement(event);
+			break;
+			
+		// Instructs the npc to walk toward an XY coordinate.
+		// .x and .y	: From/To  coordinates
+		// .speed	: Walk/Run
+		// .direction	: Away/Towards
+		// .loop	: Number of times to attempt to loop the movement.
+		NPCEVENT_MOVE_XY:
+			MovementXY(event);
+			break;
+			
+		// Wander somewhere
+		// .loop	: Number of times to attept to wander.
+		NPCEVENT_WANDER:
+	   		MovementWander(event);
+	   		break;
+		
+		//
+		// * Check System Events that the core sends.
+		//
+			
+		// Triggered when a mobile enter's the npcs 'area size'.
+		// .source	: What entered the area
+		SYSEVENT_ENTEREDAREA:
+			if ( g_scripts.Exists(&quot;EnterArea&quot;) )
+				var process := GetNerveProcess(npc, &quot;EnterArea&quot;, g_nerves);
+				if ( !process )
+					StartNerve(npc, &quot;EnterArea&quot;, g_scripts[&quot;EnterArea&quot;].script, {event, g_settings, g_scripts}, g_scripts[&quot;EnterArea&quot;].flags, g_nerves);
+				else
+					process.SendEvent(event);
+				endif
+			endif
+			break;
+			
+		// Triggered when a mobile leaves the npc's 'area size'.
+		// .source	: What left the area
+		SYSEVENT_LEFTAREA:
+			if ( g_scripts.Exists(&quot;LeftArea&quot;) )
+				var process := GetNerveProcess(npc, &quot;LeftArea&quot;, g_nerves);
+				if ( !process )
+					StartNerve(npc, &quot;LeftArea&quot;, g_scripts[&quot;LeftArea&quot;].script, {event, g_settings, g_scripts}, g_scripts[&quot;LeftArea&quot;].flags, g_nerves);
+				else
+					process.SendEvent(event);
+				endif
+			endif
+			break;
+			
+		// Someone has changed from blue to gray/red and was already within the ENTERED_AREA range
+		// .source	: What changed criminal status.
+		SYSEVENT_GONE_CRIMINAL:
+			if ( g_scripts.Exists(&quot;ItemGiven&quot;) )
+				var process := GetNerveProcess(npc, &quot;ItemGiven&quot;, g_nerves);
+				if ( !process )
+					StartNerve(npc, &quot;ItemGiven&quot;, g_scripts[&quot;ItemGiven&quot;].script, {event, g_settings, g_scripts}, g_scripts[&quot;ItemGiven&quot;].flags, g_nerves);
+				else
+					process.SendEvent(event);
+				endif
+			endif
+			break;
+			
+		// Sent when something targets the npc to begin combat or
+		// when something has damaged the npc.
+		// .source	: What caused the damage or engaged the npc
+		// For SYSEVENT_DAMAGED
+		// .damaged	: Integer amount of damage.
+		SYSEVENT_ENGAGED:
+		SYSEVENT_DAMAGED:
+			if ( g_scripts.Exists(&quot;Combat&quot;) )
+				if ( (event.source).ISA(POLCLASS_MOBILE) )
+					var process := GetNerveProcess(npc, &quot;Combat&quot;, g_nerves);
+					if ( !process )
+						StartNerve(npc, &quot;Combat&quot;, g_scripts[&quot;Combat&quot;].script, {event, g_settings, g_scripts}, g_scripts[&quot;Combat&quot;].flags, g_nerves);
+					else
+						process.SendEvent(event);
+					endif
+				endif
+			endif
+			break;
+			
+		// Instructs the npc to run its disengage nerve.
+		// When something attacking it goes out of warmode, this is run.
+		// .source	: What was targetting this npc but has now left combat mode.
+		SYSEVENT_DISENGAGED:
+			if ( g_scripts.Exists(&quot;Disengaged&quot;) )
+				var process := GetNerveProcess(npc, &quot;Disengaged&quot;, g_nerves);
+				if ( !process )
+					StartNerve(npc, &quot;Disengaged&quot;, g_scripts[&quot;Disengaged&quot;].script, {event, g_settings, g_scripts}, g_scripts[&quot;Disengaged&quot;].flags, g_nerves);
+				else
+					process.SendEvent(event);
+				endif
+			endif
+			break;
+			
+		// When speech is made by a player, this nerve is used.
+		// Note: The NPC function Say() doesnt yet pass around the speech event.
+		// .source	: Where the speech originated.
+		// .text	: The actual speech
+		// .uc_text	: a &quot;Unicode array&quot; of 2-byte &quot;Big Endian&quot; integers.
+		// .langcode	: a 3-character, uppercase language code.
+		// .texttype	: &quot;yell&quot;, &quot;whisper&quot;, &quot;emote&quot;, &quot;default&quot;.
+		SYSEVENT_SPEECH:
+		SYSEVENT_GHOST_SPEECH:
+			if( g_scripts.Exists(&quot;Listen&quot;) )
+				var process := GetNerveProcess(npc, &quot;Listen&quot;, g_nerves);
+				if ( !process )
+					StartNerve(npc, &quot;Listen&quot;, g_scripts[&quot;Listen&quot;].script, {event, g_settings, g_scripts}, g_scripts[&quot;Listen&quot;].flags, g_nerves);
+				else
+					process.SendEvent(event);
+				endif
+			endif
+			break;
+			
+		// Instructs the npc to run its double click script.
+		// Run when the npc is double clicked by a player.
+		// .source	: What sent the double click
+		SYSEVENT_DOUBLECLICKED:
+			if ( g_scripts.Exists(&quot;DblClick&quot;) )
+				if ( Distance(event.source, npc) &lt;= g_settings[&quot;dbl_click_range&quot;] )
+					var process := GetNerveProcess(npc, &quot;DblClick&quot;, g_nerves);
+					if ( !process )
+						StartNerve(npc, &quot;DblClick&quot;, g_scripts[&quot;DblClick&quot;].script, {event, g_settings, g_scripts}, g_scripts[&quot;DblClick&quot;].flags, g_nerves);
+					else
+						process.SendEvent(event);
+					endif
+				endif
+			endif
+			break;
+			
+		// The NPC is a merchant, and has sold or purchased something.
+		// Both sold and bought events are sent to this same nerve.
+		// The best thing to do is fork it into two functions inside the
+		// nerve script to handle each event type.
+		// MERCHANT_SOLD means the merchant sold an item to the player.
+		// MERCHANT_BOUGHT means the merchatn bought something from the player.
+		//
+		// .source	: Who the merchant is selling to/buying from.
+		// .amount	: Gold amount for the sale/purchase.
+		SYSEVENT_MERCHANT_SOLD:
+		SYSEVENT_MERCHANT_BOUGHT:
+			if ( g_scripts.Exists(&quot;Merchant&quot;) )
+				var process := GetNerveProcess(npc, &quot;Merchant&quot;, g_nerves);
+				if ( !process )
+					StartNerve(npc, &quot;Merchant&quot;, g_scripts[&quot;Merchant&quot;].script, {event, g_settings, g_scripts}, g_scripts[&quot;Merchant&quot;].flags, g_nerves);
+				else
+					process.SendEvent(event);
+				endif
+			endif
+			break;
+			
+		// Someone has dragged an item onto the npc.
+		// .source	: What dragged the item over the npc.
+		// .item	: The item being given to the npc.
+		SYSEVENT_ITEM_GIVEN:
+			if ( g_scripts.Exists(&quot;ItemGiven&quot;) )
+				var process := GetNerveProcess(npc, &quot;ItemGiven&quot;, g_nerves);
+				if ( !process )
+					StartNerve(npc, &quot;ItemGiven&quot;, g_scripts[&quot;ItemGiven&quot;].script, {event, g_settings, g_scripts}, g_scripts[&quot;ItemGiven&quot;].flags, g_nerves);
+				else
+					process.SendEvent(event);
+				endif
+			endif
+			break;
+			
+		//
+		// * Check custom events
+		//
+		//A nerve has instructed the brain to kill another nerve or its self.
+		// .name	: Nerve name
+		NPCEVENT_ENDNERVE:
+			StopNerve(npc, event.name, g_nerves);
+			break;
+			
+		//A nerve has instructed the brain to start another nerve.
+		// .name	: Nerve name
+		// .script	: Nerve script
+		// .data	: array of goodies
+		NPCEVENT_STARTNERVE:
+			StartNerve(npc, event.name, event.script, event.data, event.flags, g_nerves);
+			break;
+			
+		// Set a new opponent!
+		// NOTE: Auto-sets Warmode=1!
+		// .source	: Opponent (mobile)
+		NPCEVENT_OPPONENT:
+			SetOpponent(event.source);
+			break;
+			
+		// Say something
+		// .text	: Speech content
+		// .texttype	: Speech type (&quot;default&quot;, &quot;whisper&quot;, yell&quot;)
+		// .doevent	: Sends SYSEVENT_SPEECH to surrounding npcs
+		NPCEVENT_SPEAK:
+			Say(event.text, event.texttype, event.doevent);
+			break;
+			
+		// Turn toward something
+		// .source	: Target (anything)
+		// .direction	: NETURN_TOWARD or NETURN_AWAY
+		NPCEVENT_TURN:
+			case (event.direction)
+				NETURN_TOWARD:
+					TurnToward(event.source);
+				NETURN_AWAY:
+					TurnAwayFrom(event.source);
+			endcase
+			break;
+			
+		// Face towards or away from XY coordinates.
+		// .x and .y replace .source for TURN_XY
+		// .direction	: NETURN_TOWARD or NETURN_AWAY
+		NPCEVENT_TURN_XY:
+			case (event.direction)
+				NETURN_TOWARD:
+					TurnTowardLocation(event.x, event.y);
+				NETURN_AWAY:
+					TurnAwayFromLocation(event.x, event.y);
+			endcase
+			break;
+			
+		// Set WarMode state
+		// NOTE: Auto-clears Opponent if turned off!
+		// .value : 0=Off. 1=On.
+		NPCEVENT_WARMODE:
+			SetWarmode( event.value );
+			break;
+	   		
+	   	// Force the npc to go into its sleep mode.
+	   	// If the next event in the queue tells it to wake up,
+	   	// this command will be useless.
+	   	NPCEVENT_SLEEP:
+	   		//idle_ticks := g_settings[&quot;idle_ticks&quot;]+1;
+	   		break;
+	   		
+	   	// Force the npc out of sleep mode.
+	   	NPCEVENT_WAKEUP:
+	   		//sleep_mode := 0;
+	   		//idle_ticks := 0;
+	   		break;
+	   		
+	   	// Forward an event from one nerve to another.
+	   	// .NerveName	: The name of the nerve to forward the event to.
+	   	// .mask	: Type of event for the nerve to receive.
+	   	// .data	: Data to forward to the nerve.
+	   	NPCEVENT_FWDNERVE:
+	   	var process := GetNerveProcess(npc, event.NerveName, g_nerves);
+			if ( process )
+				process.SendEvent(event);
+			endif
+			break;
+			
+		// If the event .type is unknown, send it to the
+		// npc's &quot;virtual&quot; nerve if it has one.
+	   	default:
+	   		if ( g_scripts.Exists(&quot;Virtual&quot;) )
+	   			var process := GetNerveProcess(npc, &quot;Virtual&quot;, g_nerves);
+				if ( !process )
+					StartNerve(npc, &quot;Virtual&quot;, g_scripts[&quot;Virtual&quot;].script, {event, g_settings, g_scripts}, g_scripts[&quot;Virtual&quot;].flags, g_nerves);
+				else
+					process.SendEvent(event);
+				endif
+			endif
+			break;
+	   endcase
+
+	   // If the event has a .process member, reply to it by sending
+	   // an event with .type being the NPCEVENT_DONE constant
+	   // and telling it what event it sent that has finished
+	   // being processed.
+	   if ( event.process )
+	   	(event.process).SendEvent(struct{&quot;type&quot;:=NPCEVENT_DONE, &quot;source&quot;:=event.type});
+	   endif
+	   
+	   set_priority(old_priority);
+endfunction

Added: trunk/096/pkg/mobiles/ai_brain/include/braincore/movement.inc
===================================================================
--- trunk/096/pkg/mobiles/ai_brain/include/braincore/movement.inc	2005-09-04 16:15:18 UTC (rev 53)
+++ trunk/096/pkg/mobiles/ai_brain/include/braincore/movement.inc	2005-09-04 16:17:40 UTC (rev 54)
@@ -0,0 +1,168 @@
+/*===============================================================
+* Current Version
+* MOVEMENT.INC - v1.0
+* Updated 9/1/2005 6:42AM
+*
+* -- Revision v1.0 --
+* Austin:
+*  Created include file
+===============================================================*/
+
+/*
+ * Movement(ev)
+ *
+ * Purpose
+ * Handles NPC movenpcnt to/from an object for the brain.
+ *
+ * Parameters
+ * ev:	Strucuture containing event information.
+ *
+ * Return value
+ * Always returns 1
+ *
+ */
+function Movement(ev)
+	var old_pri := set_priority(50);
+	
+	case ( ev.speed )
+		NEMOVE_WALK:
+			case ( ev.direction )
+				NEMOVE_AWAY:
+					repeat
+						WalkAwayFrom(ev.source);
+						sleepms(3);
+					until ( !MoveLoopCheck(ev) );
+				NEMOVE_TOWARD:
+					repeat
+						WalkToward(ev.source);
+						sleepms(3);
+					until ( !MoveLoopCheck(ev) );
+			endcase	
+		NEMOVE_RUN:
+			case( ev.direction )
+				NEMOVE_AWAY:
+					repeat
+						RunAWayFrom(ev.source);
+						sleepms(3);
+					until ( !MoveLoopCheck(ev) );	
+				NEMOVE_TOWARD:
+					repeat
+						RunToward(ev.source);
+						sleepms(3);
+					until ( !MoveLoopCheck(ev) );
+			endcase
+	endcase
+	
+	set_priority(old_pri);
+	
+	return 1;
+endfunction
+
+/*
+ * MovementXY(ev)
+ *
+ * Purpose
+ * Handles NPC movement to/from a coordinate for the brain.
+ *
+ * Parameters
+ * ev:	Strucuture containing event information.
+ *
+ * Return value
+ * Always returns 1
+ *
+ */
+function MovementXY(ev)
+	var old_pri := set_priority(50);
+	
+	case ( ev.speed )
+		NEMOVE_WALK:
+			case ( ev.direction )
+				NEMOVE_AWAY:
+					repeat
+						WalkAwayFromLocation(ev.x, ev.y);
+						sleepms(3);
+					until ( !MoveLoopCheck(ev) );
+				NEMOVE_TOWARD:
+					repeat
+						WalkTowardLocation(ev.x, ev.y);
+						sleepms(3);
+					until ( !MoveLoopCheck(ev) );
+			endcase	
+		NEMOVE_RUN:
+			case( ev.direction )
+				NEMOVE_AWAY:
+					repeat
+						RunAwayFromLocation(ev.x, ev.y);
+						sleepms(3);
+					until ( !MoveLoopCheck(ev) );	
+				NEMOVE_TOWARD:
+					repeat
+						RunTowardLocation(ev.x, ev.y);
+						sleepms(3);
+					until ( !MoveLoopCheck(ev) );
+			endcase
+	endcase
+	
+	set_priority(old_pri);
+	
+	return 1;
+endfunction
+
+/*
+ * MovementWander(ev)
+ *
+ * Purpose
+ * Handles NPC wander movement for the brain.
+ *
+ * Parameters
+ * ev:	Strucuture containing event information.
+ *
+ * Return value
+ * Always returns 1
+ *
+ */
+function MovementWander(ev)
+	repeat
+		Wander();
+		sleepms(3);
+	until ( !MoveLoopCheck(ev) );
+endfunction
+
+/*
+ * MoveLoop(ev)
+ *
+ * Purpose
+ * Determines if the npc should continue trying to move
+ * or if something else needs the brain's attention.
+ *
+ * Parameters
+ * ev:	Strucuture containing event information.
+ *
+ * Return value
+ * Returns 1 if the npc may continue moving.
+ *
+ */
+function MoveLoopCheck(byref ev)
+	if ( Events_Waiting() )
+		return 0;
+	elseif ( ev.loop &lt; 1 )
+		return 0;
+	elseif ( npc.frozen )
+		return 0;
+	elseif ( npc.paralyzed )
+		return 0;
+	endif
+	if ( ev.source )
+		// Dont need to worry about distance in an XY movement check. 
+		// It wont run in circles around XY coordinates like it does an object.
+		if ( ev.direction == NEMOVE_TOWARD )
+			if ( Distance(npc, ev.source) &lt;= 1 )
+				return 0;
+			endif
+		endif
+	endif
+	
+	ev.loop := ev.loop-1;
+	
+	return 1;
+endfunction

Added: trunk/096/pkg/mobiles/ai_brain/include/braincore/setup.inc
===================================================================
--- trunk/096/pkg/mobiles/ai_brain/include/braincore/setup.inc	2005-09-04 16:15:18 UTC (rev 53)
+++ trunk/096/pkg/mobiles/ai_brain/include/braincore/setup.inc	2005-09-04 16:17:40 UTC (rev 54)
@@ -0,0 +1,133 @@
+/*===============================================================
+* Current Version
+* SETUP.INC - v1.0
+* Updated 8/31/2005 4:54AM
+*
+* -- Revision v1.0 --
+* Austin:
+*  Created include file
+===============================================================*/
+
+/*
+ * InitializeSettings()
+ * 
+ * Purpose
+ * Initializes g_settings in the brain.
+ *
+ * Parameters
+ *
+ * Return value
+ * Always returns 1
+ *
+ */
+function InitializeSettings()
+	
+	g_settings := NPC_LoadTemplateSettings(npc);
+	g_settings := NPC_GetDefaultSettings(g_settings);
+	g_settings := NPC_LoadScriptSettings(npc);
+		
+	return 1;
+endfunction
+
+/*
+ * InitializeEvents()
+ *
+ * Purpose
+ * Enables system events the core sends based on g_settings
+ *
+ * Parameters
+ *
+ * Return value
+ * Always returns 1
+ *
+ */
+function InitializeEvents()
+	//
+	// * Events that use the core 'speech' range.
+	//
+	if ( g_scripts.Exists(&quot;Listen&quot;) )
+		if ( g_settings[&quot;HearSpeech&quot;] )
+			EnableEvents(SYSEVENT_SPEECH, g_settings[&quot;ListenRange&quot;]);
+		endif
+		if ( g_settings[&quot;HearGhosts&quot;] )
+			EnableEvents(SYSEVENT_GHOST_SPEECH, g_settings[&quot;ListenRange&quot;]);
+		endif
+	endif
+		
+	//
+	// * Events that use the core 'area size' range.
+	//
+	if ( g_scripts.Exists(&quot;EnterArea&quot;) )
+		EnableEvents(SYSEVENT_ENTEREDAREA, g_settings[&quot;AreaSize&quot;]);
+	endif
+	if ( g_scripts.Exists(&quot;LeftArea&quot;) )
+		EnableEvents(SYSEVENT_LEFTAREA, g_settings[&quot;AreaSize&quot;]);
+	endif
+	if ( g_scripts.Exists(&quot;GoneCriminal&quot;) )
+		EnableEvents(SYSEVENT_GONE_CRIMINAL, g_settings[&quot;AreaSize&quot;]);
+	endif
+	
+	//
+	// * Events that do not have a core range check.
+	//
+	if ( g_scripts.Exists(&quot;DblClick&quot;) )
+		EnableEvents(SYSEVENT_DOUBLECLICKED);
+	endif
+	if ( g_scripts.Exists(&quot;ItemGiven&quot;) )
+		EnableEvents(SYSEVENT_ITEM_GIVEN);
+	endif
+	if ( g_scripts.Exists(&quot;Disengaged&quot;) )
+		EnableEvents(SYSEVENT_DISENGAGED);
+	endif
+	if ( g_scripts.Exists(&quot;Merchant&quot;) )
+		EnableEvents(SYSEVENT_MERCHANT_BOUGHT);
+		EnableEvents(SYSEVENT_MERCHANT_SOLD);
+	endif
+	if ( g_scripts.Exists(&quot;Combat&quot;) )
+		EnableEvents(SYSEVENT_ENGAGED+SYSEVENT_DAMAGED);
+	endif
+	
+	return 1;
+endfunction
+
+/*
+ * StartupScripts()
+ *
+ * Purpose
+ * Runs the restart_script or init_script. Sets up the npc_info cprop.
+ *
+ * Parameters
+ *
+ * Return value
+ * Returns 1 on success
+ *
+ */
+function StartupScripts()
+	if ( GetObjProperty(npc, &quot;npc_info&quot;) )
+		//This can only happen if restart() was done on the npc or when POL starts up.
+		
+		SetWarmode(0);
+		//StopNerves();
+		
+		if ( g_scripts.Exists(&quot;restart_script&quot;) )
+			var restart_script := Run_Script_To_Completion(g_scripts[&quot;restart_script&quot;], {npc, g_settings});
+			if ( restart_script.errortext )
+				FatalError(&quot;Restart script failed:&quot;+restart_script.errortext);
+				return 0;
+			endif
+		endif
+	else
+		var npc_info := struct{&quot;npctemplate&quot;:=npc.npctemplate, &quot;serial&quot;:=npc.serial};
+		SetObjProperty(npc, &quot;npc_info&quot;, npc_info);
+		
+		if ( g_scripts.Exists(&quot;init_script&quot;) )
+			var init_script := Run_Script_To_Completion(g_scripts[&quot;init_script&quot;], {npc, g_settings});
+			if ( init_script.errortext )
+				FatalError(&quot;Init script failed:&quot;+init_script.errortext);
+				return 0;
+			endif
+		endif
+	endif
+	
+	return 1;
+endfunction
\ No newline at end of file

Added: trunk/096/pkg/mobiles/ai_brain/include/eventid.inc
===================================================================
--- trunk/096/pkg/mobiles/ai_brain/include/eventid.inc	2005-09-04 16:15:18 UTC (rev 53)
+++ trunk/096/pkg/mobiles/ai_brain/include/eventid.inc	2005-09-04 16:17:40 UTC (rev 54)
@@ -0,0 +1,70 @@
+/*===============================================================
+* Current Version
+* EVENTID.INC - v1.0
+* Updated 8/31/2005 5:50AM
+*
+* -- Revision v1.0 --
+* Austin:
+*  Created include file
+===============================================================*/
+
+//
+// * Custom brain AI event IDs
+//
+const NPCEVENT_MOVE				:= 0xA00003;	// Has NEMOVE_* helper constants
+const NPCEVENT_OPPONENT				:= 0xA00004;	// Set New Opponent (.source)
+const NPCEVENT_SPEAK				:= 0xA00005;	// Speak (.text)
+const NPCEVENT_TURN				:= 0xA00006;	// Turn towards or away from an object
+const NPCEVENT_WARMODE				:= 0xA00007;	// Set WarMode state (.value=0|1)
+const NPCEVENT_ATTACK				:= 0xA0000A;	// Tell the npc to attack something
+const NPCEVENT_MOVE_XY				:= 0xA0000B;	// Tell the NPC to move to coordinates
+const NPCEVENT_TURN_XY				:= 0xA0000C;	// Tell the NPC to turn towards coordinates
+const NPCEVENT_WANDER				:= 0xA0000D;	// Tell the npc to wander
+
+const NPCEVENT_ENDNERVE				:= 0xA0000F;	// Tell the brain to stop a nerve.
+const NPCEVENT_STARTNERVE			:= 0xA00010;	// Tell the brain to start a nerve.
+const NPCEVENT_DONE				:= 0xA00011;	// Brain tells a nerve that its instruction is done.
+
+const NPCEVENT_SLEEP				:= 0xA00012;	// Tell the brain to go to sleep.
+const NPCEVENT_WAKEUP				:= 0xA00013;	// Tell the brain to wake up.
+
+const NPCEVENT_FWDNERVE				:= 0xA00014;	// Tell the brain to forward an event to a nerve.
+
+//
+// * NPCEVENT_MOVE helper constants (.source = object)
+//
+const NEMOVE_WALK				:= 1;	// .speed (default)
+const NEMOVE_RUN				:= 2;	// .speed
+const NEMOVE_TOWARD 				:= 1;	// .direction (default)
+const NEMOVE_AWAY				:= 2;	// .direction
+
+//
+// * NE_TURN helper constants
+//
+const NETURN_TOWARD				:= 1;
+const NETURN_AWAY				:= 2;
+
+//
+// * AWAKEN CONSTANTS
+// 
+const WAKEUP					:= 0;
+const NOWAKE					:= 1;
+
+//
+// * CLEAR THOUGHT CONSTANTS
+//
+const CLR_BRAIN					:= 1;
+const CLR_NERVE					:= 2;
+const CLR_BOTH					:= 3;
+
+//
+//* NPC.EM constants (only brain can access npc.em)
+//
+// Constants for texttype flags in the AI_Speak() function
+const SPEAK_TEXTTYPE_DEFAULT			:= &quot;default&quot;;
+const SPEAK_TEXTTYPE_WHISPER			:= &quot;whisper&quot;;
+const SPEAK_TEXTTYPE_YELL			:= &quot;yell&quot;;
+
+// Constants for doevent flag in AI_Speak() function
+const SPEAK_DOEVENT_DISABLE			:= 0x0;
+const SPEAK_DOEVENT_ENABLE			:= 0x1;

Added: trunk/096/pkg/mobiles/ai_brain/include/npcCommands.inc
===================================================================
--- trunk/096/pkg/mobiles/ai_brain/include/npcCommands.inc	2005-09-04 16:15:18 UTC (rev 53)
+++ trunk/096/pkg/mobiles/ai_brain/include/npcCommands.inc	2005-09-04 16:17:40 UTC (rev 54)
@@ -0,0 +1,520 @@
+/*===============================================================
+* Current Version
+* NPC_COMMANDS.INC - v1.0
+* Updated 8/31/2005 6:38AM
+*
+* -- Revision v1.0 --
+* Austin:
+*  Created include file
+===============================================================*/
+
+use uo;
+use os;
+
+include &quot;include/sysEvent&quot;;
+include &quot;:ai_brain:include/eventid&quot;;
+
+/////////////////////////////////////////////////////////////////
+// * Function List *
+//
+// AI_Attack(mobile, opponent, no_wake:=WAKEUP)
+// AI_ClearThoughts(mobile, flags)
+// AI_EndNerve(mobile, nerve_name, no_wake:=WAKEUP)
+// AI_Flee(mobile, opponent, no_wake:=WAKEUP)
+// AI_FowardEvent(mobile, nerve_name, mask, data, no_wake:=WAKEUP)
+// AI_Move(mobile, object, to_from:=NEMOVE_TOWARD, speed:=NEMOVE_RUN, no_wake:=WAKEUP, loop:=0)
+// AI_MoveXY(mobile, x, y, to_from:=NEMOVE_TOWARD, speed:=NEMOVE_RUN, no_wake:=WAKEUP, loop:=0)
+// AI_SetOpponent(mobile, opponent, no_wake:=WAKEUP)
+// AI_Sleep(mobile)
+// AI_Speak(mobile, text, text_type:=SPEAK_TEXTTYPE_DEFAULT, do_event:=SPEAK_DOEVENT_DISABLE, no_wake:=WAKEUP)
+// AI_StartNerve(mobile, nerve_name, script_name, data, no_wake:=WAKEUP)
+// AI_Turn(mobile, turn_to, direction:=NETURN_TOWARD, no_wake:=WAKEUP)
+// AI_TurnXY(mobile, x, y, direction:=NETURN_TOWARD, no_wake:=WAKEUP)
+// AI_WakeUp(mobile)
+// AI_Wander(mobile, no_wake:=WAKEUP, loop:=0)
+// AI_WarMode(mobile, mode:=0, no_wake:=WAKEUP)
+// 
+/////////////////////////////////////////////////////////////////
+
+/*
+ * AI_Attack(mobile, opponent, no_wake)
+ *
+ * Purpose
+ * Triggers the npc's combat script on opponent.
+ *
+ * Parameters
+ * mobile:	The npc that will receive the command.
+ * opponent:	What the npc's combat nerve will attack.
+ * no_wake:	Optional wakeup flag:
+ *		WAKEUP - Will stop the sleep script if it is running - Default.
+ *		NOWAKE - Will not stop the sleep script if it is running.
+ *
+ * Return value
+ * Result of SendEvent()
+ *
+ */
+function AI_Attack(mobile, opponent, no_wake:=WAKEUP)
+	var ev		:= struct;
+	ev.+type	:= SYSEVENT_ENGAGED;
+	ev.+source	:= opponent;
+	ev.+WakeUp	:= no_wake;
+	ev.+process	:= GetProcess(GetPid());
+
+	return SendEvent(mobile, ev);
+endfunction
+
+/*
+ * AI_ClearThoughts(mobile, flags)
+ *
+ * Purpose
+ * Clears the event queue for the script calling it and or the brain.
+ *
+ * Parameters
+ * mobile:	A reference to the npc.
+ * flags:	CLR_* flag for what scripts should have their event queues cleared.
+ *		CLR_BRAIN - Clears the brain's queue.
+ *		CLR_NERVE - Clears the nerve's queue.
+ *		CLR_BOTH  - Clears the queue for both.
+ *
+ * Return value
+ * Always returns 1
+ *
+ */
+function AI_ClearThoughts(mobile, flags)
+	var brain	:= flags &amp; CLR_BRAIN;
+	var nerve	:= flags &amp; CLR_NERVE;
+	var both	:= flags &amp; CLR_BOTH;
+
+	if ( both || brain )
+		brain := mobile.process;
+		brain.clear_event_queue();
+	endif
+
+	if ( both || nerve )
+		nerve := GetProcess(GetPid());
+		nerve.clear_event_queue();
+	endif
+
+	return 1;
+endfunction
+
+/*
+ * AI_EndNerve(mobile, nerve_name, no_wake)
+ *
+ * Purpose
+ * Used to tell the brain to stop a nerve script.
+ *
+ * Parameters
+ * mobile:	The npc that will receive the command.
+ * nerve_name:	String containing the name of the nerve (dictionary key).
+ * no_wake:	Optional wakeup flag:
+ *		WAKEUP - Will stop the sleep script if it is running - Default.
+ *		NOWAKE - Will not stop the sleep script if it is running.
+ *
+ * Return value
+ * Result of SendEvent()
+ *
+ */
+function AI_EndNerve(mobile, nerve_name, no_wake:=WAKEUP)
+	var ev		:= struct;
+	ev.+type	:= NPCEVENT_ENDNERVE;
+	ev.+name	:= nerve_name;
+	ev.+WakeUp	:= no_wake;
+	ev.+process	:= GetProcess(GetPid());
+
+	return SendEvent(mobile, ev);
+endfunction
+
+/*
+ * AI_Flee(mobile, opponent, no_wake)
+ *
+ * Purpose
+ * Used to tell the brain to stop a nerve script.
+ *
+ * Parameters
+ * mobile:	The npc that will receive the command.
+ * opponent:	Opponent to flee from.
+ * no_wake:	Optional wakeup flag:
+ *		WAKEUP - Will stop the sleep script if it is running - Default.
+ *		NOWAKE - Will not stop the sleep script if it is running.
+ *
+ * Return value
+ * Result of SendEvent()
+ *
+ */
+function AI_Flee(mobile, opponent, no_wake:=WAKEUP)
+	var ev		:= struct;
+	ev.+type	:= NPCEVENT_FLEE;
+	ev.+source	:= opponent;
+	ev.+WakeUp	:= no_wake;
+	ev.+process	:= GetProcess(GetPid());
+
+	return SendEvent(mobile, ev);
+endfunction
+
+/*
+ * AI_ForwardEvent(mobile, nerve_name, mask, data, no_wake)
+ *
+ * Purpose
+ * Used to send an event from one nerve to another.
+ *
+ * Parameters
+ * mobile:	The npc that will receive the command.
+ * nerve_name:	String containing the name of the nerve to forward the event to (dictionary key).
+ * mask:	The type of event the nerve should handle the forward as. (example: SYSEVENT_LEFTAREA)
+ * data:	Data that the nerve will receive.
+ * no_wake:	Optional wakeup flag:
+ *		WAKEUP - Will stop the sleep script if it is running - Default.
+ *		NOWAKE - Will not stop the sleep script if it is running.
+ *
+ * Return value
+ * Result of SendEvent()
+ *
+ */
+function AI_FowardEvent(mobile, nerve_name, mask, data, no_wake:=WAKEUP)
+	var ev		:= struct;
+	ev.+type	:= NPCEVENT_FWDNERVE;
+	ev.+NerveName	:= nerve_name;
+	ev.+mask	:= mask;
+	ev.+data	:= data;
+	ev.+WakeUp	:= no_wake;
+	ev.+process	:= GetProcess(GetPid());
+
+	return SendEvent(mobile, ev);
+endfunction
+
+/*
+ * AI_Move(mobile, opponent, to_from, speed, no_wake, loop)
+ *
+ * Purpose
+ * Commands an npc to move toward / away from an item or mobile.
+ *
+ * Parameters
+ * mobile:	The npc that will receive the command.
+ * object:	Item or mobile the npc will move away from/toward.
+ * to_from:	Direction the npc will go:
+ *		NEMOVE_TOWARD - Will make the npc move toward the object - Default
+ *		NEMOVE_AWAY   - Will make the npc move away from the object.
+ * speed:	Speed the npc will move at:
+ *		NEMOVE_RUN  - NPC will run
+ *		NEMOVE_WALK - NPC will walk
+ * no_wake:	Optional wakeup flag::
+ *		WAKEUP - Will stop the sleep script if it is running - Default.
+ *		NOWAKE - Will not stop the sleep script if it is running.
+ * loop:	Number of steps for the npc to take toward/away from the object.
+ *		Note: Loop can be interrupted and end prematurely!
+ *
+ * Return value
+ * Result of SendEvent()
+ *
+ */
+function AI_Move(mobile, object, to_from:=NEMOVE_TOWARD, speed:=NEMOVE_RUN, no_wake:=WAKEUP, loop:=0)
+	var ev		:= struct;
+	ev.+type	:= NPCEVENT_MOVE;
+	ev.+source	:= object;
+	ev.+direction	:= to_from;
+	ev.+speed	:= speed;
+	ev.+WakeUp	:= no_wake;
+	ev.+loop	:= loop;
+	ev.+process	:= GetProcess(GetPid());
+
+	return SendEvent(mobile, ev);
+endfunction
+
+/*
+ * AI_MoveXY(mobile, x, y, to_from, speed, no_wake, loop)
+ *
+ * Purpose
+ * Commands an npc to move toward or away from an XY coordinate.
+ *
+ * Parameters
+ * mobile:	The npc that will receive the command.
+ * x:		X coordinate to move away from/toward
+ * y:		Y coordinate to move away from/toward
+ * to_from:	Direction the npc will go:
+ *		NEMOVE_TOWARD - Will make the npc move toward the object - Default
+ *		NEMOVE_AWAY   - Will make the npc move away from the object.
+ * speed:	Speed the npc will move at:
+ *		NEMOVE_RUN  - NPC will run
+ *		NEMOVE_WALK - NPC will walk
+ * no_wake:	Optional wakeup flag::
+ *		WAKEUP - Will stop the sleep script if it is running - Default.
+ *		NOWAKE - Will not stop the sleep script if it is running.
+ * loop:	Number of steps for the npc to take toward/away from the object.
+ *		Note: Loop can be interrupted and end prematurely!
+ *
+ * Return value
+ * Result of SendEvent()
+ *
+ */
+function AI_MoveXY(mobile, x, y, to_from:=NEMOVE_TOWARD, speed:=NEMOVE_RUN, no_wake:=WAKEUP, loop:=0)
+	var ev		:= struct;
+	ev.+type	:= NPCEVENT_MOVE_XY;
+	ev.+x		:= x;
+	ev.+y		:= y;
+	ev.+direction	:= to_from;
+	ev.+speed	:= speed;
+	ev.+WakeUp	:= no_wake;
+	ev.+loop	:= loop;
+	ev.+process	:= GetProcess(GetPid());
+
+	return SendEvent(mobile, ev);
+endfunction
+
+/*
+ * AI_SetOpponent(mobile, opponent, no_wake)
+ *
+ * Purpose
+ * Places the npc into war mode and sets an opponent.
+ *
+ * Parameters
+ * mobile:	The npc that will receive the command.
+ * opponent:	Mobile reference that will be considered an opponent.
+ * no_wake:	Optional wakeup flag:
+ *		WAKEUP - Will stop the sleep script if it is running - Default.
+ *		NOWAKE - Will not stop the sleep script if it is running.
+ *
+ * Return value
+ * Result of SendEvent()
+ *
+ */
+function AI_SetOpponent(mobile, opponent, no_wake:=WAKEUP)
+	var ev		:= struct;
+	ev.+type	:= NPCEVENT_OPPONENT;
+	ev.+source	:= opponent;
+	ev.+WakeUp	:= no_wake;
+	ev.+process	:= GetProcess(GetPid());
+
+	return SendEvent(mobile, ev);
+endfunction
+
+/*
+ * AI_Sleep(mobile)
+ *
+ * Purpose
+ * Instructs the npc to go into sleep mode - shuts down all nerves.
+ *
+ * Parameters
+ * mobile:	The npc that will receive the command.
+ *
+ * Return value
+ * Result of SendEvent()
+ *
+ */
+function AI_Sleep(mobile)
+	var ev		:= struct;
+	ev.+type	:= NPCEVENT_SLEEP;
+	ev.+WakeUp	:= NOWAKE;
+	ev.+process	:= GetProcess(GetPid());
+
+	return SendEvent(mobile, ev);
+endfunction
+
+/*
+ * AI_Speak(mobile, text, text_type, do_event, no_wake)
+ *
+ * Purpose
+ * Commands the NPC to speak.
+ *
+ * Parameters
+ * mobile:	The npc that will receive the command.
+ * text:	The text the npc will speak.
+ * text_type:	text_type for npc.em :
+ *		SPEAK_TEXTTYPE_DEFAULT - Default
+ *		SPEAK_TEXTTYPE_WHISPER
+ *		SPEAK_TEXTTYPE_YELL
+ * do_event:	Flags for sending a system event for speech to surrounding npcs.
+ *		SPEAK_DOEVENT_DISABLE - Default
+ *		SPEAK_DOEVENT_ENABLE
+ * no_wake:	Optional wakeup flag:
+ *		WAKEUP - Will stop the sleep script if it is running - Default.
+ *		NOWAKE - Will not stop the sleep script if it is running.
+ *
+ * Return value
+ * Result of SendEvent()
+ *
+ */
+function AI_Speak(mobile, text, text_type:=SPEAK_TEXTTYPE_DEFAULT, do_event:=SPEAK_DOEVENT_DISABLE, no_wake:=WAKEUP)
+	var ev		:= struct;
+	ev.+type	:= NPCEVENT_SPEAK;
+	ev.+text	:= text;
+	ev.+texttype	:= text_type;
+	ev.+doevent	:= do_event;
+	ev.+WakeUp	:= no_wake;
+	ev.+process	:= GetProcess(GetPid());
+
+	return SendEvent(mobile, ev);
+endfunction
+
+/*
+ * AI_StartNerve(mobile, nerve_name, script_name, data, no_wake)
+ *
+ * Purpose
+ * Used to start a custom nerve up from within a nerve.
+ *
+ * Parameters
+ * mobile:	The npc that will receive the command.
+ * nerve_name:	String containing the name of the nerve (dictionary key).
+ * script_name:	Path of the script to start.
+ * data:	Data to be sent to the nerve once it starts.
+ * no_wake:	Optional wakeup flag:
+ *		WAKEUP - Will stop the sleep script if it is running - Default.
+ *		NOWAKE - Will not stop the sleep script if it is running.
+ *
+ * Return value
+ * Result of SendEvent()
+ *
+ */
+function AI_StartNerve(mobile, nerve_name, script_name, data, no_wake:=WAKEUP)
+	var ev		:= struct;
+	ev.+type	:= NPCEVENT_STARTNERVE;
+	ev.+name	:= nerve_name;
+	ev.+script	:= script_name;
+	ev.+data	:= data;
+	ev.+WakeUp	:= no_wake;
+	ev.+process	:= GetProcess(GetPid());
+
+	return SendEvent(mobile, ev);
+endfunction
+
+/*
+ * AI_Turn(mobile, turn_to, direction, no_wake)
+ *
+ * Purpose
+ * Commands the NPC to face away from / toward an object.
+ *
+ * Parameters
+ * mobile:	The npc that will receive the command.
+ * turn_to:	item or moble reference to turn away from / toward.
+ * direction:	Direction the npc will face:
+ *		NETURN_TOWARD - Will make the npc turn toward the object - Default.
+ 		NETURN_AWAY   - Will make the npc turn away from the object.
+ * no_wake:	Optional wakeup flag:
+ *		WAKEUP - Will stop the sleep script if it is running - Default.
+ *		NOWAKE - Will not stop the sleep script if it is running.
+ *
+ * Return value
+ * Result of SendEvent()
+ *
+ */
+function AI_Turn(mobile, turn_to, direction:=NETURN_TOWARD, no_wake:=WAKEUP)
+	var ev		:= struct;
+	ev.+type	:= NPCEVENT_TURN;
+	ev.+source	:= turn_to;
+	ev.+direction	:= direction;
+	ev.+WakeUp	:= no_wake;
+	ev.+process	:= GetProcess(GetPid());
+
+	return SendEvent(mobile, ev);
+endfunction
+
+/*
+ * AI_TurnXY(mobile, x, y, direction, no_wake)
+ *
+ * Purpose
+ * Commands the NPC to face away from / toward a coordinate.
+ *
+ * Parameters
+ * mobile:	The npc that will receive the command.
+ * x:		X coordinate to turn away from / toward.
+ * y:		Y coordinate to turn away from / toward.
+ * direction:	Direction the npc will face:
+ *		NETURN_TOWARD - Will make the npc turn toward the object - Default.
+ 		NETURN_AWAY   - Will make the npc turn away from the object.
+ * no_wake:	Optional wakeup flag:
+ *		WAKEUP - Will stop the sleep script if it is running - Default.
+ *		NOWAKE - Will not stop the sleep script if it is running.
+ *
+ * Return value
+ * Result of SendEvent()
+ *
+ */
+function AI_TurnXY(mobile, x, y, direction:=NETURN_TOWARD, no_wake:=WAKEUP)
+	var ev		:= struct;
+	ev.+type	:= NPCEVENT_TURN_XY;
+	ev.+x		:= x;
+	ev.+y		:= y;
+	ev.+direction	:= direction;
+	ev.+WakeUp	:= no_wake;
+	ev.+process	:= GetProcess(GetPid());
+
+	return SendEvent(mobile, ev);
+endfunction
+
+/*
+ * AI_WakeUp(mobile)
+ *
+ * Purpose
+ * Sends an event to the npc causing its sleep script to end.
+ *
+ * Parameters
+ * mobile:	The npc that will receive the command.
+ *
+ * Return value
+ * Result of SendEvent()
+ *
+ */
+function AI_WakeUp(mobile)
+	var ev		:= struct;
+	ev.+type	:= NPCEVENT_WAKEUP;
+	ev.+WakeUp	:= WAKEUP;
+	ev.+process	:= GetProcess(GetPid());
+
+	return SendEvent(mobile, ev);
+endfunction
+
+/*
+ * AI_Wander(mobile, opponent, no_wake)
+ *
+ * Purpose
+ * Commands the NPC to wander one step in a random direction.
+ *
+ * Parameters
+ * mobile:	The npc that will receive the command.
+ * no_wake:	Optional wakeup flag:
+ *		WAKEUP - Will stop the sleep script if it is running - Default.
+ *		NOWAKE - Will not stop the sleep script if it is running.
+ * loop:	Number of times to attempt to wander.
+ *		Note: Loop can be interrupted and end prematurely!
+ *
+ * Return value
+ * Result of SendEvent()
+ *
+ */
+function AI_Wander(mobile, no_wake:=WAKEUP, loop:=0)
+	var ev		:= struct;
+	ev.+type	:= NPCEVENT_WANDER;
+	ev.+WakeUp	:= no_wake;
+	ev.+loop	:= CInt(loop);
+	ev.+process	:= GetProcess(GetPid());
+
+	return SendEvent(mobile, ev);
+endfunction
+
+/*
+ * AI_WarMode(mobile, mode, no_wake)
+ *
+ * Purpose
+ * Toggles warmode on the npc. Setting to 0 also clears the opponent.
+ *
+ * Parameters
+ * mobile:	The npc that will receive the command.
+ * mode:	0 - Takes the NPC out of warmode and clears the opponent - Default.
+ *		1 - Places the npc into warmode.
+ * no_wake:	Optional wakeup flag:
+ *		WAKEUP - Will stop the sleep script if it is running - Default.
+ *		NOWAKE - Will not stop the sleep script if it is running.
+ *
+ * Return value
+ * Result of SendEvent()
+ *
+ */
+function AI_WarMode(mobile, mode:=0, no_wake:=WAKEUP)
+	var ev		:= struct;
+	ev.+type	:= NPCEVENT_WARMODE;
+	ev.+value	:= mode;
+	ev.+WakeUp	:= no_wake;
+	ev.+process	:= GetProcess(GetPid());
+
+	return SendEvent(mobile, ev);
+endfunction

Added: trunk/096/pkg/mobiles/ai_brain/include/npcError.inc
===================================================================
--- trunk/096/pkg/mobiles/ai_brain/include/npcError.inc	2005-09-04 16:15:18 UTC (rev 53)
+++ trunk/096/pkg/mobiles/ai_brain/include/npcError.inc	2005-09-04 16:17:40 UTC (rev 54)
@@ -0,0 +1,36 @@
+/*===============================================================
+* Current Version
+* NPC_ERRORS.INC - v1.0
+* Updated 8/31/2005 5:08AM
+*
+* -- Revision v1.0 --
+* Austin:
+*  Created include file
+===============================================================*/
+
+use uo;
+use os;
+
+/*
+ * NPC_ErrorSysLog(errmsg)
+ *
+ * Purpose
+ * Logs an error message.
+ *
+ * Parameters
+ * errmsg:	Error message
+ *
+ * Return value
+ * Always returns 1
+ *
+ */
+function NPC_ErrorSysLog(mobile, errmsg)
+	Set_Critical(1);
+	SysLog(&quot;NPC Template: &quot; + mobile.npctemplate);
+	SysLog(&quot;NPC Name    : &quot; + mobile.name);
+	SysLog(errmsg );
+	SysLog(&quot;------------&quot;);
+	Set_Critical(0);
+	
+	return 1;
+endfunction
\ No newline at end of file

Added: trunk/096/pkg/mobiles/ai_brain/include/npcNerves.inc
===================================================================
--- trunk/096/pkg/mobiles/ai_brain/include/npcNerves.inc	2005-09-04 16:15:18 UTC (rev 53)
+++ trunk/096/pkg/mobiles/ai_brain/include/npcNerves.inc	2005-09-04 16:17:40 UTC (rev 54)
@@ -0,0 +1,213 @@
+/*===============================================================
+* Current Version
+* NERVES.INC - v1.0
+* Updated 9/1/2005 6:15PM
+*
+* -- Revision v1.0 --
+* Austin:
+*  Created include file
+===============================================================*/
+
+use uo;
+use os;
+
+include &quot;:ai_brain:include/npcError&quot;;
+
+/////////////////////////////////////////////////////////////////
+// * Function List *
+//
+// GetNerveFlags(mobile, nerve_name, byref nerve_dict:=0)
+// GetNerveProcess(mobile, nerve_name, byref nerve_dict:=0)
+// LoadNerves(mobile)
+// SaveNerves(mobile, nerve_dict)
+// StartNerve(mobile, nerve_name, nerve_script, data:=array, flags:=NF_NO_FLAGS, byref nerve_dict:=0)
+// StopNerve(mobile, nerve_name, byref nerve_dict:=0)
+//
+/////////////////////////////////////////////////////////////////
+// * Global Varibles *
+//
+// Nerve flags
+const NF_NO_FLAGS		:= 0x0;
+const NF_CONTINUE_ON_SLEEP	:= 0x1;
+//
+/////////////////////////////////////////////////////////////////
+
+/*
+ * LoadNerves()
+ *
+ * Purpose
+ * Loads nerve information for an npc.
+ *
+ * Parameters
+ * mobile:	NPC to get the nerve settings from.
+ *
+ * Return value
+ * Returns a dictionary
+ *
+ */
+function LoadNerves(mobile)
+	var nerve_dict := GetObjProperty(mobile, &quot;#NerveInfo&quot;);
+	if ( Lower(TypeOf(nerve_dict)) != &quot;dictionary&quot; )
+		nerve_dict := dictionary;
+	endif
+
+	return nerve_dict;
+endfunction
+
+/*
+ * SaveNerves(mobile, nerve_dict)
+ *
+ * Purpose
+ * Saves nerve information for an npc.
+ *
+ * Parameters
+ * mobile:	NPC to save the nerve settings on.
+ * nerve_dict:	Dictionary containing nerve information.
+ *
+ * Return value
+ * Returns 1 on success
+ *
+ */
+function SaveNerves(mobile, byref nerve_dict)
+	return SetObjProperty(mobile, &quot;#NerveInfo&quot;, nerve_dict);
+endfunction
+
+/*
+ * GetNerveProcess(mobile, nerve_name, byref nerve_dict)
+ *
+ * Purpose
+ * Retrieves a reference to a running nerve script.
+ *
+ * Parameters
+ * mobile:	NPC to get the nerve information from.
+ * nerve_name:	Name of the nerve to get the information for.
+ * nerve_dict:	Optional parameter. Use if the settings were already loaded for faster access.
+ *
+ * Return value
+ * Returns a script reference.
+ *
+ */
+function GetNerveProcess(mobile, nerve_name, byref nerve_dict:=0)
+	if ( !nerve_dict )
+		nerve_dict := LoadNerves(mobile);
+	endif
+
+	if ( nerve_dict.exists(nerve_name) )
+		return GetProcess(CInt(nerve_dict[nerve_name].pid));
+	else
+		return error{&quot;errortext&quot; := &quot;GetNerveProcess() - Invalid nerve name  [&quot;+nerve_name+&quot;]&quot;};
+	endif
+endfunction
+
+/*
+ * GetNerveFlags(mobile, nerve_name, byref nerve_dict)
+ *
+ * Purpose
+ * Retrieves the flag setting set on a nerve.
+ *
+ * Parameters
+ * mobile:	NPC to get the nerve information from.
+ * nerve_name:	Name of the nerve to get the information for.
+ * nerve_dict:	Optional parameter. Use if the settings were already loaded for faster access.
+ *
+ * Return value
+ * Returns a script reference.
+ *
+ */
+function GetNerveFlags(mobile, nerve_name, byref nerve_dict:=0)
+	if ( !nerve_dict )
+		nerve_dict := LoadNerves(mobile);
+	endif
+
+	if ( nerve_dict.exists(nerve_name) )
+		return GetProcess(CInt(nerve_dict[nerve_name].flags));
+	else
+		return error{&quot;errortext&quot; := &quot;GetNerveProcess() - Invalid nerve name  [&quot;+nerve_name+&quot;]&quot;};
+	endif
+endfunction
+
+/*
+ * StartNerve(mobile, nerve_name, nerve_script, data, flags, byref nerve_dict)
+ *
+ * Purpose
+ * Starts up a nerve script.
+ *
+ * Parameters
+ * mobile:	NPC the nerve will be running for.
+ * nerve_name:	The name the nerve script will be run under. (Example: &quot;CombatScript&quot; or &quot;EnterReact&quot;)
+ * data:	Array of data to send to the nerve script when it starts.
+ * flags:	Can contain anything - but should use NF_* flags for bitwise checks.
+ * nerve_dict:	Optional parameter. Use if the settings were already loaded for faster access.
+ *
+ * Notes:
+ * data[1] - Will contain the mobile argument.
+ * data[2] - Will contain the nerve name argument.
+ * If data is not an array, it will be placed at index[3].
+ * If data is sent as an array, it will begin at the index of [3].
+ *
+ * Return value
+ * Returns a script reference to the nerve script.
+ *
+ */
+function StartNerve(mobile, nerve_name, nerve_script, data:=array, flags:=NF_NO_FLAGS, byref nerve_dict:=0)
+	if ( Lower(TypeOf(data)) != &quot;array&quot;)
+		data := array{data};
+	endif
+	//Mobile is always the begining of the data array.
+	data.Insert(1, mobile);
+	//Nerve name is always the second part of the data array.
+	data.Insert(2, nerve_name);
+
+	var process := start_script(nerve_script, data);
+
+	if ( process.errortext )
+		var errmsg := &quot;StartNerve() [&quot;+nerve_name+&quot;] [&quot;+nerve_script+&quot;] failed to start! -&gt;&quot;+process.errortext;
+		NPC_ErrorSysLog(mobile, errmsg);
+		return error{&quot;errortext&quot;:=errmsg};
+	else
+		//Before setting the new nerve, check if one is already running.
+		if ( nerve_dict.exists(nerve_name) )
+			//Stop the old nerve, before storing the new one.
+			StopNerve(mobile, nerve_name, nerve_dict);
+		endif
+		var nerve_info := struct;
+		nerve_info.+pid := process.pid;
+		nerve_info.+flags := flags;
+		nerve_dict[nerve_name] := nerve_info;
+
+		SaveNerves(mobile, nerve_dict);
+
+		return process;
+	endif
+endfunction
+
+/*
+ * StopNerve(mobile, nerve_name, byref nerve_dict)
+ *
+ * Purpose
+ * Starts up a nerve script.
+ *
+ * Parameters
+ * mobile:	NPC the nerve will be stopped on.
+ * nerve_name:	The name of the nerve script to stop.
+ * nerve_dict:	Optional parameter. Use if the settings were already loaded for faster access.
+ *
+ * Return value
+ * Returns 1 on success.
+ *
+ */
+function StopNerve(mobile, nerve_name, byref nerve_dict:=0)
+	if ( !nerve_dict )
+		nerve_dict := LoadNerves(mobile);
+	endif
+
+	if ( nerve_dict.Exists(nerve_name) )
+		GetNerveProcess(mobile, nerve_name, nerve_dict).kill();
+		nerve_dict.Erase(nerve_name);
+
+		return SaveNerves(mobile, nerve_dict);
+	else
+		return error{&quot;errortext&quot; := &quot;StopNerve() - Invalid nerve name  [&quot;+nerve_name+&quot;]&quot;};
+	endif
+endfunction
+

Added: trunk/096/pkg/mobiles/ai_brain/include/npcSettings.inc
===================================================================
--- trunk/096/pkg/mobiles/ai_brain/include/npcSettings.inc	2005-09-04 16:15:18 UTC (rev 53)
+++ trunk/096/pkg/mobiles/ai_brain/include/npcSettings.inc	2005-09-04 16:17:40 UTC (rev 54)
@@ -0,0 +1,165 @@
+/*===============================================================
+* Current Version
+* NPC_SETTINGS.INC - v1.0
+* Updated 8/30/2005 7:28AM
+*
+* -- Revision v1.0 --
+* Austin:
+*  Created include file
+===============================================================*/
+
+use uo;
+use os;
+use cfgfile;
+
+include &quot;:ai_brain:include/npcUtil&quot;;
+
+/*
+ * NPC_DefaultSettings(settings:=0)
+ *
+ * Purpose
+ * Checks the settings dictionary to make sure required values are set.
+ * If a dictionary is passed, it will check it for required parameters.
+ * If they are not present, they will be set.
+ * Nothing will be overwritten in this function.
+ *
+ * Parameters
+ * settings:	Optional parameter
+ *		Dictionary read in from NPC_GetDefaultSettings()
+ *
+ * Return value
+ * Returns a dictionary
+ *
+ */
+function NPC_GetDefaultSettings(settings:=0)
+	if ( Lower(TypeOf(settings)) != &quot;dictionary&quot; )
+		settings := dictionary;
+	endif
+
+	if ( CInt(settings.exists(&quot;cycle_wait&quot;)) &lt;= 0 )
+		settings[&quot;cycle_wait&quot;] := 10;
+	endif
+	if ( CInt(settings.exists(&quot;sleep_time&quot;)) &lt;= 0 )
+		settings[&quot;sleep_time&quot;] := 1024;
+	endif
+	if ( CInt(settings.exists(&quot;idle_ticks&quot;)) &lt;= 0 )
+		settings[&quot;idle_ticks&quot;] := 5;
+	endif
+
+	return settings;
+endfunction
+
+/*
+ * NPC_LoadTemplateSettings(source)
+ *
+ * Purpose
+ * Loads settings for a template from npcdesc.cfg
+ *
+ * Parameters
+ * source:	Name of the npc template to load settings for.
+ *		Can also be an npc reference - if custom settings should be loaded off it.
+ *
+ * Return value
+ * Returns a dictionary
+ *
+ */
+function NPC_LoadTemplateSettings(source)
+	var template:=source;
+	if ( source.IsA(POLCLASS_NPC) )
+		template := NPC_ParseTemplateName(source.npctemplate);
+	elseif ( !template.package )
+		template := NPC_ParseTemplateName(template);
+	endif
+
+	//
+	// * Load config defaults first
+	//
+	var npc_cfg := ReadConfigFile(template.package+&quot;npcdesc&quot;);
+	var npc_elem := npc_cfg[template.template];
+
+	var setting_list := GetConfigStringDictionary(npc_elem, &quot;AISetting&quot;);
+	
+	var settings := dictionary;
+	foreach setting_name in (setting_list.keys())
+		settings[setting_name] := UnPack(setting_list[setting_name]);
+		sleepms(2);
+	endforeach
+
+	//
+	// * If the source is an npc, check it for custom settings.
+	//
+	if ( source.IsA(POLCLASS_NPC) )
+		var cstm_settings := GetObjProperty(source, &quot;AISettings&quot;);
+		foreach key in (cstm_settings.keys())
+			if ( cstm_settings[key] == error )
+				settings.Erase(key);
+			else
+				settings[key] := cstm_settings[key];
+			endif
+				
+			sleepms(2);
+		endforeach
+	endif
+	
+	return settings;
+endfunction
+
+/*
+ * NPC_LoadScriptSettings(source)
+ *
+ * Purpose
+ * Loads brain AI script settings for an NPC. Gives .script and .flag values for them.
+ *
+ * Parameters
+ * source:	Name of the npc template to load settings for.
+ *		Can also be an npc reference - if custom settings should be loaded off it.
+ *
+ * Return value
+ * Returns a dictionary
+ *
+ */
+function NPC_LoadScriptSettings(source)
+	var template:=source;
+	if ( source.IsA(POLCLASS_NPC) )
+		template := NPC_ParseTemplateName(source.npctemplate);
+	elseif ( !template.package )
+		template := NPC_ParseTemplateName(template);
+	endif
+
+	//
+	// * Load config defaults first
+	//
+	var npc_cfg := ReadConfigFile(template.package+&quot;npcdesc&quot;);
+	var npc_elem := npc_cfg[template.template];
+
+	var script_list := GetConfigStringDictionary(npc_elem, &quot;AIScript&quot;);
+	var flag_list := GetConfigStringDictionary(npc_elem, &quot;AIScriptFlag&quot;);
+
+	var script_settings := dictionary;
+	foreach script_type in (script_list.keys())
+		var temp := struct;
+		temp.+script := script_list[script_type];
+		temp.+flags := 0x0;
+		if ( flag_list[script_type] )
+			temp.flags := UnPack(flag_list[script_type]);
+		endif
+
+		script_settings[script_type] := temp;
+		sleepms(2);
+	endforeach
+
+	//
+	// * If the source is an npc, check it for custom script settings.
+	//   Assumes each key in the dictionary property has a .script and .flags pair already.
+	//
+	if ( source.IsA(POLCLASS_NPC) )
+		var cstm_scripts := GetObjProperty(source, &quot;AIScripts&quot;);
+		foreach key in (cstm_scripts.keys())
+			script_settings[key] := cstm_scripts[key];
+			sleepms(2);
+		endforeach
+	endif
+	
+	return script_settings;
+endfunction
+

Added: trunk/096/pkg/mobiles/ai_brain/include/npcUtil.inc
===================================================================
--- trunk/096/pkg/mobiles/ai_brain/include/npcUtil.inc	2005-09-04 16:15:18 UTC (rev 53)
+++ trunk/096/pkg/mobiles/ai_brain/include/npcUtil.inc	2005-09-04 16:17:40 UTC (rev 54)
@@ -0,0 +1,45 @@
+/*===============================================================
+* Current Version
+* NPC_UTIL.INC - v1.0
+* Updated 8/31/2005 4:23AM
+*
+* -- Revision v1.0 --
+* Austin:
+*  Created include file
+===============================================================*/
+
+/*
+ * NPC_ParseTemplateName(template_name)
+ *
+ * Purpose
+ * Finds the appropriate npcdesc.cfg to load.
+ * This enables npcs to be placed in packages and not just the ::npcdesc file.
+ * ReadConfigFile(&quot;:*:npcdesc&quot;) does not work in this case because packaged npcs
+ * have the package name at the begining of their .npctemplate member. Reading the
+ * specific config file - helps to avoid possible elem name collisions.
+ *
+ * Parameters
+ * template_name:	Name of the npc template to parse
+ *
+ * Return value
+ * Returns struct .package .template
+ *
+ */
+function NPC_ParseTemplateName(template_name)
+	//Find positions of &quot;:&quot; characters
+	var colon_a := Find(template_name, &quot;:&quot;, 1);
+	var colon_b := Find(template_name, &quot;:&quot;, 2);
+
+	var parsed := struct{&quot;package&quot;, &quot;template&quot;};
+
+	if ( !colon_a || !colon_b )
+		//Not a complete package name - use default npcdesc.cfg
+		parsed.package := &quot;::&quot;;
+		parsed.template := template_name;
+	else
+		parsed.package := template_name[colon_a, colon_b];
+		parsed.template := template_name[colon_b+1, Len(template_name)];
+	endif
+
+	return parsed;
+endfunction

Added: trunk/096/pkg/mobiles/ai_brain/pkg.cfg
===================================================================
--- trunk/096/pkg/mobiles/ai_brain/pkg.cfg	2005-09-04 16:15:18 UTC (rev 53)
+++ trunk/096/pkg/mobiles/ai_brain/pkg.cfg	2005-09-04 16:17:40 UTC (rev 54)
@@ -0,0 +1,14 @@
+Enabled		1
+Name		ai_brain
+
+Version		5.0
+
+CoreRequired	96
+Requires	gumps 1.5
+
+Creator		Austin Heilman
+Email		<A HREF="https://lists.berlios.de/mailman/listinfo/poldistro-svn">Austin at tsse.net</A>
+Maintainer	Austin Heilman
+Email		<A HREF="https://lists.berlios.de/mailman/listinfo/poldistro-svn">Austin at tsse.net</A>
+
+#Conflicts none


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000034.html">[Poldistro-svn] r53 - trunk/096/pkg/mobiles
</A></li>
	<LI>Next message: <A HREF="000035.html">[Poldistro-svn] r55 - trunk/096/pkg/mobiles
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#39">[ date ]</a>
              <a href="thread.html#39">[ thread ]</a>
              <a href="subject.html#39">[ subject ]</a>
              <a href="author.html#39">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/poldistro-svn">More information about the Poldistro-svn
mailing list</a><br>
</body></html>
