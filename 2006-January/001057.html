<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Poldistro-svn] r1086 - in trunk/096/pkg/multis/boat: . OLD
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/poldistro-svn/2006-January/index.html" >
   <LINK REL="made" HREF="mailto:poldistro-svn%40lists.berlios.de?Subject=Re%3A%20%5BPoldistro-svn%5D%20r1086%20-%20in%20trunk/096/pkg/multis/boat%3A%20.%20OLD&In-Reply-To=%3C200601051123.k05BN9ve028814%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   
   <LINK REL="Next"  HREF="001058.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Poldistro-svn] r1086 - in trunk/096/pkg/multis/boat: . OLD</H1>
    <B>austin at BerliOS</B> 
    <A HREF="mailto:poldistro-svn%40lists.berlios.de?Subject=Re%3A%20%5BPoldistro-svn%5D%20r1086%20-%20in%20trunk/096/pkg/multis/boat%3A%20.%20OLD&In-Reply-To=%3C200601051123.k05BN9ve028814%40sheep.berlios.de%3E"
       TITLE="[Poldistro-svn] r1086 - in trunk/096/pkg/multis/boat: . OLD">austin at berlios.de
       </A><BR>
    <I>Thu Jan  5 12:23:09 CET 2006</I>
    <P><UL>
        
        <LI>Next message: <A HREF="001058.html">[Poldistro-svn] r1087 - in trunk/096/pkg/multis/boat: . config deed multi plank tiller
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1057">[ date ]</a>
              <a href="thread.html#1057">[ thread ]</a>
              <a href="subject.html#1057">[ subject ]</a>
              <a href="author.html#1057">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: austin
Date: 2006-01-05 12:23:07 +0100 (Thu, 05 Jan 2006)
New Revision: 1086

Added:
   trunk/096/pkg/multis/boat/OLD/
   trunk/096/pkg/multis/boat/OLD/boat.src
   trunk/096/pkg/multis/boat/OLD/itemdesc.cfg
   trunk/096/pkg/multis/boat/OLD/pkg.cfg
   trunk/096/pkg/multis/boat/OLD/plank.src
   trunk/096/pkg/multis/boat/OLD/plankControl.src
   trunk/096/pkg/multis/boat/OLD/plankUtil.inc
   trunk/096/pkg/multis/boat/OLD/plankWalk.src
   trunk/096/pkg/multis/boat/OLD/shipDeed.src
   trunk/096/pkg/multis/boat/OLD/tillerman.src
Removed:
   trunk/096/pkg/multis/boat/boat.src
   trunk/096/pkg/multis/boat/itemdesc.cfg
   trunk/096/pkg/multis/boat/pkg.cfg
   trunk/096/pkg/multis/boat/plank.src
   trunk/096/pkg/multis/boat/plankControl.src
   trunk/096/pkg/multis/boat/plankUtil.inc
   trunk/096/pkg/multis/boat/plankWalk.src
   trunk/096/pkg/multis/boat/shipDeed.src
   trunk/096/pkg/multis/boat/tillerman.src
Log:


Added: trunk/096/pkg/multis/boat/OLD/boat.src
===================================================================
--- trunk/096/pkg/multis/boat/OLD/boat.src	2005-12-29 09:18:56 UTC (rev 1085)
+++ trunk/096/pkg/multis/boat/OLD/boat.src	2006-01-05 11:23:07 UTC (rev 1086)
@@ -0,0 +1,790 @@
+////////////////
+//	boat.src 
+//
+//	control script for boats
+//
+//	Header replaced by Racalac 9/15/02
+//
+//	Todo/Fix: Course nav needs the &quot;goto #&quot; command implimented.
+//			  Tillerman string recognition causes boat to pause
+////////////////
+
+use os;
+use uo;
+use util;
+use boat;
+
+include &quot;include/OLD/eventID&quot;;
+include &quot;include/sysEvent&quot;;
+include &quot;:itemutils:myUtil&quot;;
+include &quot;include/client&quot;;
+include &quot;include/OLD/sound&quot;;
+include &quot;:gumps:yesno&quot;;
+include &quot;util/key&quot;;
+include &quot;plankUtil&quot;;
+
+const STATE_STATIONARY := 0;
+const STATE_MOVING := 1;
+const STATE_DRIFTING := 2;
+const STATE_FOLLOWING_COURSE := 3; //NOTE NEW STATE
+const DELAY_DRIFTING := 15000;
+
+/*NOTE NEW CONSTANTS*/
+const NEGONE := -1;
+const ZERO := 0;
+const POSONE := 1;
+
+var state := STATE_STATIONARY;
+var relative_direction;
+var ms_delay_between_moves := 200;
+var boat;
+var tillerman;
+var owner := GetObjProperty(boat.hold,&quot;owner&quot;);
+var decay := GetObjProperty(boat.tillerman, &quot;decay&quot;);
+
+/*NOTE NEW GLOBAL*/
+var first_move_toward_waypoint := 1;
+
+program autostart_boat(param)
+  boat := param;
+  if(!boat)
+    syslog( &quot;[ERROR] [boat.src] Boat script running, but boat not found!&quot; );
+    return;
+  endif
+  tillerman := boat.tillerman;
+  if(!tillerman)
+    syslog( &quot;[ERROR] [boat.src] No tillerman for boat at: &quot; +(boat.x-1) +&quot;,&quot;+ boat.y +&quot;,&quot;+ boat.z + &quot;; destroying the boat...&quot; );
+    DestroyMulti(boat);
+    return;
+  endif
+  EnableEvents(SYSEVENT_SPEECH, 15);
+  RegisterForSpeechEvents(tillerman, 15);
+  var nextencounter := ReadGameClock()+(RandomInt(120) + 120);
+  var nextsound := ReadGameClock()+5;
+  var driftcounter := 1;
+  //set_critical(1);
+  var x,y;
+  while(boat)
+    if(GetObjProperty(boat.hold, &quot;#speed&quot;))
+      state := STATE_MOVING;
+      ms_delay_between_moves := GetObjProperty(boat.hold, &quot;#speed&quot;); 
+      relative_direction := GetObjProperty(boat.hold, &quot;#relativedir&quot;);
+      eraseobjproperty(boat.hold, &quot;#speed&quot;);
+      eraseobjproperty(boat.hold, &quot;#relativedir&quot;);    
+    endif     
+    decay := getobjproperty(boat.tillerman,&quot;decay&quot;);
+    if((decay) and(!getobjproperty(tillerman,&quot;nodecay&quot;)))
+      if(ReadGameClock() &gt; decay)
+        PrintTextAbove(tillerman, &quot;Arrrrrgh!  She's going down, Captain!  Abandon ship!&quot;);
+        sleep(4);
+        foreach item in EnumerateItemsInContainer( boat.hold )
+          DestroyItem(item);
+        endforeach
+        foreach mob in(boat.items)
+          DestroyItem(mob);
+        endforeach        
+        foreach mob in(boat.mobiles)
+          MoveCharacterToLocation(mob, 1, 1, 0,  MOVECHAR_FORCELOCATION );
+          SendSysMessage(mob, &quot;Your ship, badly in need of maintenance, sinks beneath the waves!&quot;);
+          SendSysMessage(mob, &quot;You awake on a distant shore...&quot;);
+        endforeach
+        if(boat.has_offline_mobiles)
+          foreach mob in(boat.offline_mobiles)
+            MoveCharacterToLocation(mob, 1, 1, 0,  MOVECHAR_FORCELOCATION );
+          endforeach
+        endif
+        DestroyMulti(boat);
+      endif
+    endif    
+    case(state)
+      STATE_MOVING:   if(ReadGameClock() &gt; nextsound)
+                        PlayBoatSounds();
+                        nextsound := ReadGameClock()+5;
+                      endif
+                      x := boat.x;
+                      y := boat.y;
+                      MoveBoatRelative(boat, relative_direction);
+                      if(boat.x == 6 or boat.x == 5097 or boat.y == 6 or boat.y == 4089)   
+                        WorldWrap();
+                      endif
+                      if((x == boat.x) &amp;&amp;(y == boat.y))
+                        ms_delay_between_moves := 1000;
+                        state := STATE_DRIFTING;
+                        PrintTextAbove(tillerman, &quot;Aaargh!  We've run ashore!&quot;);
+                        //SmackEveryone();
+                      endif
+                      sleepms(ms_delay_between_moves);
+                      if(ReadGameClock() &gt; nextencounter)
+                        DoEncounter();
+                        nextencounter := ReadGameClock()+120;
+                      endif
+                      while(events_waiting())
+                        process_event(wait_for_event(0));
+                      endwhile
+      STATE_DRIFTING:   if(ReadGameClock() &gt; nextsound)
+                          PlayBoatSounds();
+                          nextsound := ReadGameClock()+5;
+                        endif
+                        if(driftcounter &gt; 15)
+                          MoveBoatRelative(boat, RandomInt(8));
+                          driftcounter := 1;
+                        else
+                          driftcounter := driftcounter + 1;
+                        endif
+                        sleepms(1000);
+                        while(events_waiting())
+                          process_event(wait_for_event(0));
+                        endwhile
+      STATE_STATIONARY: var ev := wait_for_event(120);
+                        if(ev)
+                          process_event(ev);
+                        endif
+/*NOTE NEW BOAT STATE*/
+      STATE_FOLLOWING_COURSE:
+        		x := boat.x;
+        		y := boat.y;
+        		BoatFollowCourse(boat);
+        				
+        		sleepms(ms_delay_between_moves);
+                        while(events_waiting())
+                          process_event(wait_for_event(0));
+                        endwhile
+/*END NEW BOAT STATE*/
+    endcase
+    if(ReadGameClock() &gt; nextencounter)
+      checkres();
+      nextencounter := ReadGameClock()+120;
+    endif
+  endwhile
+endprogram
+
+function handle_speech(event)
+  var text := lower(event.text);
+  if(text[&quot;drift&quot;] || text[&quot;raise anchor&quot;])
+    ms_delay_between_moves := 1000;
+    state := STATE_DRIFTING;
+    PrintTextAbove(tillerman, &quot;Aye Aye, Captain!&quot;);
+  elseif(text[&quot;forward&quot;])
+    if(state == STATE_STATIONARY)
+      PrintTextAbove(tillerman, &quot;The anchor is down, Captain!&quot;);
+    else
+      PrintTextAbove(tillerman, &quot;Aye Aye, Captain!&quot;);
+      state := STATE_MOVING;
+      if(text[&quot;left&quot;])
+        relative_direction := 7;
+      elseif(text[&quot;right&quot;])
+        relative_direction := 1;
+      else
+        relative_direction := 0;
+      endif
+    endif
+  elseif(text[&quot;back&quot;])
+    if(state == STATE_STATIONARY)
+      PrintTextAbove(tillerman, &quot;The anchor is down, Captain!&quot;);
+    else
+      PrintTextAbove(tillerman, &quot;Aye Aye, Captain!&quot;);
+      state := STATE_MOVING;
+      if(text[&quot;left&quot;])
+        relative_direction := 5;
+      elseif(text[&quot;right&quot;])
+        relative_direction := 3;
+      else
+        relative_direction := 4;
+      endif
+    endif
+  elseif(text[&quot;stop&quot;] || text[&quot;furl sail&quot;] || text[&quot;furl&quot;])
+    PrintTextAbove(tillerman, &quot;Aye Aye, Captain!&quot;);
+    ms_delay_between_moves := 1000;
+    state := STATE_DRIFTING;
+  elseif(text[&quot;drop anchor&quot;])
+    PrintTextAbove(tillerman, &quot;Aye Aye, Captain! Anchor dropped.&quot;);
+    ms_delay_between_moves := 1000;
+    state := STATE_STATIONARY;
+  elseif(text[&quot;turn right&quot;] || text[&quot;starboard&quot;])
+    if(state == STATE_STATIONARY)
+      PrintTextAbove(tillerman, &quot;The anchor is down, Captain!&quot;);
+    else
+      PrintTextAbove(tillerman, &quot;Aye Aye, Captain!&quot;);
+      TurnBoat(boat, 1);
+    endif
+  elseif(text[&quot;right&quot;])
+    if(state == STATE_STATIONARY)
+      PrintTextAbove(tillerman, &quot;The anchor is down, Captain!&quot;);
+    else
+      PrintTextAbove(tillerman, &quot;Aye Aye, Captain!&quot;);
+      state := STATE_MOVING;
+      relative_direction := 2;
+    endif
+  elseif(text[&quot;turn left&quot;] || text[&quot;port&quot;])
+    if(state == STATE_STATIONARY)
+      PrintTextAbove(tillerman, &quot;The anchor is down, Captain!&quot;);
+    else
+      PrintTextAbove(tillerman, &quot;Aye Aye, Captain!&quot;);
+      TurnBoat(boat, 3);
+    endif
+  elseif(text[&quot;left&quot;])
+    if(state == STATE_STATIONARY)
+      PrintTextAbove(tillerman, &quot;The anchor is down, Captain!&quot;);
+    else
+      PrintTextAbove(tillerman, &quot;Aye Aye, Captain!&quot;);
+      state := STATE_MOVING;
+      relative_direction := 6;
+    endif
+  elseif(text[&quot;come about&quot;] || text[&quot;turn around&quot;])
+    if(state == STATE_STATIONARY)
+      PrintTextAbove(tillerman, &quot;The anchor is down, Captain!&quot;);
+    else
+      PrintTextAbove(tillerman, &quot;Aye Aye, Captain! Coming about!&quot;);
+      TurnBoat(boat, 2);
+      sleep(1);
+    endif
+/*NEW MAP COURSE COMMANDS*/
+    elseif(text[&quot;set course&quot;])
+      	PrintTextAbove(tillerman, &quot;Select a map for me to follow.&quot;);   	
+      	var map := Target(event.source);
+      	if(!map.isa(POLCLASS_MAP))
+      		PrintTextAbove(tillerman, &quot;Are ye dense? I need a map!&quot;); 
+      	else
+      		SetObjProperty(tillerman, &quot;course&quot;, map.GetPins());
+      		SetObjProperty(tillerman, &quot;nextwaypoint&quot;, 1);
+      		PrintTextAbove(tillerman, &quot;Arr, course plotted.&quot;); 
+      	endif
+    elseif(text[&quot;clear course&quot;])
+    	PrintTextAbove(tillerman, &quot;Arr, course cleared Cap'n.&quot;);
+    	EraseObjProperty(tillerman, &quot;course&quot;);
+    	EraseObjProperty(tillerman, &quot;nextwaypoint&quot;);
+    elseif(text[&quot;nav&quot;])
+    	if(state != STATE_FOLLOWING_COURSE)
+    		PrintTextAbove(tillerman, &quot;We are not currently following a course.&quot;);
+    	else
+    		PrintTextAbove(tillerman, &quot;We are following our course.&quot;);
+    		PrintTextAbove(tillerman, &quot;The next waypoint is #&quot; + GetObjProperty(tillerman,&quot;nextwaypoint&quot;));
+    	endif
+    elseif(text[&quot;start&quot;])
+    	if( (GetObjProperty(tillerman,&quot;course&quot;)==error) || (GetObjProperty(tillerman,&quot;nextwaypoint&quot;)==error))
+    		PrintTextAbove(tillerman,&quot;Arr, set course first Cap'n.&quot;);
+    	else    		
+     		state := STATE_FOLLOWING_COURSE;
+     		SetObjProperty(tillerman, &quot;nextwaypoint&quot;, 1);
+    		PrintTextAbove(tillerman,&quot;Aye, sailing to first waypoint.&quot;);
+    	endif
+    elseif(text[&quot;continue&quot;])
+    	if( (GetObjProperty(tillerman,&quot;course&quot;)==error) || (GetObjProperty(tillerman,&quot;nextwaypoint&quot;)==error))
+    		PrintTextAbove(tillerman,&quot;Arr, set course first Cap'n.&quot;);
+    	else
+    	    state := STATE_FOLLOWING_COURSE;
+    		PrintTextAbove(tillerman,&quot;Aye, moving on.&quot;);
+    	endif
+  	endif
+/*END NEW MAP COURSE COMMANDS*/
+  if(text[&quot;full&quot;])
+    if(state != STATE_STATIONARY)
+      PrintTextAbove(tillerman, &quot;Aye Aye, Captain! Full speed ahead!&quot;);
+      ms_delay_between_moves := 100;
+    endif
+  elseif(text[&quot;slow&quot;])
+    if(state != STATE_STATIONARY)
+      PrintTextAbove(tillerman, &quot;Aye Aye, Captain! &quot;);
+      ms_delay_between_moves := 1000;
+    endif
+  endif
+  sleep(1);
+  if(text[&quot;one&quot;])
+    if(state != STATE_STATIONARY)
+      MoveBoatRelative(boat, relative_direction);
+      state := STATE_STATIONARY;
+    endif
+  endif
+endfunction
+
+function process_event(event)
+  if(event.type == SYSEVENT_SPEECH)
+    if(CanCommandMe(event.source))
+      var text := lower(event.text);
+      if(text[&quot;drydock&quot;])
+        PrintTextAbove(tillerman, &quot;Aye Aye, Captain! Docking.&quot;);
+        drydock(event);
+        sleep(1);
+      elseif(text[&quot;status&quot;])
+        decay := GetObjProperty(boat.tillerman, &quot;decay&quot;);
+        if((decay - ReadGameClock() ) &gt; 861000 )
+          PrintTextAbove( tillerman, &quot;Arrh, the ship's in excellent shape! She's a fine vessel indeed, Captain!&quot; );
+        elseif((decay - ReadGameClock() ) &gt; 604800 )
+          PrintTextAbove( tillerman, &quot;She's slightly worn, Captain.&quot;);
+        elseif((decay - ReadGameClock() ) &gt; 259200 )
+          PrintTextAbove(tillerman, &quot;She's fairly worn, Captain.&quot;);
+        elseif((decay - ReadGameClock() ) &gt; 86400 )
+          PrintTextAbove(tillerman, &quot;Arrr, she's greatly worn and in dire need of repair, Captain!&quot;);
+        else 
+          PrintTextAbove(tillerman, &quot;Arrr, she's going to sink within the day if she don't get repairs soon, Captain!&quot;);
+        endif
+      else
+        foreach person in (boat.mobiles)
+          if (event.source == person)
+             handle_speech(event);
+          endif  
+        endforeach
+      endif
+    endif
+  endif
+  
+endfunction
+
+function CanCommandMe(who)
+  owner := GetObjProperty(boat.tillerman, &quot;owner&quot;);
+  if(who.serial == owner)
+    return 1;
+  else
+    var packkey;
+    var lokid := GetObjProperty(boat.tillerman, &quot;lockid&quot;);
+    foreach thing in EnumerateItemsInContainer(who.backpack)
+      if(GetObjProperty(thing, &quot;lockid&quot;) == lokid)
+        packkey := 1;
+        break;
+      endif
+    endforeach
+    if(packkey == 1)
+      return 1;
+    else
+      return 0;
+    endif
+  endif
+endfunction
+
+function DoEncounter()
+  foreach who in  ListMobilesNearLocationEx(boat.x, boat.y, GetMapInfo(boat.x, boat.y, boat.realm).z, 4, LISTEX_FLAG_GHOST, boat.realm)
+    if(YesNo(who,&quot;Resurrect?&quot;))
+      if (who in boat.mobiles)
+        PlaySoundEffect(who, SFX_SPELL_RESSURECTION);
+        PlaySoundEffect(who, SFX_SPELL_RESSURECTION);
+        Resurrect(who);
+      endif
+    endif
+  endforeach
+  var who :=(boat.mobiles);
+  who := who[1];
+  if(!who)
+    return;
+  endif
+  var x;
+  var y;
+  var z;
+  x := RandomInt(15)-5;
+  y := RandomInt(15)-5;
+  x := x + boat.x;
+  y := y + boat.y;
+  if(x &gt; boat.x)
+    x := x + 5;
+  else
+    x := x - 5;
+  endif
+  if(y &gt; boat.y)
+    y := y + 5;
+  else
+    y := y - 5;
+  endif
+  z := GetMapInfo(x, y, boat.realm).z;
+  if(z &gt;= who.z)
+    return;
+  endif
+  var it := CreateNpcFromTemplate(getcritter(), x, y, z, 0, boat.realm);
+  if(it)
+    SetObjProperty(it,&quot;killme&quot;,1);
+  endif
+  var ev := {};
+  ev.+type := EVID_ENTEREDAREA;
+  ev.+source := who;
+  SendEvent(it, ev);
+endfunction
+
+function checkres()
+  foreach who in  ListMobilesNearLocationEx(boat.x, boat.y, GetMapInfo(boat.x, boat.y, boat.realm).z, 4, LISTEX_FLAG_GHOST, boat.realm)
+    if(who in boat.mobiles)
+      if(YesNo(who,&quot;Resurrect?&quot;))
+        PlaySoundEffect(who, SFX_SPELL_RESSURECTION);
+        PlaySoundEffect(who, SFX_SPELL_RESSURECTION);
+        Resurrect(who);
+      endif
+    endif
+  endforeach
+endfunction
+
+function getcritter()
+  case(RandomInt(9))
+    0: return &quot;walrus&quot;;
+    1: return &quot;walrus&quot;;
+    2: return &quot;walrus&quot;;
+    3: return &quot;walrus&quot;;
+    4: return &quot;alligator&quot;;
+    5: return &quot;alligator&quot;;
+    6: return &quot;waterelemental&quot;;
+    7: return &quot;seaserpent&quot;;
+    8: return &quot;airelemental&quot;;
+  endcase
+endfunction
+
+function drydock(event)
+  if(GetObjProperty(event.source, &quot;#DryDocking&quot;))
+    SendSysMessage(event.source, &quot;You are already doing something else.&quot;);
+    return;
+  endif
+  SetObjProperty(event.source, &quot;#DryDocking&quot;, 1);
+  EraseObjProperty(event.source, &quot;#DryDocking&quot;);
+  var text := lower(event.text);
+  if(!text[&quot;drydock&quot;])
+    EraseObjProperty(event.source, &quot;#DryDocking&quot;);
+    return;
+  endif
+  var me := event.source;
+  var items := boat.items;
+  var mobsondeck := boat.mobiles;
+
+  if(len(items) &gt; 0)
+    PrintTextAbovePrivate(boat.tillerman, &quot;Arrh, Captain!  You can't drydock the boat while items are on deck!&quot;, me);
+    EraseObjProperty(me, &quot;#DryDocking&quot;);
+    return;
+  endif
+  items := EnumerateItemsInContainer(boat.hold);
+  if(len(items) &gt; 0)
+    PrintTextAbovePrivate(boat.tillerman, &quot;Arrh, we'd best clear out the items in the hold first, Captain!&quot;, me);
+    EraseObjProperty(me, &quot;#DryDocking&quot;);
+    return;
+  endif
+  if(len(mobsondeck) &gt; 0)
+    PrintTextAbovePrivate(boat.tillerman, &quot;Arrh, Captain!  You can't drydock the boat while people are on the deck!&quot;, me);
+    EraseObjProperty(me, &quot;#DryDocking&quot;);
+    return;
+  endif  
+  if(CanDockMe(boat, me))
+    if(!YesNo(me,&quot;Drydock the ship?&quot;))
+      EraseObjProperty(me, &quot;#DryDocking&quot;);
+      return;
+    endif
+    var shiptype;
+    case(boat.objtype)
+      0x6040: shiptype := 0x6027;
+      0x6041: shiptype := 0x6028;
+      0x6042: shiptype := 0x6029;
+      0x6043: shiptype := 0x602a;
+      0x6044: shiptype := 0x602b;
+      0x6045: shiptype := 0x602c;
+    endcase
+    if(!shiptype)
+      SendSysMessage(me, &quot;Your boat seems to be malfunctioning. Please page a GM.&quot;);
+      return;
+    endif
+    var newboat := CreateItemInContainer(me.backpack, shiptype, 1);
+    var key := FindKey(me, boat.tillerman);
+    if(!newboat)
+      SendSysMessage(me,&quot;Could not create boat deed in your backpack!&quot;);
+      EraseObjProperty(me, &quot;#DryDocking&quot;);
+      return;
+    endif
+    if(ReserveItem(newboat))
+      newboat.graphic := 0x14f3;
+      if(!boat.tillerman.name)
+        newboat.name := &quot;a toy boat&quot;;
+      else
+        newboat.name := boat.tillerman.name;
+      endif
+      if(!DestroyBoat(boat))
+        DestroyItem(newboat);
+        EraseObjProperty(me, &quot;#DryDocking&quot;);
+        return;
+      endif
+    else
+      DestroyItem(newboat);
+      EraseObjProperty(me, &quot;#DryDocking&quot;);
+      return;
+    endif
+    if(key)
+      DestroyItem(key);
+    endif
+  endif
+  EraseObjProperty(me, &quot;#DryDocking&quot;);
+endfunction
+
+function DestroyBoat(who)
+  var res := DestroyMulti(boat);
+  if(!res)
+    return 0;
+  endif
+  return 1;
+endfunction
+
+function SmackEveryone()
+  foreach mob in(boat.mobiles)
+    ApplyDamage(mob,RandomInt(10));
+    PerformAction(mob,0x14);
+    PlaySoundEffect(mob,0x110);
+  endforeach
+endfunction
+
+function PlayBoatSounds()
+  var who := RandomInt(len(boat.mobiles)+1);
+  var mobs :=(boat.mobiles);
+  if(RandomInt(2) == 1)
+    PlaySoundEffect(mobs[who],0x13);
+  else
+    PlaySoundEffect(mobs[who],0x14);
+  endif
+endfunction
+
+function WorldWrap()
+  var newx := boat.x;
+  var newy := boat.y;
+  if(boat.y &lt;= 6)
+    newy := 4088;
+  elseif(boat.y &gt;= 4089)
+    newy := 6;
+  endif
+  if(boat.x &lt;= 6)
+    newx := 5096;
+  elseif(boat.x &gt;= 5097)
+    newx := 6;
+  endif
+  var lockid := GetObjProperty(boat.hold, &quot;lockid&quot;);
+  var owner := GetObjProperty(boat.hold, &quot;owner&quot;);
+  var shiptype := boat.objtype;
+  var shipfacing, created;
+  case(tillerman.graphic)
+    0x3e4e: shipfacing := CRMULTI_FACING_NORTH;
+    0x3e55: shipfacing := CRMULTI_FACING_EAST;
+    0x3e4b: shipfacing := CRMULTI_FACING_SOUTH;
+    0x3e50: shipfacing := CRMULTI_FACING_WEST;
+    default: shipfacing := &quot;Error!&quot;;
+  endcase
+  if(shipfacing == &quot;Error!&quot;)
+    syslog( &quot;[ERROR] [boat.src] Couldn't tell which way the ship was facing for the worldwrap!&quot;);
+  endif    
+  created := CreateMultiAtLocation( newx, newy, -5, shiptype, shipfacing, boat.realm);
+  if(!created)
+    syslog( &quot;[ERROR] [boat.src] New ship couldn't be created for worldwrap!&quot;);
+    return;
+  endif
+  var oldshiphold := boat.hold;
+  var newshiphold := created.hold;
+  foreach item in EnumerateItemsInContainer( oldshiphold )
+    if(item.container == oldshiphold)
+      MoveItemToContainer(item, newshiphold);
+    endif
+  endforeach
+  foreach item in EnumerateItemsInContainer( oldshiphold )
+    MoveItemToContainer(item, newshiphold);
+  endforeach
+  foreach mob in(boat.mobiles)
+    MoveCharacterToLocation(mob,(mob.x-boat.x)+created.x,(mob.y-boat.y)+created.y, -2,  MOVECHAR_FORCELOCATION );
+  endforeach
+  if(boat.has_offline_mobiles)
+    foreach mob in(boat.offline_mobiles)
+      MoveCharacterToLocation(mob,(mob.x-boat.x)+created.x,(mob.y-boat.y)+created.y, -2,  MOVECHAR_FORCELOCATION );
+    endforeach
+  endif
+  foreach mob in(boat.items)
+    MoveitemToLocation(mob,(mob.x-boat.x)+created.x,(mob.y-boat.y)+created.y, -2,0  );
+  endforeach
+  var newtillerman := created.tillerman;
+  newtillerman.name := tillerman.name;
+  SetObjProperty( created.starboardplank, &quot;lockid&quot;, lockid);
+  SetObjProperty( created.portplank, &quot;lockid&quot;, lockid);
+  SetObjProperty( created.ship.starboardplank, &quot;owner&quot;, owner );
+  SetObjProperty( created.ship.portplank, &quot;owner&quot;, owner );
+  SetObjProperty( created.ship.starboardplank, &quot;tillermanid&quot;, newtillerman.serial );
+  SetObjProperty( created.ship.portplank, &quot;tillermanid&quot;, newtillerman.serial );
+  SetObjProperty( created.hold, &quot;lockid&quot;, lockid);
+  SetObjProperty( created.hold, &quot;owner&quot;, owner);
+  SetObjProperty( created.tillerman, &quot;owner&quot;, owner);
+  SetObjProperty( created.tillerman, &quot;shipserial&quot;, created.serial);
+  SetObjProperty( created.tillerman, &quot;lockid&quot;, lockid);
+  SetObjProperty( created.tillerman, &quot;decay&quot;, decay);
+  if(boat.starboardplank.locked == 1)
+    created.starboardplank.locked := 1;
+  endif
+  if(boat.portplank.locked == 1)  
+    created.portplank.locked := 1;
+  endif
+  if(boat.hold.locked == 1)
+    created.hold.locked := 1;
+  endif
+  SetObjProperty( created.hold, &quot;#relativedir&quot;, relative_direction);
+  SetObjProperty( created.hold, &quot;#speed&quot;, ms_delay_between_moves);
+  created.tillerman.usescript := &quot;:boat:tillerman&quot;;
+  if(!DestroyMulti(boat))
+    DestroyItem(boat.tillerman);
+    syslog( &quot;[ERROR] [boat.src] Old ship at &quot; +(boat.x-1) +&quot;,&quot;+ boat.y +&quot;,&quot;+ boat.z + &quot; couldn't be destroyed during worldwrap!&quot;);
+  endif
+endfunction
+
+function CanDockMe(boat, who)
+  if(GetObjProperty(boat.hold,&quot;owner&quot;) == who.serial)
+    return 1;
+  else
+    var packkey;
+    var lokid := GetObjProperty(boat.tillerman, &quot;lockid&quot;);
+    foreach thing in EnumerateItemsInContainer(who.backpack)
+      if(GetObjProperty(thing, &quot;lockid&quot;) == lokid)
+        packkey := 1;
+        break;
+      endif
+    endforeach
+    if(packkey == 1)
+      return 1;
+    else
+      return 0;
+    endif
+  endif
+endfunction
+
+/*NEW MAP COURSE FUNCTIONS*/
+//follows the current course
+function BoatFollowCourse(boat)
+	var startx, starty, destx, desty;
+	var course, nextwaypoint;
+	var newpoint, newfacing, prevfacing;
+	
+	course := GetObjProperty(boat.tillerman,&quot;course&quot;);
+	nextwaypoint := GetObjProperty(boat.tillerman,&quot;nextwaypoint&quot;);
+	startx := boat.x;
+	starty := boat.y;
+	prevfacing := boat.facing;
+	
+	if( (course==error) || (nextwaypoint==error))
+		return;
+	endif
+	
+	destx := course[nextwaypoint].x;
+	desty := course[nextwaypoint].y;
+	
+	newpoint := lineBresenham(startx,starty,destx,desty);
+	newfacing := GetNewFacing(startx,starty,newpoint[1],newpoint[2]);
+
+	if(newfacing == error) //reached waypoint/end
+		nextwaypoint := nextwaypoint + 1;
+		first_move_toward_waypoint := 1; //so we turn toward next waypoint (includes next course follow if we're done with this one)
+		if(nextwaypoint &gt; course.size()) //done
+			state := STATE_DRIFTING;
+			PrintTextAbove(boat.tillerman,&quot;Arr, we've reached our destination.&quot;);
+			return;
+		else
+			SetObjProperty(boat.tillerman,&quot;nextwaypoint&quot;,nextwaypoint);
+		endif
+		
+	else
+
+		if(first_move_toward_waypoint == 1)
+			if( prevfacing != newfacing )
+				TurnBoat(boat,Cint(DetermineTurnCode(boat,newfacing)) );
+			endif
+			first_move_toward_waypoint := 0;
+		endif
+		MoveBoat(boat,newfacing);
+		
+		if((startx == boat.x) &amp;&amp;(starty == boat.y)) //we didn't move. must be blocked
+    		state := STATE_DRIFTING;
+    		PrintTextAbove(tillerman, &quot;Aaargh!  We've stopped!&quot;);
+  		endif
+  	endif
+	
+endfunction
+
+//convert facing 0-7 to turn code 0-3
+function DetermineTurnCode( boat, desired )
+
+    var current := CInt(boat.facing / 2);
+    desired := CInt(desired / 2);
+
+	
+    if ( desired &lt; current ) 
+    	desired := desired + 4; 
+    endif
+    return (desired - current);
+endfunction
+	
+//returns the direction (x1,y1) lies from (x0,y0) in the range 0-7.
+// returns error if the 2 points are equal.
+function GetNewFacing(x0,y0,x1,y1)
+	var dx, dy;
+	var facing;
+	dx := x1 - x0;
+	dy := y1 - y0;
+	
+	case(dx)
+		NEGONE: 
+			case(dy)
+				 NEGONE: facing := 7;
+				 ZERO: facing := 6;
+				 POSONE: facing := 5;
+				 default: facing := error;
+			endcase
+		 ZERO:
+		 	case(dy)
+		 		 NEGONE: facing := 0;
+		 		 ZERO: facing := error;
+		 		 POSONE: facing := 4;
+		 		 default: facing := error;
+		    endcase
+		 POSONE:
+		 	case(dy)
+		 		 NEGONE: facing := 1;
+		 		 ZERO: facing := 2;
+		 		 POSONE: facing := 3;
+		 		 default: facing := error;
+		 	endcase
+		 default: facing := error;
+	endcase
+	
+	return facing;
+endfunction
+
+//Bresenham's line drawing algorithm. determines a line between two waypoints.
+function lineBresenham(x0, y0, x1, y1)
+    var dy;
+    dy := y1 - y0;
+    var dx;
+    dx := x1 - x0;
+    var stepx, stepy;
+
+    if (dy &lt; 0)
+      	dy := -dy;  
+       	stepy := -1;
+    else
+      	stepy := 1;
+    endif
+        
+    if (dx &lt; 0) 
+       	dx := -dx;
+       	stepx := -1;
+    else 
+      	stepx := 1;
+    endif
+        
+    dy := 2*dy;   
+    dx := 2*dx;    
+
+    if (dx &gt; dy)
+        var fraction;
+        fraction := 2*dy - dx;
+        while (x0 != x1)
+        	if (fraction &gt;= 0)
+            	y0 := y0 + stepy;
+                fraction := fraction - dx;
+           	endif
+            x0 := x0 + stepx;
+            fraction := fraction + dy;
+            return {x0, y0};
+        endwhile
+    else
+        var fraction;
+        fraction := 2*dx - dy;
+        while (y0 != y1)
+            if (fraction &gt;= 0)
+                x0 := x0 + stepx;
+                fraction := fraction - dy;
+            endif
+            y0 := y0 + stepy;
+            fraction := fraction + dx;
+            return {x0, y0};
+        endwhile
+    endif
+endfunction
+/*END NEW MAP COURSE FUNCTIONS*/

Added: trunk/096/pkg/multis/boat/OLD/itemdesc.cfg
===================================================================
--- trunk/096/pkg/multis/boat/OLD/itemdesc.cfg	2005-12-29 09:18:56 UTC (rev 1085)
+++ trunk/096/pkg/multis/boat/OLD/itemdesc.cfg	2006-01-05 11:23:07 UTC (rev 1086)
@@ -0,0 +1,168 @@
+Item 0x6027
+{
+    Name                smallboatdeed
+    Desc                deed to a small boat
+    Graphic             0x14F2
+    Script              shipDeed
+    ShipObjType         smallboat
+    VendorSellsFor      12500
+    VendorBuysFor       12500
+	newbie              1
+}
+Item 0x6028
+{
+    Name                smalldragonboatdeed
+    Desc                deed to a small dragon boat
+    Graphic             0x14F2
+    Script              shipDeed
+    ShipObjType         smalldragonboat
+    VendorSellsFor      12500
+    VendorBuysFor       12500
+	newbie              1
+}
+
+
+Item 0x6029
+{
+    Name                mediumboatdeed
+    Desc                deed to a medium boat
+    Graphic             0x14F2
+    Script              shipDeed
+    ShipObjType         mediumboat
+    VendorSellsFor      14200
+    VendorBuysFor       14200
+	newbie              1
+}
+Item 0x602A
+{
+    Name                mediumdragonboatdeed
+    Desc                deed to a medium dragon boat
+    Graphic             0x14F2
+    Script              shipDeed
+    ShipObjType         mediumdragonboat
+    VendorSellsFor      14200
+    VendorBuysFor       14200
+	newbie              1
+}
+
+
+Item 0x602B
+{
+    Name                largeboatdeed
+    Desc                deed to a large boat
+    Graphic             0x14F2
+    Script              shipDeed
+    ShipObjType         largeboat
+    VendorSellsFor      15900
+    VendorBuysFor       15900
+	newbie              1
+}
+
+Item 0x602C
+{
+    Name                largedragonboatdeed
+	Desc                deed to a large dragon boat
+    Graphic             0x14F2
+    Script              shipDeed
+    ShipObjType         largedragonboat
+    VendorSellsFor      15900
+    VendorBuysFor       15900
+	newbie              1
+}
+
+Boat 0x6040
+{
+    Name                smallboat
+    Graphic             0x4000
+    MultiID             0x0000
+    OldObjtype          0x4000
+    OldObjtype          0x4001
+    OldObjtype          0x4002
+    OldObjtype          0x4003
+}
+
+Boat 0x6041
+{
+    Name                smalldragonboat
+    Graphic             0x4004
+    MultiID             0x0004
+    OldObjtype          0x4004
+    OldObjtype          0x4005
+    OldObjtype          0x4006
+    OldObjtype          0x4007
+}
+
+Boat 0x6042
+{
+    Name                mediumboat
+    Graphic             0x4008
+    MultiID             0x0008
+    OldObjtype          0x4008
+    OldObjtype          0x4009
+    OldObjtype          0x400A
+    OldObjtype          0x400B
+}
+
+Boat 0x6043
+{
+    Name                mediumdragonboat
+    Graphic             0x400C
+    MultiID             0x000C
+    OldObjtype          0x400C
+    OldObjtype          0x400D
+    OldObjtype          0x400E
+    OldObjtype          0x400F
+}
+
+Boat 0x6044
+{
+    Name                largeboat
+    Graphic             0x4010
+    MultiID             0x0010
+    OldObjtype          0x4010
+    OldObjtype          0x4011
+    OldObjtype          0x4012
+    OldObjtype          0x4013
+}
+
+Boat 0x6045
+{
+    Name                largedragonboat
+    Graphic             0x4014
+    MultiID             0x0014
+    OldObjtype          0x4014
+    OldObjtype          0x4015
+    OldObjtype          0x4016
+    OldObjtype          0x4017
+}
+
+Item 0xF010
+{
+    Name                Tillerman
+    graphic             1
+	script              tillerman
+}
+
+Item 0xF011
+{
+    Name                gangplank
+    Graphic             1
+    Lockable            1
+    RequiresAttention   0
+    DoubleclickRange    20
+    Script              plank
+    WalkOnScript        plankWalk
+    ControlScript       plankControl
+}
+
+Item 0xF012
+{
+    Name                gangplank2
+    Graphic             1
+    Lockable            1
+    RequiresAttention   0
+    DoubleclickRange    20
+    Script              plank
+    WalkOnScript        plankWalk
+    ControlScript       plankControl
+}

Added: trunk/096/pkg/multis/boat/OLD/pkg.cfg
===================================================================
--- trunk/096/pkg/multis/boat/OLD/pkg.cfg	2005-12-29 09:18:56 UTC (rev 1085)
+++ trunk/096/pkg/multis/boat/OLD/pkg.cfg	2006-01-05 11:23:07 UTC (rev 1086)
@@ -0,0 +1,9 @@
+# $Id: pkg.cfg 684 2005-10-27 18:48:28Z muaddiblsd $
+#
+#
+Enabled		0
+Name		boat
+Maintainer	Distro Team
+Email		<A HREF="https://lists.berlios.de/mailman/listinfo/poldistro-svn">distro at polserver.com</A>
+Version		1.0
+

Added: trunk/096/pkg/multis/boat/OLD/plank.src
===================================================================
--- trunk/096/pkg/multis/boat/OLD/plank.src	2005-12-29 09:18:56 UTC (rev 1085)
+++ trunk/096/pkg/multis/boat/OLD/plank.src	2006-01-05 11:23:07 UTC (rev 1086)
@@ -0,0 +1,92 @@
+use os;
+use uo;
+
+include &quot;util/key&quot;;
+include &quot;:itemutils:objtype&quot;;
+include &quot;plankUtil&quot;;
+
+program useplank(mob, plank)
+  set_critical(1);
+
+// Refresh the boat if he's the owner.
+var owner := GetObjProperty(plank, &quot;owner&quot;);
+if (mob.serial == owner)
+  var tillermanid := GetObjProperty(plank, &quot;tillermanid&quot;);
+  var tillerman := SystemFindObjectBySerial( tillermanid );
+  if (tillerman)
+    var decay := GetObjProperty(tillerman, &quot;decay&quot;);
+    // Only give him the refresh message if the ship was less than 'in excellent shape'
+    // so he doesn't get the message every time he gets on and off the ship.
+    if ( (decay - ReadGameClock() ) &lt; 860000 )
+          SendSysMessage(mob, &quot;Your ship has been refreshed.&quot;);
+    endif
+    SetObjProperty( tillerman, 	  &quot;decay&quot;,      (ReadGameClock()+ 864000));
+  endif
+endif
+  if(mob.multi.serial == plank.multi.serial)
+	TimedOpenClose(plank);
+  elseif((FK(mob, plank) == 1) ||(!plank.locked))
+	if(!IsExtended(plank))
+	  TimedOpenClose(plank);
+	else
+	  YankOntoBoat(mob,plank);
+	endif
+  else
+	PrintTextAbovePrivate(plank, &quot;That is locked.&quot;, mob);
+  endif
+endprogram
+
+function TimedOpenClose(plank)
+  if(IsExtended(plank))
+    if(!IsPlankOccupied(plank))
+      Retract(plank);
+      EraseObjProperty(plank, &quot;#WhenOpened&quot;);
+    endif
+  else
+    var whenopened := ReadGameClock();
+    SetObjProperty(plank, &quot;#WhenOpened&quot;, whenopened);
+    Extend(plank);
+    repeat
+    sleep(6);
+    until(!(plank &amp;&amp; IsPlankOccupied(plank)));
+    if(GetObjProperty(plank, &quot;#WhenOpened&quot;) == whenopened)
+      Retract(plank);
+      EraseObjProperty(plank, &quot;#WhenOpened&quot;);
+    endif
+  endif
+endfunction
+
+function YankOntoBoat(mob, plank)
+  var sh := GetStandingHeight(plank.x, plank.y, plank.z, plank.realm);
+  if(sh)
+    var nx :=(plank.x + plank.multi.x) / 2;
+    var ny :=(plank.y + plank.multi.y) / 2;
+    MoveCharacterToLocation(mob, nx, ny, plank.z);
+    return;
+  endif
+endfunction
+
+function CanWalkOntoPlank(plank)
+  var dx;
+  var dy;
+  case(plank.graphic)
+    GID_PLANK_EXTENDED_FACING_WEST:
+    GID_PLANK_RETRACTED_FACING_WEST:    dx := -1;
+                                        dy := 0;
+    GID_PLANK_EXTENDED_FACING_EAST:
+    GID_PLANK_RETRACTED_FACING_EAST:    dx := 1;
+                                        dy := 0;
+
+    GID_PLANK_EXTENDED_FACING_NORTH:
+    GID_PLANK_RETRACTED_FACING_NORTH:   dx := 0;
+                                        dy := -1;
+    GID_PLANK_EXTENDED_FACING_SOUTH:
+    GID_PLANK_RETRACTED_FACING_SOUTH:   dx := 0;
+                                        dy := 1;
+  endcase
+  if(GetStandingHeight(plank.x + dx, plank.y + dy, plank.z, plank.realm))
+    return 1;
+  else
+     return 0;
+  endif
+endfunction

Added: trunk/096/pkg/multis/boat/OLD/plankControl.src
===================================================================
--- trunk/096/pkg/multis/boat/OLD/plankControl.src	2005-12-29 09:18:56 UTC (rev 1085)
+++ trunk/096/pkg/multis/boat/OLD/plankControl.src	2006-01-05 11:23:07 UTC (rev 1086)
@@ -0,0 +1,20 @@
+/*
+ * plankcontrol - plank control script
+ *
+ * sole job is to close an open locked plank on startup.
+ *
+ */
+
+use os;
+use uo;
+
+include &quot;:itemutils:objtype&quot;;
+include &quot;plankUtil&quot;;
+
+set_debug(1);
+
+program plankcontrol( plank )
+    if (plank.locked &amp;&amp; IsExtended(plank))
+        Retract( plank );
+    endif
+endprogram

Added: trunk/096/pkg/multis/boat/OLD/plankUtil.inc
===================================================================
--- trunk/096/pkg/multis/boat/OLD/plankUtil.inc	2005-12-29 09:18:56 UTC (rev 1085)
+++ trunk/096/pkg/multis/boat/OLD/plankUtil.inc	2006-01-05 11:23:07 UTC (rev 1086)
@@ -0,0 +1,89 @@
+include &quot;:itemutils:objtype&quot;;
+
+const KEYSTART := 0x100e;
+const KEYEND := 0x1013;
+const KEYRING := 0x1011;
+
+function IsExtended( plank )
+  return plank.graphic in { GID_PLANK_EXTENDED_FACING_EAST, GID_PLANK_EXTENDED_FACING_WEST, GID_PLANK_EXTENDED_FACING_NORTH, GID_PLANK_EXTENDED_FACING_SOUTH };
+endfunction
+
+function IsPlankOccupied( plank )
+  return ListMobilesNearLocation( plank.x, plank.y, plank.z, 0, plank.realm ).size();
+endfunction
+
+function Extend( plank )
+  if (!IsExtended(plank))
+    TogglePlank(plank);
+  endif
+endfunction
+
+function Retract( plank )
+  if (IsExtended(plank))
+    TogglePlank(plank);
+  endif
+endfunction
+
+function TogglePlank( plank )
+  var partnertype := PlankPartner( plank.graphic );
+  if (partnertype)
+    plank.graphic := partnertype;
+  endif
+endfunction
+
+function PlankPartner( planktype )
+  case (planktype)
+    GID_PLANK_EXTENDED_FACING_EAST:  return GID_PLANK_RETRACTED_FACING_EAST;   // 0x3ed5: return 0x3eb1;
+    GID_PLANK_RETRACTED_FACING_EAST: return GID_PLANK_EXTENDED_FACING_EAST;    // 0x3eb1: return 0x3ed5;
+    GID_PLANK_EXTENDED_FACING_WEST:  return GID_PLANK_RETRACTED_FACING_WEST;   // 0x3ed4: return 0x3eb2;
+    GID_PLANK_RETRACTED_FACING_WEST: return GID_PLANK_EXTENDED_FACING_WEST;    // 0x3eb2: return 0x3ed4;
+    GID_PLANK_EXTENDED_FACING_NORTH:  return GID_PLANK_RETRACTED_FACING_NORTH; // 0x3e84: return 0x3e85;
+    GID_PLANK_RETRACTED_FACING_NORTH: return GID_PLANK_EXTENDED_FACING_NORTH;  // 0x3e85: return 0x3e84;
+    GID_PLANK_EXTENDED_FACING_SOUTH:  return GID_PLANK_RETRACTED_FACING_SOUTH; // 0x3e89: return 0x3e8a;
+    GID_PLANK_RETRACTED_FACING_SOUTH: return GID_PLANK_EXTENDED_FACING_SOUTH;  // 0x3e8a: return 0x3e89;
+    default: syslog( &quot;Unknown plank type 0x&quot; + Hex( planktype ) );
+             return error;
+  endcase
+endfunction
+
+function fk(me, plank)
+  var doorlockid := GetObjProperty( plank, &quot;lockid&quot; );
+  var keylockid;
+  var insidering;
+  var mykeys := EnumerateItemsInContainer(me.backpack);
+  foreach key in mykeys
+	if ( (key.objtype &gt;= KEYSTART ) &amp;&amp; (key.objtype &lt;= KEYEND) &amp;&amp; (key.objtype != KEYRING ) )
+	  keylockid := GetObjProperty( key, &quot;lockid&quot; );
+	  if ( (keylockid) &amp;&amp; (keylockid == doorlockid) )
+		return 1;
+	  endif
+	elseif (key.objtype == KEYRING)
+	  insidering := FindMyPack(key.serial);
+	  foreach otherkey in EnumerateItemsInContainer(insidering)
+		keylockid := GetObjProperty( otherkey, &quot;lockid&quot; );
+		if (keylockid == doorlockid)
+		  return 1;
+		endif
+	  endforeach
+	endif
+  endforeach
+  return 0;
+endfunction
+
+function OpenTamedStorageAreas()
+  var bank := FindStorageArea( &quot;Tamed Storage&quot; );
+  if (!bank)
+    bank := CreateStorageArea( &quot;Tamed Storage&quot; );
+  endif
+  return bank;
+endfunction
+
+function FindMyPack(myserial)
+  var mybank := OpenTamedStorageAreas();
+  var bank_obj_name := &quot;Bankbox  &quot; + Hex(myserial);
+  var bankbox := FindRootItemInStorageArea( mybank, bank_obj_name );
+  if (!bankbox)
+    bankbox := CreateRootItemInStorageArea(mybank, bank_obj_name, UOBJ_BANKBOX  );
+  endif
+  return bankbox;
+endfunction
\ No newline at end of file

Added: trunk/096/pkg/multis/boat/OLD/plankWalk.src
===================================================================
--- trunk/096/pkg/multis/boat/OLD/plankWalk.src	2005-12-29 09:18:56 UTC (rev 1085)
+++ trunk/096/pkg/multis/boat/OLD/plankWalk.src	2006-01-05 11:23:07 UTC (rev 1086)
@@ -0,0 +1,158 @@
+use os;
+use uo;
+
+include &quot;include/client&quot;;
+include &quot;:itemutils:objtype&quot;;
+include &quot;util/key&quot;;
+include &quot;plankUtil&quot;;
+
+/*
+ * the searchoffset matrix is for an east-facing plank.
+ * these will have to be rotated for the other positions
+ *   P is the plank, N is where you can't step (otherwise
+ *    this teleportation stuff wouldn't be necessary)
+ *
+ *        13 12 11
+ *        14  5  4
+ *        15  6  2
+ *        16  7  1 N P
+ *        17  8  3
+ *        18  9 10
+ *        19 20 21
+ *
+ */
+
+var searchoffset := {
+   { -2,  0 },          //  1
+   { -2, -1 },
+   { -2, +1 },
+   { -2, -2 },
+   { -3, -2 },          //  5
+   { -3, -1 },
+   { -3,  0 },
+   { -3, +1 },
+   { -3, +2 },
+   { -2, +2 },          // 10
+   { -2, -3 },
+   { -3, -3 },
+   { -4, -3 },
+   { -4, -2 },
+   { -4, -1 },          // 15
+   { -4,  0 },
+   { -4, +1 },
+   { -4, +2 },
+   { -4, +3 },
+   { -3, +3 },          // 20
+   { -2, +3 },
+   { -5,  0 },
+   { -5, +2 },
+   { -5, +3 },
+   { -5, +4 },
+   { -4, +4 },          // 20
+   { -3, +4 },
+   { -6,  0 },
+   { -6, +3 },
+   { -6, +4 },
+   { -6, +5 },
+   { -5, +5 },          // 20
+   { -4, +5 }
+};
+
+program plankwalk( who, plank, lastx, lasty, lastz )
+    if (!FindKey( who, plank ))
+        if (plank.locked)
+            var sh := GetStandingHeight( lastx, lasty, lastz, who.realm );
+            if (!sh || !sh.multi || sh.multi.serial != plank.multi.serial)
+                MoveCharacterToLocation( who, lastx, lasty, lastz, MOVECHAR_FORCELOCATION );
+                return;
+            endif
+        endif
+    endif
+
+    if (ListMobilesNearLocation( plank.x, plank.y, plank.z, 0, plank.realm ).size() &gt; 1)
+        MoveCharacterToLocation( who, lastx, lasty, lastz, MOVECHAR_FORCELOCATION );
+        return;
+    endif
+
+    var xidx, yidx, xmul, ymul;
+
+    case (plank.graphic)
+        GID_PLANK_EXTENDED_FACING_WEST:
+            if (! (who.facing in { DIR_W, DIR_NW, DIR_SW }))
+                return;
+            endif
+            xidx := 1;
+            yidx := 2;
+            xmul := 1;
+            ymul := 1;
+
+        GID_PLANK_EXTENDED_FACING_EAST:
+            if (! (who.facing in { DIR_E, DIR_NE, DIR_SE }))
+                return;
+            endif
+            xidx := 1;
+            yidx := 2;
+            xmul := -1; // flip across x-axis
+            ymul := 1;
+
+        GID_PLANK_EXTENDED_FACING_NORTH:
+            if (! (who.facing in { DIR_N, DIR_NE, DIR_NW }))
+                return;
+            endif
+            xidx := 2;
+            yidx := 1;
+            xmul := 1;
+            ymul := +1;
+
+        GID_PLANK_EXTENDED_FACING_SOUTH:
+            if (! (who.facing in { DIR_S, DIR_SE, DIR_SW }))
+                return;
+            endif
+            xidx := 2;
+            yidx := 1;
+            xmul := 1;
+            ymul := -1; // flip across y-axis
+
+        default:
+            return;
+    endcase
+    if (CanMove( who,
+                 searchoffset[1][xidx] * xmul / 2,
+                 searchoffset[1][yidx] * ymul / 2 ))
+        return;                     // doesn't need our help!
+    endif
+
+
+    foreach offset in searchoffset
+        if (TryMove( who, offset[xidx] * xmul, offset[yidx] * ymul ))
+            return;
+        endif
+    endforeach
+endprogram
+
+function TryMove( who, dx, dy )
+    var res := 0;
+    set_critical( 1 );
+
+    var tryx := who.x + dx;
+    var tryy := who.y + dy;
+    var h := GetStandingHeight( tryx, tryy, who.z, who.realm );
+    if (h &amp;&amp; (not h.multi)) // CHECKME should check line of sight?
+        MoveCharacterToLocation( who, tryx, tryy, h.z );
+        res := 1;
+    endif
+
+    set_critical(0);
+    return res;
+endfunction
+
+function CanMove( who, dx, dy )
+    var tryx := who.x + dx;
+    var tryy := who.y + dy;
+    var h := GetStandingHeight( tryx, tryy, who.z, who.realm );
+    if (h)
+        return 1;
+    else
+        return 0;
+    endif
+endfunction
\ No newline at end of file

Added: trunk/096/pkg/multis/boat/OLD/shipDeed.src
===================================================================
--- trunk/096/pkg/multis/boat/OLD/shipDeed.src	2005-12-29 09:18:56 UTC (rev 1085)
+++ trunk/096/pkg/multis/boat/OLD/shipDeed.src	2006-01-05 11:23:07 UTC (rev 1086)
@@ -0,0 +1,128 @@
+// $Id: shipDeed.src 905 2005-11-05 08:20:50Z muaddiblsd $
+
+use cfgfile;
+use uo;
+use os;
+
+include &quot;util/key&quot;;
+include &quot;:itemutils:objtype&quot;;
+include &quot;:itemutils:canAccess&quot;;
+
+program useshipdeed(who, deed)
+  if(DeedAlreadyBuiltFrom(deed))
+    PrintTextAbovePrivate(deed, &quot;That ship has already been built.&quot;, who);
+  elseif(can_access(who, deed))
+    BuildShip(who, deed);
+  endif
+endprogram
+
+function BuildShip(who, deed)
+  var shiptype := GetShipObjtype(deed.objtype);
+  if(!shiptype)
+    PrintTextAbovePrivate(deed, &quot;That ship deed appears to be broken.&quot;, who);
+    return;
+  endif
+  var flags := ShipFacingFlags(who.facing);
+  var where := TargetMultiPlacement(who, shiptype, flags);
+  if(!where)
+    if(deed.graphic == 5363)
+      deed.graphic := 5364;
+    elseif(deed.graphic == 5364)
+      deed.graphic := 5363;
+    endif
+    return;
+  elseif((where.x == deed.x) &amp;&amp; (where.y == deed.y))
+    if(deed.graphic == 5363)
+      deed.graphic := 5364;
+    elseif(deed.graphic == 5364)
+      deed.graphic := 5363;
+    endif
+    return;
+  endif
+  set_critical(1);
+  if((where.x &lt; who.x - 10) || (where.y &lt; who.y - 10) || (where.x &gt; who.x + 10) || (where.y &gt; who.y + 10))
+    SendSysMessage(who, &quot;You cannot place a boat that far away.&quot;);
+    return;
+  endif
+  var created := CreateShipKeysAndBuiltDeed(who, shiptype, where.x, where.y, where.z, flags);
+  if(created)
+    var ship := created.ship;
+    var deedtype := deed.objtype;
+    if((deed.name != &quot;a toy boat&quot;) &amp;&amp; (!deed.name[&quot;deed&quot;]))
+      ship.tillerman.name := deed.name;
+    endif
+    if(DestroyItem(deed))
+      ship.starboardplank.locked    := 1;
+      ship.portplank.locked         := 1;
+      ship.hold.locked              := 1;
+      var lockid := AllocLockId();
+      SetObjProperty(ship.starboardplank, &quot;lockid&quot;,      lockid);
+      SetObjProperty(ship.starboardplank, &quot;owner&quot;,       who.serial);
+      SetObjProperty(ship.starboardplank, &quot;tillermanid&quot;, ship.tillerman.serial);
+      SetObjProperty(ship.portplank,      &quot;lockid&quot;,      lockid);
+      SetObjProperty(ship.portplank,      &quot;owner&quot;,       who.serial);
+      SetObjProperty(ship.portplank,      &quot;tillermanid&quot;, ship.tillerman.serial);
+      SetObjProperty(ship.hold,           &quot;lockid&quot;,      lockid);
+      SetObjProperty(ship.tillerman,      &quot;owner&quot;,       who.serial);
+      SetObjProperty(ship.tillerman,      &quot;shipserial&quot;,  ship.serial);
+      SetObjProperty(ship.tillerman,      &quot;lockid&quot;,      lockid);
+      SetObjProperty(ship.tillerman,      &quot;shiptype&quot;,    deedtype);
+      SetObjProperty(created.packkey,     &quot;lockid&quot;,      lockid);
+      SetObjProperty(created.packkey,     &quot;shipserial&quot;,  ship.serial);
+      SetObjProperty(ship.tillerman,      &quot;decay&quot;,       (ReadGameClock()+ 864000));
+      ship.tillerman.usescript := &quot;:boat:tillerman&quot;;
+    else
+      DestroyItem(created.packkey);
+      DestroyMulti(ship);
+      SendSysMessage(who, &quot;There was an error creating the boat.&quot;);
+    endif
+  endif
+endfunction
+
+function ShipFacingFlags(facing)
+  var flags := 0;
+  case (facing)
+    DIR_N:  flags := CRMULTI_FACING_NORTH;
+    DIR_NE: flags := CRMULTI_FACING_NORTH;
+    DIR_E:  flags := CRMULTI_FACING_EAST;
+    DIR_SE: flags := CRMULTI_FACING_SOUTH;
+    DIR_S:  flags := CRMULTI_FACING_SOUTH;
+    DIR_SW: flags := CRMULTI_FACING_SOUTH;
+    DIR_W:  flags := CRMULTI_FACING_WEST;
+    DIR_NW: flags := CRMULTI_FACING_NORTH;
+  endcase
+  return flags;
+endfunction
+
+function CreateShipKeysAndBuiltDeed(who, shiptype, x, y, z, flags)
+  var packkey := CreateItemInBackpack(who, UOBJ_COPPER_KEY);
+  if(!packkey)
+    PrintTextAbovePrivate(who, &quot;My backpack is too full!&quot;, who);
+    return 0;
+  endif
+  var ship := CreateMultiAtLocation(x, y, z, shiptype, flags, who.realm);
+  if(!ship)
+    PrintTextAbovePrivate(who, &quot;I can't place the ship there.&quot;, who);
+    DestroyItem(packkey);
+    return 0;
+  else
+    var result := struct;
+    result.+packkey := packkey;
+    result.+ship    := ship;
+    return result;
+  endif
+endfunction
+
+function DeedAlreadyBuiltFrom(deed)
+  if(GetObjProperty(deed, &quot;builtserial&quot;))
+    return 1;
+  else
+    return 0;
+  endif
+endfunction
+
+function GetShipObjtype(objtype)
+    var cfg := ReadConfigFile(&quot;:boat:itemdesc&quot;);
+    var ot := GetObjtypeByName(cfg[objtype].ShipObjType);
+    return Cint(ot);
+endfunction
\ No newline at end of file

Added: trunk/096/pkg/multis/boat/OLD/tillerman.src
===================================================================
--- trunk/096/pkg/multis/boat/OLD/tillerman.src	2005-12-29 09:18:56 UTC (rev 1085)
+++ trunk/096/pkg/multis/boat/OLD/tillerman.src	2006-01-05 11:23:07 UTC (rev 1086)
@@ -0,0 +1,22 @@
+use os;
+use uo;
+
+include &quot;util/key&quot;;
+include &quot;:itemutils:objtype&quot;;
+include &quot;plankUtil&quot;;
+
+program renameboat(you, tillerman)
+  if((GetObjProperty(tillerman,&quot;owner&quot;) != you.serial) &amp;&amp;(you.cmdlevel &lt; 2))
+	PrintTextAbove(tillerman,&quot;Stop that, or I'll throw ye overboard!&quot;);
+	return;
+  endif
+    var boatname := RequestInput(you, tillerman, &quot;Enter a new name for this boat.(max 40 characters)&quot;);
+  if(boatname)
+	if(len(boatname) &lt;= 40)
+	  tillerman.name := boatname;
+	  SendSysMessage(you, &quot;Boat is renamed.&quot;);
+	else
+	  SendSysMessage(you, &quot;Too many characters in name.&quot;);
+	endif
+  endif
+endprogram
\ No newline at end of file

Deleted: trunk/096/pkg/multis/boat/boat.src
===================================================================
--- trunk/096/pkg/multis/boat/boat.src	2005-12-29 09:18:56 UTC (rev 1085)
+++ trunk/096/pkg/multis/boat/boat.src	2006-01-05 11:23:07 UTC (rev 1086)
@@ -1,790 +0,0 @@
-////////////////
-//	boat.src 
-//
-//	control script for boats
-//
-//	Header replaced by Racalac 9/15/02
-//
-//	Todo/Fix: Course nav needs the &quot;goto #&quot; command implimented.
-//			  Tillerman string recognition causes boat to pause
-////////////////
-
-use os;
-use uo;
-use util;
-use boat;
-
-include &quot;include/OLD/eventID&quot;;
-include &quot;include/sysEvent&quot;;
-include &quot;:itemutils:myUtil&quot;;
-include &quot;include/client&quot;;
-include &quot;include/OLD/sound&quot;;
-include &quot;:gumps:yesno&quot;;
-include &quot;util/key&quot;;
-include &quot;plankUtil&quot;;
-
-const STATE_STATIONARY := 0;
-const STATE_MOVING := 1;
-const STATE_DRIFTING := 2;
-const STATE_FOLLOWING_COURSE := 3; //NOTE NEW STATE
-const DELAY_DRIFTING := 15000;
-
-/*NOTE NEW CONSTANTS*/
-const NEGONE := -1;
-const ZERO := 0;
-const POSONE := 1;
-
-var state := STATE_STATIONARY;
-var relative_direction;
-var ms_delay_between_moves := 200;
-var boat;
-var tillerman;
-var owner := GetObjProperty(boat.hold,&quot;owner&quot;);
-var decay := GetObjProperty(boat.tillerman, &quot;decay&quot;);
-
-/*NOTE NEW GLOBAL*/
-var first_move_toward_waypoint := 1;
-
-program autostart_boat(param)
-  boat := param;
-  if(!boat)
-    syslog( &quot;[ERROR] [boat.src] Boat script running, but boat not found!&quot; );
-    return;
-  endif
-  tillerman := boat.tillerman;
-  if(!tillerman)
-    syslog( &quot;[ERROR] [boat.src] No tillerman for boat at: &quot; +(boat.x-1) +&quot;,&quot;+ boat.y +&quot;,&quot;+ boat.z + &quot;; destroying the boat...&quot; );
-    DestroyMulti(boat);
-    return;
-  endif
-  EnableEvents(SYSEVENT_SPEECH, 15);
-  RegisterForSpeechEvents(tillerman, 15);
-  var nextencounter := ReadGameClock()+(RandomInt(120) + 120);
-  var nextsound := ReadGameClock()+5;
-  var driftcounter := 1;
-  //set_critical(1);
-  var x,y;
-  while(boat)
-    if(GetObjProperty(boat.hold, &quot;#speed&quot;))
-      state := STATE_MOVING;
-      ms_delay_between_moves := GetObjProperty(boat.hold, &quot;#speed&quot;); 
-      relative_direction := GetObjProperty(boat.hold, &quot;#relativedir&quot;);
-      eraseobjproperty(boat.hold, &quot;#speed&quot;);
-      eraseobjproperty(boat.hold, &quot;#relativedir&quot;);    
-    endif     
-    decay := getobjproperty(boat.tillerman,&quot;decay&quot;);
-    if((decay) and(!getobjproperty(tillerman,&quot;nodecay&quot;)))
-      if(ReadGameClock() &gt; decay)
-        PrintTextAbove(tillerman, &quot;Arrrrrgh!  She's going down, Captain!  Abandon ship!&quot;);
-        sleep(4);
-        foreach item in EnumerateItemsInContainer( boat.hold )
-          DestroyItem(item);
-        endforeach
-        foreach mob in(boat.items)
-          DestroyItem(mob);
-        endforeach        
-        foreach mob in(boat.mobiles)
-          MoveCharacterToLocation(mob, 1, 1, 0,  MOVECHAR_FORCELOCATION );
-          SendSysMessage(mob, &quot;Your ship, badly in need of maintenance, sinks beneath the waves!&quot;);
-          SendSysMessage(mob, &quot;You awake on a distant shore...&quot;);
-        endforeach
-        if(boat.has_offline_mobiles)
-          foreach mob in(boat.offline_mobiles)
-            MoveCharacterToLocation(mob, 1, 1, 0,  MOVECHAR_FORCELOCATION );
-          endforeach
-        endif
-        DestroyMulti(boat);
-      endif
-    endif    
-    case(state)
-      STATE_MOVING:   if(ReadGameClock() &gt; nextsound)
-                        PlayBoatSounds();
-                        nextsound := ReadGameClock()+5;
-                      endif
-                      x := boat.x;
-                      y := boat.y;
-                      MoveBoatRelative(boat, relative_direction);
-                      if(boat.x == 6 or boat.x == 5097 or boat.y == 6 or boat.y == 4089)   
-                        WorldWrap();
-                      endif
-                      if((x == boat.x) &amp;&amp;(y == boat.y))
-                        ms_delay_between_moves := 1000;
-                        state := STATE_DRIFTING;
-                        PrintTextAbove(tillerman, &quot;Aaargh!  We've run ashore!&quot;);
-                        //SmackEveryone();
-                      endif
-                      sleepms(ms_delay_between_moves);
-                      if(ReadGameClock() &gt; nextencounter)
-                        DoEncounter();
-                        nextencounter := ReadGameClock()+120;
-                      endif
-                      while(events_waiting())
-                        process_event(wait_for_event(0));
-                      endwhile
-      STATE_DRIFTING:   if(ReadGameClock() &gt; nextsound)
-                          PlayBoatSounds();
-                          nextsound := ReadGameClock()+5;
-                        endif
-                        if(driftcounter &gt; 15)
-                          MoveBoatRelative(boat, RandomInt(8));
-                          driftcounter := 1;
-                        else
-                          driftcounter := driftcounter + 1;
-                        endif
-                        sleepms(1000);
-                        while(events_waiting())
-                          process_event(wait_for_event(0));
-                        endwhile
-      STATE_STATIONARY: var ev := wait_for_event(120);
-                        if(ev)
-                          process_event(ev);
-                        endif
-/*NOTE NEW BOAT STATE*/
-      STATE_FOLLOWING_COURSE:
-        		x := boat.x;
-        		y := boat.y;
-        		BoatFollowCourse(boat);
-        				
-        		sleepms(ms_delay_between_moves);
-                        while(events_waiting())
-                          process_event(wait_for_event(0));
-                        endwhile
-/*END NEW BOAT STATE*/
-    endcase
-    if(ReadGameClock() &gt; nextencounter)
-      checkres();
-      nextencounter := ReadGameClock()+120;
-    endif
-  endwhile
-endprogram
-
-function handle_speech(event)
-  var text := lower(event.text);
-  if(text[&quot;drift&quot;] || text[&quot;raise anchor&quot;])
-    ms_delay_between_moves := 1000;
-    state := STATE_DRIFTING;
-    PrintTextAbove(tillerman, &quot;Aye Aye, Captain!&quot;);
-  elseif(text[&quot;forward&quot;])
-    if(state == STATE_STATIONARY)
-      PrintTextAbove(tillerman, &quot;The anchor is down, Captain!&quot;);
-    else
-      PrintTextAbove(tillerman, &quot;Aye Aye, Captain!&quot;);
-      state := STATE_MOVING;
-      if(text[&quot;left&quot;])
-        relative_direction := 7;
-      elseif(text[&quot;right&quot;])
-        relative_direction := 1;
-      else
-        relative_direction := 0;
-      endif
-    endif
-  elseif(text[&quot;back&quot;])
-    if(state == STATE_STATIONARY)
-      PrintTextAbove(tillerman, &quot;The anchor is down, Captain!&quot;);
-    else
-      PrintTextAbove(tillerman, &quot;Aye Aye, Captain!&quot;);
-      state := STATE_MOVING;
-      if(text[&quot;left&quot;])
-        relative_direction := 5;
-      elseif(text[&quot;right&quot;])
-        relative_direction := 3;
-      else
-        relative_direction := 4;
-      endif
-    endif
-  elseif(text[&quot;stop&quot;] || text[&quot;furl sail&quot;] || text[&quot;furl&quot;])
-    PrintTextAbove(tillerman, &quot;Aye Aye, Captain!&quot;);
-    ms_delay_between_moves := 1000;
-    state := STATE_DRIFTING;
-  elseif(text[&quot;drop anchor&quot;])
-    PrintTextAbove(tillerman, &quot;Aye Aye, Captain! Anchor dropped.&quot;);
-    ms_delay_between_moves := 1000;
-    state := STATE_STATIONARY;
-  elseif(text[&quot;turn right&quot;] || text[&quot;starboard&quot;])
-    if(state == STATE_STATIONARY)
-      PrintTextAbove(tillerman, &quot;The anchor is down, Captain!&quot;);
-    else
-      PrintTextAbove(tillerman, &quot;Aye Aye, Captain!&quot;);
-      TurnBoat(boat, 1);
-    endif
-  elseif(text[&quot;right&quot;])
-    if(state == STATE_STATIONARY)
-      PrintTextAbove(tillerman, &quot;The anchor is down, Captain!&quot;);
-    else
-      PrintTextAbove(tillerman, &quot;Aye Aye, Captain!&quot;);
-      state := STATE_MOVING;
-      relative_direction := 2;
-    endif
-  elseif(text[&quot;turn left&quot;] || text[&quot;port&quot;])
-    if(state == STATE_STATIONARY)
-      PrintTextAbove(tillerman, &quot;The anchor is down, Captain!&quot;);
-    else
-      PrintTextAbove(tillerman, &quot;Aye Aye, Captain!&quot;);
-      TurnBoat(boat, 3);
-    endif
-  elseif(text[&quot;left&quot;])
-    if(state == STATE_STATIONARY)
-      PrintTextAbove(tillerman, &quot;The anchor is down, Captain!&quot;);
-    else
-      PrintTextAbove(tillerman, &quot;Aye Aye, Captain!&quot;);
-      state := STATE_MOVING;
-      relative_direction := 6;
-    endif
-  elseif(text[&quot;come about&quot;] || text[&quot;turn around&quot;])
-    if(state == STATE_STATIONARY)
-      PrintTextAbove(tillerman, &quot;The anchor is down, Captain!&quot;);
-    else
-      PrintTextAbove(tillerman, &quot;Aye Aye, Captain! Coming about!&quot;);
-      TurnBoat(boat, 2);
-      sleep(1);
-    endif
-/*NEW MAP COURSE COMMANDS*/
-    elseif(text[&quot;set course&quot;])
-      	PrintTextAbove(tillerman, &quot;Select a map for me to follow.&quot;);   	
-      	var map := Target(event.source);
-      	if(!map.isa(POLCLASS_MAP))
-      		PrintTextAbove(tillerman, &quot;Are ye dense? I need a map!&quot;); 
-      	else
-      		SetObjProperty(tillerman, &quot;course&quot;, map.GetPins());
-      		SetObjProperty(tillerman, &quot;nextwaypoint&quot;, 1);
-      		PrintTextAbove(tillerman, &quot;Arr, course plotted.&quot;); 
-      	endif
-    elseif(text[&quot;clear course&quot;])
-    	PrintTextAbove(tillerman, &quot;Arr, course cleared Cap'n.&quot;);
-    	EraseObjProperty(tillerman, &quot;course&quot;);
-    	EraseObjProperty(tillerman, &quot;nextwaypoint&quot;);
-    elseif(text[&quot;nav&quot;])
-    	if(state != STATE_FOLLOWING_COURSE)
-    		PrintTextAbove(tillerman, &quot;We are not currently following a course.&quot;);
-    	else
-    		PrintTextAbove(tillerman, &quot;We are following our course.&quot;);
-    		PrintTextAbove(tillerman, &quot;The next waypoint is #&quot; + GetObjProperty(tillerman,&quot;nextwaypoint&quot;));
-    	endif
-    elseif(text[&quot;start&quot;])
-    	if( (GetObjProperty(tillerman,&quot;course&quot;)==error) || (GetObjProperty(tillerman,&quot;nextwaypoint&quot;)==error))
-    		PrintTextAbove(tillerman,&quot;Arr, set course first Cap'n.&quot;);
-    	else    		
-     		state := STATE_FOLLOWING_COURSE;
-     		SetObjProperty(tillerman, &quot;nextwaypoint&quot;, 1);
-    		PrintTextAbove(tillerman,&quot;Aye, sailing to first waypoint.&quot;);
-    	endif
-    elseif(text[&quot;continue&quot;])
-    	if( (GetObjProperty(tillerman,&quot;course&quot;)==error) || (GetObjProperty(tillerman,&quot;nextwaypoint&quot;)==error))
-    		PrintTextAbove(tillerman,&quot;Arr, set course first Cap'n.&quot;);
-    	else
-    	    state := STATE_FOLLOWING_COURSE;
-    		PrintTextAbove(tillerman,&quot;Aye, moving on.&quot;);
-    	endif
-  	endif
-/*END NEW MAP COURSE COMMANDS*/
-  if(text[&quot;full&quot;])
-    if(state != STATE_STATIONARY)
-      PrintTextAbove(tillerman, &quot;Aye Aye, Captain! Full speed ahead!&quot;);
-      ms_delay_between_moves := 100;
-    endif
-  elseif(text[&quot;slow&quot;])
-    if(state != STATE_STATIONARY)
-      PrintTextAbove(tillerman, &quot;Aye Aye, Captain! &quot;);
-      ms_delay_between_moves := 1000;
-    endif
-  endif
-  sleep(1);
-  if(text[&quot;one&quot;])
-    if(state != STATE_STATIONARY)
-      MoveBoatRelative(boat, relative_direction);
-      state := STATE_STATIONARY;
-    endif
-  endif
-endfunction
-
-function process_event(event)
-  if(event.type == SYSEVENT_SPEECH)
-    if(CanCommandMe(event.source))
-      var text := lower(event.text);
-      if(text[&quot;drydock&quot;])
-        PrintTextAbove(tillerman, &quot;Aye Aye, Captain! Docking.&quot;);
-        drydock(event);
-        sleep(1);
-      elseif(text[&quot;status&quot;])
-        decay := GetObjProperty(boat.tillerman, &quot;decay&quot;);
-        if((decay - ReadGameClock() ) &gt; 861000 )
-          PrintTextAbove( tillerman, &quot;Arrh, the ship's in excellent shape! She's a fine vessel indeed, Captain!&quot; );
-        elseif((decay - ReadGameClock() ) &gt; 604800 )
-          PrintTextAbove( tillerman, &quot;She's slightly worn, Captain.&quot;);
-        elseif((decay - ReadGameClock() ) &gt; 259200 )
-          PrintTextAbove(tillerman, &quot;She's fairly worn, Captain.&quot;);
-        elseif((decay - ReadGameClock() ) &gt; 86400 )
-          PrintTextAbove(tillerman, &quot;Arrr, she's greatly worn and in dire need of repair, Captain!&quot;);
-        else 
-          PrintTextAbove(tillerman, &quot;Arrr, she's going to sink within the day if she don't get repairs soon, Captain!&quot;);
-        endif
-      else
-        foreach person in (boat.mobiles)
-          if (event.source == person)
-             handle_speech(event);
-          endif  
-        endforeach
-      endif
-    endif
-  endif
-  
-endfunction
-
-function CanCommandMe(who)
-  owner := GetObjProperty(boat.tillerman, &quot;owner&quot;);
-  if(who.serial == owner)
-    return 1;
-  else
-    var packkey;
-    var lokid := GetObjProperty(boat.tillerman, &quot;lockid&quot;);
-    foreach thing in EnumerateItemsInContainer(who.backpack)
-      if(GetObjProperty(thing, &quot;lockid&quot;) == lokid)
-        packkey := 1;
-        break;
-      endif
-    endforeach
-    if(packkey == 1)
-      return 1;
-    else
-      return 0;
-    endif
-  endif
-endfunction
-
-function DoEncounter()
-  foreach who in  ListMobilesNearLocationEx(boat.x, boat.y, GetMapInfo(boat.x, boat.y, boat.realm).z, 4, LISTEX_FLAG_GHOST, boat.realm)
-    if(YesNo(who,&quot;Resurrect?&quot;))
-      if (who in boat.mobiles)
-        PlaySoundEffect(who, SFX_SPELL_RESSURECTION);
-        PlaySoundEffect(who, SFX_SPELL_RESSURECTION);
-        Resurrect(who);
-      endif
-    endif
-  endforeach
-  var who :=(boat.mobiles);
-  who := who[1];
-  if(!who)
-    return;
-  endif
-  var x;
-  var y;
-  var z;
-  x := RandomInt(15)-5;
-  y := RandomInt(15)-5;
-  x := x + boat.x;
-  y := y + boat.y;
-  if(x &gt; boat.x)
-    x := x + 5;
-  else
-    x := x - 5;
-  endif
-  if(y &gt; boat.y)
-    y := y + 5;
-  else
-    y := y - 5;
-  endif
-  z := GetMapInfo(x, y, boat.realm).z;
-  if(z &gt;= who.z)
-    return;
-  endif
-  var it := CreateNpcFromTemplate(getcritter(), x, y, z, 0, boat.realm);
-  if(it)
-    SetObjProperty(it,&quot;killme&quot;,1);
-  endif
-  var ev := {};
-  ev.+type := EVID_ENTEREDAREA;
-  ev.+source := who;
-  SendEvent(it, ev);
-endfunction
-
-function checkres()
-  foreach who in  ListMobilesNearLocationEx(boat.x, boat.y, GetMapInfo(boat.x, boat.y, boat.realm).z, 4, LISTEX_FLAG_GHOST, boat.realm)
-    if(who in boat.mobiles)
-      if(YesNo(who,&quot;Resurrect?&quot;))
-        PlaySoundEffect(who, SFX_SPELL_RESSURECTION);
-        PlaySoundEffect(who, SFX_SPELL_RESSURECTION);
-        Resurrect(who);
-      endif
-    endif
-  endforeach
-endfunction
-
-function getcritter()
-  case(RandomInt(9))
-    0: return &quot;walrus&quot;;
-    1: return &quot;walrus&quot;;
-    2: return &quot;walrus&quot;;
-    3: return &quot;walrus&quot;;
-    4: return &quot;alligator&quot;;
-    5: return &quot;alligator&quot;;
-    6: return &quot;waterelemental&quot;;
-    7: return &quot;seaserpent&quot;;
-    8: return &quot;airelemental&quot;;
-  endcase
-endfunction
-
-function drydock(event)
-  if(GetObjProperty(event.source, &quot;#DryDocking&quot;))
-    SendSysMessage(event.source, &quot;You are already doing something else.&quot;);
-    return;
-  endif
-  SetObjProperty(event.source, &quot;#DryDocking&quot;, 1);
-  EraseObjProperty(event.source, &quot;#DryDocking&quot;);
-  var text := lower(event.text);
-  if(!text[&quot;drydock&quot;])
-    EraseObjProperty(event.source, &quot;#DryDocking&quot;);
-    return;
-  endif
-  var me := event.source;
-  var items := boat.items;
-  var mobsondeck := boat.mobiles;
-
-  if(len(items) &gt; 0)
-    PrintTextAbovePrivate(boat.tillerman, &quot;Arrh, Captain!  You can't drydock the boat while items are on deck!&quot;, me);
-    EraseObjProperty(me, &quot;#DryDocking&quot;);
-    return;
-  endif
-  items := EnumerateItemsInContainer(boat.hold);
-  if(len(items) &gt; 0)
-    PrintTextAbovePrivate(boat.tillerman, &quot;Arrh, we'd best clear out the items in the hold first, Captain!&quot;, me);
-    EraseObjProperty(me, &quot;#DryDocking&quot;);
-    return;
-  endif
-  if(len(mobsondeck) &gt; 0)
-    PrintTextAbovePrivate(boat.tillerman, &quot;Arrh, Captain!  You can't drydock the boat while people are on the deck!&quot;, me);
-    EraseObjProperty(me, &quot;#DryDocking&quot;);
-    return;
-  endif  
-  if(CanDockMe(boat, me))
-    if(!YesNo(me,&quot;Drydock the ship?&quot;))
-      EraseObjProperty(me, &quot;#DryDocking&quot;);
-      return;
-    endif
-    var shiptype;
-    case(boat.objtype)
-      0x6040: shiptype := 0x6027;
-      0x6041: shiptype := 0x6028;
-      0x6042: shiptype := 0x6029;
-      0x6043: shiptype := 0x602a;
-      0x6044: shiptype := 0x602b;
-      0x6045: shiptype := 0x602c;
-    endcase
-    if(!shiptype)
-      SendSysMessage(me, &quot;Your boat seems to be malfunctioning. Please page a GM.&quot;);
-      return;
-    endif
-    var newboat := CreateItemInContainer(me.backpack, shiptype, 1);
-    var key := FindKey(me, boat.tillerman);
-    if(!newboat)
-      SendSysMessage(me,&quot;Could not create boat deed in your backpack!&quot;);
-      EraseObjProperty(me, &quot;#DryDocking&quot;);
-      return;
-    endif
-    if(ReserveItem(newboat))
-      newboat.graphic := 0x14f3;
-      if(!boat.tillerman.name)
-        newboat.name := &quot;a toy boat&quot;;
-      else
-        newboat.name := boat.tillerman.name;
-      endif
-      if(!DestroyBoat(boat))
-        DestroyItem(newboat);
-        EraseObjProperty(me, &quot;#DryDocking&quot;);
-        return;
-      endif
-    else
-      DestroyItem(newboat);
-      EraseObjProperty(me, &quot;#DryDocking&quot;);
-      return;
-    endif
-    if(key)
-      DestroyItem(key);
-    endif
-  endif
-  EraseObjProperty(me, &quot;#DryDocking&quot;);
-endfunction
-
-function DestroyBoat(who)
-  var res := DestroyMulti(boat);
-  if(!res)
-    return 0;
-  endif
-  return 1;
-endfunction
-
-function SmackEveryone()
-  foreach mob in(boat.mobiles)
-    ApplyDamage(mob,RandomInt(10));
-    PerformAction(mob,0x14);
-    PlaySoundEffect(mob,0x110);
-  endforeach
-endfunction
-
-function PlayBoatSounds()
-  var who := RandomInt(len(boat.mobiles)+1);
-  var mobs :=(boat.mobiles);
-  if(RandomInt(2) == 1)
-    PlaySoundEffect(mobs[who],0x13);
-  else
-    PlaySoundEffect(mobs[who],0x14);
-  endif
-endfunction
-
-function WorldWrap()
-  var newx := boat.x;
-  var newy := boat.y;
-  if(boat.y &lt;= 6)
-    newy := 4088;
-  elseif(boat.y &gt;= 4089)
-    newy := 6;
-  endif
-  if(boat.x &lt;= 6)
-    newx := 5096;
-  elseif(boat.x &gt;= 5097)
-    newx := 6;
-  endif
-  var lockid := GetObjProperty(boat.hold, &quot;lockid&quot;);
-  var owner := GetObjProperty(boat.hold, &quot;owner&quot;);
-  var shiptype := boat.objtype;
-  var shipfacing, created;
-  case(tillerman.graphic)
-    0x3e4e: shipfacing := CRMULTI_FACING_NORTH;
-    0x3e55: shipfacing := CRMULTI_FACING_EAST;
-    0x3e4b: shipfacing := CRMULTI_FACING_SOUTH;
-    0x3e50: shipfacing := CRMULTI_FACING_WEST;
-    default: shipfacing := &quot;Error!&quot;;
-  endcase
-  if(shipfacing == &quot;Error!&quot;)
-    syslog( &quot;[ERROR] [boat.src] Couldn't tell which way the ship was facing for the worldwrap!&quot;);
-  endif    
-  created := CreateMultiAtLocation( newx, newy, -5, shiptype, shipfacing, boat.realm);
-  if(!created)
-    syslog( &quot;[ERROR] [boat.src] New ship couldn't be created for worldwrap!&quot;);
-    return;
-  endif
-  var oldshiphold := boat.hold;
-  var newshiphold := created.hold;
-  foreach item in EnumerateItemsInContainer( oldshiphold )
-    if(item.container == oldshiphold)
-      MoveItemToContainer(item, newshiphold);
-    endif
-  endforeach
-  foreach item in EnumerateItemsInContainer( oldshiphold )
-    MoveItemToContainer(item, newshiphold);
-  endforeach
-  foreach mob in(boat.mobiles)
-    MoveCharacterToLocation(mob,(mob.x-boat.x)+created.x,(mob.y-boat.y)+created.y, -2,  MOVECHAR_FORCELOCATION );
-  endforeach
-  if(boat.has_offline_mobiles)
-    foreach mob in(boat.offline_mobiles)
-      MoveCharacterToLocation(mob,(mob.x-boat.x)+created.x,(mob.y-boat.y)+created.y, -2,  MOVECHAR_FORCELOCATION );
-    endforeach
-  endif
-  foreach mob in(boat.items)
-    MoveitemToLocation(mob,(mob.x-boat.x)+created.x,(mob.y-boat.y)+created.y, -2,0  );
-  endforeach
-  var newtillerman := created.tillerman;
-  newtillerman.name := tillerman.name;
-  SetObjProperty( created.starboardplank, &quot;lockid&quot;, lockid);
-  SetObjProperty( created.portplank, &quot;lockid&quot;, lockid);
-  SetObjProperty( created.ship.starboardplank, &quot;owner&quot;, owner );
-  SetObjProperty( created.ship.portplank, &quot;owner&quot;, owner );
-  SetObjProperty( created.ship.starboardplank, &quot;tillermanid&quot;, newtillerman.serial );
-  SetObjProperty( created.ship.portplank, &quot;tillermanid&quot;, newtillerman.serial );
-  SetObjProperty( created.hold, &quot;lockid&quot;, lockid);
-  SetObjProperty( created.hold, &quot;owner&quot;, owner);
-  SetObjProperty( created.tillerman, &quot;owner&quot;, owner);
-  SetObjProperty( created.tillerman, &quot;shipserial&quot;, created.serial);
-  SetObjProperty( created.tillerman, &quot;lockid&quot;, lockid);
-  SetObjProperty( created.tillerman, &quot;decay&quot;, decay);
-  if(boat.starboardplank.locked == 1)
-    created.starboardplank.locked := 1;
-  endif
-  if(boat.portplank.locked == 1)  
-    created.portplank.locked := 1;
-  endif
-  if(boat.hold.locked == 1)
-    created.hold.locked := 1;
-  endif
-  SetObjProperty( created.hold, &quot;#relativedir&quot;, relative_direction);
-  SetObjProperty( created.hold, &quot;#speed&quot;, ms_delay_between_moves);
-  created.tillerman.usescript := &quot;:boat:tillerman&quot;;
-  if(!DestroyMulti(boat))
-    DestroyItem(boat.tillerman);
-    syslog( &quot;[ERROR] [boat.src] Old ship at &quot; +(boat.x-1) +&quot;,&quot;+ boat.y +&quot;,&quot;+ boat.z + &quot; couldn't be destroyed during worldwrap!&quot;);
-  endif
-endfunction
-
-function CanDockMe(boat, who)
-  if(GetObjProperty(boat.hold,&quot;owner&quot;) == who.serial)
-    return 1;
-  else
-    var packkey;
-    var lokid := GetObjProperty(boat.tillerman, &quot;lockid&quot;);
-    foreach thing in EnumerateItemsInContainer(who.backpack)
-      if(GetObjProperty(thing, &quot;lockid&quot;) == lokid)
-        packkey := 1;
-        break;
-      endif
-    endforeach
-    if(packkey == 1)
-      return 1;
-    else
-      return 0;
-    endif
-  endif
-endfunction
-
-/*NEW MAP COURSE FUNCTIONS*/
-//follows the current course
-function BoatFollowCourse(boat)
-	var startx, starty, destx, desty;
-	var course, nextwaypoint;
-	var newpoint, newfacing, prevfacing;
-	
-	course := GetObjProperty(boat.tillerman,&quot;course&quot;);
-	nextwaypoint := GetObjProperty(boat.tillerman,&quot;nextwaypoint&quot;);
-	startx := boat.x;
-	starty := boat.y;
-	prevfacing := boat.facing;
-	
-	if( (course==error) || (nextwaypoint==error))
-		return;
-	endif
-	
-	destx := course[nextwaypoint].x;
-	desty := course[nextwaypoint].y;
-	
-	newpoint := lineBresenham(startx,starty,destx,desty);
-	newfacing := GetNewFacing(startx,starty,newpoint[1],newpoint[2]);
-
-	if(newfacing == error) //reached waypoint/end
-		nextwaypoint := nextwaypoint + 1;
-		first_move_toward_waypoint := 1; //so we turn toward next waypoint (includes next course follow if we're done with this one)
-		if(nextwaypoint &gt; course.size()) //done
-			state := STATE_DRIFTING;
-			PrintTextAbove(boat.tillerman,&quot;Arr, we've reached our destination.&quot;);
-			return;
-		else
-			SetObjProperty(boat.tillerman,&quot;nextwaypoint&quot;,nextwaypoint);
-		endif
-		
-	else
-
-		if(first_move_toward_waypoint == 1)
-			if( prevfacing != newfacing )
-				TurnBoat(boat,Cint(DetermineTurnCode(boat,newfacing)) );
-			endif
-			first_move_toward_waypoint := 0;
-		endif
-		MoveBoat(boat,newfacing);
-		
-		if((startx == boat.x) &amp;&amp;(starty == boat.y)) //we didn't move. must be blocked
-    		state := STATE_DRIFTING;
-    		PrintTextAbove(tillerman, &quot;Aaargh!  We've stopped!&quot;);
-  		endif
-  	endif
-	
-endfunction
-
-//convert facing 0-7 to turn code 0-3
-function DetermineTurnCode( boat, desired )
-
-    var current := CInt(boat.facing / 2);
-    desired := CInt(desired / 2);
-
-	
-    if ( desired &lt; current ) 
-    	desired := desired + 4; 
-    endif
-    return (desired - current);
-endfunction
-	
-//returns the direction (x1,y1) lies from (x0,y0) in the range 0-7.
-// returns error if the 2 points are equal.
-function GetNewFacing(x0,y0,x1,y1)
-	var dx, dy;
-	var facing;
-	dx := x1 - x0;
-	dy := y1 - y0;
-	
-	case(dx)
-		NEGONE: 
-			case(dy)
-				 NEGONE: facing := 7;
-				 ZERO: facing := 6;
-				 POSONE: facing := 5;
-				 default: facing := error;
-			endcase
-		 ZERO:
-		 	case(dy)
-		 		 NEGONE: facing := 0;
-		 		 ZERO: facing := error;
-		 		 POSONE: facing := 4;
-		 		 default: facing := error;
-		    endcase
-		 POSONE:
-		 	case(dy)
-		 		 NEGONE: facing := 1;
-		 		 ZERO: facing := 2;
-		 		 POSONE: facing := 3;
-		 		 default: facing := error;
-		 	endcase
-		 default: facing := error;
-	endcase
-	
-	return facing;
-endfunction
-
-//Bresenham's line drawing algorithm. determines a line between two waypoints.
-function lineBresenham(x0, y0, x1, y1)
-    var dy;
-    dy := y1 - y0;
-    var dx;
-    dx := x1 - x0;
-    var stepx, stepy;
-
-    if (dy &lt; 0)
-      	dy := -dy;  
-       	stepy := -1;
-    else
-      	stepy := 1;
-    endif
-        
-    if (dx &lt; 0) 
-       	dx := -dx;
-       	stepx := -1;
-    else 
-      	stepx := 1;
-    endif
-        
-    dy := 2*dy;   
-    dx := 2*dx;    
-
-    if (dx &gt; dy)
-        var fraction;
-        fraction := 2*dy - dx;
-        while (x0 != x1)
-        	if (fraction &gt;= 0)
-            	y0 := y0 + stepy;
-                fraction := fraction - dx;
-           	endif
-            x0 := x0 + stepx;
-            fraction := fraction + dy;
-            return {x0, y0};
-        endwhile
-    else
-        var fraction;
-        fraction := 2*dx - dy;
-        while (y0 != y1)
-            if (fraction &gt;= 0)
-                x0 := x0 + stepx;
-                fraction := fraction - dy;
-            endif
-            y0 := y0 + stepy;
-            fraction := fraction + dx;
-            return {x0, y0};
-        endwhile
-    endif
-endfunction
-/*END NEW MAP COURSE FUNCTIONS*/

Deleted: trunk/096/pkg/multis/boat/itemdesc.cfg
===================================================================
--- trunk/096/pkg/multis/boat/itemdesc.cfg	2005-12-29 09:18:56 UTC (rev 1085)
+++ trunk/096/pkg/multis/boat/itemdesc.cfg	2006-01-05 11:23:07 UTC (rev 1086)
@@ -1,168 +0,0 @@
-Item 0x6027
-{
-    Name                smallboatdeed
-    Desc                deed to a small boat
-    Graphic             0x14F2
-    Script              shipDeed
-    ShipObjType         smallboat
-    VendorSellsFor      12500
-    VendorBuysFor       12500
-	newbie              1
-}
-Item 0x6028
-{
-    Name                smalldragonboatdeed
-    Desc                deed to a small dragon boat
-    Graphic             0x14F2
-    Script              shipDeed
-    ShipObjType         smalldragonboat
-    VendorSellsFor      12500
-    VendorBuysFor       12500
-	newbie              1
-}
-
-
-Item 0x6029
-{
-    Name                mediumboatdeed
-    Desc                deed to a medium boat
-    Graphic             0x14F2
-    Script              shipDeed
-    ShipObjType         mediumboat
-    VendorSellsFor      14200
-    VendorBuysFor       14200
-	newbie              1
-}
-Item 0x602A
-{
-    Name                mediumdragonboatdeed
-    Desc                deed to a medium dragon boat
-    Graphic             0x14F2
-    Script              shipDeed
-    ShipObjType         mediumdragonboat
-    VendorSellsFor      14200
-    VendorBuysFor       14200
-	newbie              1
-}
-
-
-Item 0x602B
-{
-    Name                largeboatdeed
-    Desc                deed to a large boat
-    Graphic             0x14F2
-    Script              shipDeed
-    ShipObjType         largeboat
-    VendorSellsFor      15900
-    VendorBuysFor       15900
-	newbie              1
-}
-
-Item 0x602C
-{
-    Name                largedragonboatdeed
-	Desc                deed to a large dragon boat
-    Graphic             0x14F2
-    Script              shipDeed
-    ShipObjType         largedragonboat
-    VendorSellsFor      15900
-    VendorBuysFor       15900
-	newbie              1
-}
-
-Boat 0x6040
-{
-    Name                smallboat
-    Graphic             0x4000
-    MultiID             0x0000
-    OldObjtype          0x4000
-    OldObjtype          0x4001
-    OldObjtype          0x4002
-    OldObjtype          0x4003
-}
-
-Boat 0x6041
-{
-    Name                smalldragonboat
-    Graphic             0x4004
-    MultiID             0x0004
-    OldObjtype          0x4004
-    OldObjtype          0x4005
-    OldObjtype          0x4006
-    OldObjtype          0x4007
-}
-
-Boat 0x6042
-{
-    Name                mediumboat
-    Graphic             0x4008
-    MultiID             0x0008
-    OldObjtype          0x4008
-    OldObjtype          0x4009
-    OldObjtype          0x400A
-    OldObjtype          0x400B
-}
-
-Boat 0x6043
-{
-    Name                mediumdragonboat
-    Graphic             0x400C
-    MultiID             0x000C
-    OldObjtype          0x400C
-    OldObjtype          0x400D
-    OldObjtype          0x400E
-    OldObjtype          0x400F
-}
-
-Boat 0x6044
-{
-    Name                largeboat
-    Graphic             0x4010
-    MultiID             0x0010
-    OldObjtype          0x4010
-    OldObjtype          0x4011
-    OldObjtype          0x4012
-    OldObjtype          0x4013
-}
-
-Boat 0x6045
-{
-    Name                largedragonboat
-    Graphic             0x4014
-    MultiID             0x0014
-    OldObjtype          0x4014
-    OldObjtype          0x4015
-    OldObjtype          0x4016
-    OldObjtype          0x4017
-}
-
-Item 0xF010
-{
-    Name                Tillerman
-    graphic             1
-	script              tillerman
-}
-
-Item 0xF011
-{
-    Name                gangplank
-    Graphic             1
-    Lockable            1
-    RequiresAttention   0
-    DoubleclickRange    20
-    Script              plank
-    WalkOnScript        plankWalk
-    ControlScript       plankControl
-}
-
-Item 0xF012
-{
-    Name                gangplank2
-    Graphic             1
-    Lockable            1
-    RequiresAttention   0
-    DoubleclickRange    20
-    Script              plank
-    WalkOnScript        plankWalk
-    ControlScript       plankControl
-}

Deleted: trunk/096/pkg/multis/boat/pkg.cfg
===================================================================
--- trunk/096/pkg/multis/boat/pkg.cfg	2005-12-29 09:18:56 UTC (rev 1085)
+++ trunk/096/pkg/multis/boat/pkg.cfg	2006-01-05 11:23:07 UTC (rev 1086)
@@ -1,9 +0,0 @@
-# $Id: pkg.cfg 684 2005-10-27 18:48:28Z muaddiblsd $
-#
-#
-Enabled		1
-Name		boat
-Maintainer	Distro Team
-Email		<A HREF="https://lists.berlios.de/mailman/listinfo/poldistro-svn">distro at polserver.com</A>
-Version		1.0
-

Deleted: trunk/096/pkg/multis/boat/plank.src
===================================================================
--- trunk/096/pkg/multis/boat/plank.src	2005-12-29 09:18:56 UTC (rev 1085)
+++ trunk/096/pkg/multis/boat/plank.src	2006-01-05 11:23:07 UTC (rev 1086)
@@ -1,92 +0,0 @@
-use os;
-use uo;
-
-include &quot;util/key&quot;;
-include &quot;:itemutils:objtype&quot;;
-include &quot;plankUtil&quot;;
-
-program useplank(mob, plank)
-  set_critical(1);
-
-// Refresh the boat if he's the owner.
-var owner := GetObjProperty(plank, &quot;owner&quot;);
-if (mob.serial == owner)
-  var tillermanid := GetObjProperty(plank, &quot;tillermanid&quot;);
-  var tillerman := SystemFindObjectBySerial( tillermanid );
-  if (tillerman)
-    var decay := GetObjProperty(tillerman, &quot;decay&quot;);
-    // Only give him the refresh message if the ship was less than 'in excellent shape'
-    // so he doesn't get the message every time he gets on and off the ship.
-    if ( (decay - ReadGameClock() ) &lt; 860000 )
-          SendSysMessage(mob, &quot;Your ship has been refreshed.&quot;);
-    endif
-    SetObjProperty( tillerman, 	  &quot;decay&quot;,      (ReadGameClock()+ 864000));
-  endif
-endif
-  if(mob.multi.serial == plank.multi.serial)
-	TimedOpenClose(plank);
-  elseif((FK(mob, plank) == 1) ||(!plank.locked))
-	if(!IsExtended(plank))
-	  TimedOpenClose(plank);
-	else
-	  YankOntoBoat(mob,plank);
-	endif
-  else
-	PrintTextAbovePrivate(plank, &quot;That is locked.&quot;, mob);
-  endif
-endprogram
-
-function TimedOpenClose(plank)
-  if(IsExtended(plank))
-    if(!IsPlankOccupied(plank))
-      Retract(plank);
-      EraseObjProperty(plank, &quot;#WhenOpened&quot;);
-    endif
-  else
-    var whenopened := ReadGameClock();
-    SetObjProperty(plank, &quot;#WhenOpened&quot;, whenopened);
-    Extend(plank);
-    repeat
-    sleep(6);
-    until(!(plank &amp;&amp; IsPlankOccupied(plank)));
-    if(GetObjProperty(plank, &quot;#WhenOpened&quot;) == whenopened)
-      Retract(plank);
-      EraseObjProperty(plank, &quot;#WhenOpened&quot;);
-    endif
-  endif
-endfunction
-
-function YankOntoBoat(mob, plank)
-  var sh := GetStandingHeight(plank.x, plank.y, plank.z, plank.realm);
-  if(sh)
-    var nx :=(plank.x + plank.multi.x) / 2;
-    var ny :=(plank.y + plank.multi.y) / 2;
-    MoveCharacterToLocation(mob, nx, ny, plank.z);
-    return;
-  endif
-endfunction
-
-function CanWalkOntoPlank(plank)
-  var dx;
-  var dy;
-  case(plank.graphic)
-    GID_PLANK_EXTENDED_FACING_WEST:
-    GID_PLANK_RETRACTED_FACING_WEST:    dx := -1;
-                                        dy := 0;
-    GID_PLANK_EXTENDED_FACING_EAST:
-    GID_PLANK_RETRACTED_FACING_EAST:    dx := 1;
-                                        dy := 0;
-
-    GID_PLANK_EXTENDED_FACING_NORTH:
-    GID_PLANK_RETRACTED_FACING_NORTH:   dx := 0;
-                                        dy := -1;
-    GID_PLANK_EXTENDED_FACING_SOUTH:
-    GID_PLANK_RETRACTED_FACING_SOUTH:   dx := 0;
-                                        dy := 1;
-  endcase
-  if(GetStandingHeight(plank.x + dx, plank.y + dy, plank.z, plank.realm))
-    return 1;
-  else
-     return 0;
-  endif
-endfunction

Deleted: trunk/096/pkg/multis/boat/plankControl.src
===================================================================
--- trunk/096/pkg/multis/boat/plankControl.src	2005-12-29 09:18:56 UTC (rev 1085)
+++ trunk/096/pkg/multis/boat/plankControl.src	2006-01-05 11:23:07 UTC (rev 1086)
@@ -1,20 +0,0 @@
-/*
- * plankcontrol - plank control script
- *
- * sole job is to close an open locked plank on startup.
- *
- */
-
-use os;
-use uo;
-
-include &quot;:itemutils:objtype&quot;;
-include &quot;plankUtil&quot;;
-
-set_debug(1);
-
-program plankcontrol( plank )
-    if (plank.locked &amp;&amp; IsExtended(plank))
-        Retract( plank );
-    endif
-endprogram

Deleted: trunk/096/pkg/multis/boat/plankUtil.inc
===================================================================
--- trunk/096/pkg/multis/boat/plankUtil.inc	2005-12-29 09:18:56 UTC (rev 1085)
+++ trunk/096/pkg/multis/boat/plankUtil.inc	2006-01-05 11:23:07 UTC (rev 1086)
@@ -1,89 +0,0 @@
-include &quot;:itemutils:objtype&quot;;
-
-const KEYSTART := 0x100e;
-const KEYEND := 0x1013;
-const KEYRING := 0x1011;
-
-function IsExtended( plank )
-  return plank.graphic in { GID_PLANK_EXTENDED_FACING_EAST, GID_PLANK_EXTENDED_FACING_WEST, GID_PLANK_EXTENDED_FACING_NORTH, GID_PLANK_EXTENDED_FACING_SOUTH };
-endfunction
-
-function IsPlankOccupied( plank )
-  return ListMobilesNearLocation( plank.x, plank.y, plank.z, 0, plank.realm ).size();
-endfunction
-
-function Extend( plank )
-  if (!IsExtended(plank))
-    TogglePlank(plank);
-  endif
-endfunction
-
-function Retract( plank )
-  if (IsExtended(plank))
-    TogglePlank(plank);
-  endif
-endfunction
-
-function TogglePlank( plank )
-  var partnertype := PlankPartner( plank.graphic );
-  if (partnertype)
-    plank.graphic := partnertype;
-  endif
-endfunction
-
-function PlankPartner( planktype )
-  case (planktype)
-    GID_PLANK_EXTENDED_FACING_EAST:  return GID_PLANK_RETRACTED_FACING_EAST;   // 0x3ed5: return 0x3eb1;
-    GID_PLANK_RETRACTED_FACING_EAST: return GID_PLANK_EXTENDED_FACING_EAST;    // 0x3eb1: return 0x3ed5;
-    GID_PLANK_EXTENDED_FACING_WEST:  return GID_PLANK_RETRACTED_FACING_WEST;   // 0x3ed4: return 0x3eb2;
-    GID_PLANK_RETRACTED_FACING_WEST: return GID_PLANK_EXTENDED_FACING_WEST;    // 0x3eb2: return 0x3ed4;
-    GID_PLANK_EXTENDED_FACING_NORTH:  return GID_PLANK_RETRACTED_FACING_NORTH; // 0x3e84: return 0x3e85;
-    GID_PLANK_RETRACTED_FACING_NORTH: return GID_PLANK_EXTENDED_FACING_NORTH;  // 0x3e85: return 0x3e84;
-    GID_PLANK_EXTENDED_FACING_SOUTH:  return GID_PLANK_RETRACTED_FACING_SOUTH; // 0x3e89: return 0x3e8a;
-    GID_PLANK_RETRACTED_FACING_SOUTH: return GID_PLANK_EXTENDED_FACING_SOUTH;  // 0x3e8a: return 0x3e89;
-    default: syslog( &quot;Unknown plank type 0x&quot; + Hex( planktype ) );
-             return error;
-  endcase
-endfunction
-
-function fk(me, plank)
-  var doorlockid := GetObjProperty( plank, &quot;lockid&quot; );
-  var keylockid;
-  var insidering;
-  var mykeys := EnumerateItemsInContainer(me.backpack);
-  foreach key in mykeys
-	if ( (key.objtype &gt;= KEYSTART ) &amp;&amp; (key.objtype &lt;= KEYEND) &amp;&amp; (key.objtype != KEYRING ) )
-	  keylockid := GetObjProperty( key, &quot;lockid&quot; );
-	  if ( (keylockid) &amp;&amp; (keylockid == doorlockid) )
-		return 1;
-	  endif
-	elseif (key.objtype == KEYRING)
-	  insidering := FindMyPack(key.serial);
-	  foreach otherkey in EnumerateItemsInContainer(insidering)
-		keylockid := GetObjProperty( otherkey, &quot;lockid&quot; );
-		if (keylockid == doorlockid)
-		  return 1;
-		endif
-	  endforeach
-	endif
-  endforeach
-  return 0;
-endfunction
-
-function OpenTamedStorageAreas()
-  var bank := FindStorageArea( &quot;Tamed Storage&quot; );
-  if (!bank)
-    bank := CreateStorageArea( &quot;Tamed Storage&quot; );
-  endif
-  return bank;
-endfunction
-
-function FindMyPack(myserial)
-  var mybank := OpenTamedStorageAreas();
-  var bank_obj_name := &quot;Bankbox  &quot; + Hex(myserial);
-  var bankbox := FindRootItemInStorageArea( mybank, bank_obj_name );
-  if (!bankbox)
-    bankbox := CreateRootItemInStorageArea(mybank, bank_obj_name, UOBJ_BANKBOX  );
-  endif
-  return bankbox;
-endfunction
\ No newline at end of file

Deleted: trunk/096/pkg/multis/boat/plankWalk.src
===================================================================
--- trunk/096/pkg/multis/boat/plankWalk.src	2005-12-29 09:18:56 UTC (rev 1085)
+++ trunk/096/pkg/multis/boat/plankWalk.src	2006-01-05 11:23:07 UTC (rev 1086)
@@ -1,158 +0,0 @@
-use os;
-use uo;
-
-include &quot;include/client&quot;;
-include &quot;:itemutils:objtype&quot;;
-include &quot;util/key&quot;;
-include &quot;plankUtil&quot;;
-
-/*
- * the searchoffset matrix is for an east-facing plank.
- * these will have to be rotated for the other positions
- *   P is the plank, N is where you can't step (otherwise
- *    this teleportation stuff wouldn't be necessary)
- *
- *        13 12 11
- *        14  5  4
- *        15  6  2
- *        16  7  1 N P
- *        17  8  3
- *        18  9 10
- *        19 20 21
- *
- */
-
-var searchoffset := {
-   { -2,  0 },          //  1
-   { -2, -1 },
-   { -2, +1 },
-   { -2, -2 },
-   { -3, -2 },          //  5
-   { -3, -1 },
-   { -3,  0 },
-   { -3, +1 },
-   { -3, +2 },
-   { -2, +2 },          // 10
-   { -2, -3 },
-   { -3, -3 },
-   { -4, -3 },
-   { -4, -2 },
-   { -4, -1 },          // 15
-   { -4,  0 },
-   { -4, +1 },
-   { -4, +2 },
-   { -4, +3 },
-   { -3, +3 },          // 20
-   { -2, +3 },
-   { -5,  0 },
-   { -5, +2 },
-   { -5, +3 },
-   { -5, +4 },
-   { -4, +4 },          // 20
-   { -3, +4 },
-   { -6,  0 },
-   { -6, +3 },
-   { -6, +4 },
-   { -6, +5 },
-   { -5, +5 },          // 20
-   { -4, +5 }
-};
-
-program plankwalk( who, plank, lastx, lasty, lastz )
-    if (!FindKey( who, plank ))
-        if (plank.locked)
-            var sh := GetStandingHeight( lastx, lasty, lastz, who.realm );
-            if (!sh || !sh.multi || sh.multi.serial != plank.multi.serial)
-                MoveCharacterToLocation( who, lastx, lasty, lastz, MOVECHAR_FORCELOCATION );
-                return;
-            endif
-        endif
-    endif
-
-    if (ListMobilesNearLocation( plank.x, plank.y, plank.z, 0, plank.realm ).size() &gt; 1)
-        MoveCharacterToLocation( who, lastx, lasty, lastz, MOVECHAR_FORCELOCATION );
-        return;
-    endif
-
-    var xidx, yidx, xmul, ymul;
-
-    case (plank.graphic)
-        GID_PLANK_EXTENDED_FACING_WEST:
-            if (! (who.facing in { DIR_W, DIR_NW, DIR_SW }))
-                return;
-            endif
-            xidx := 1;
-            yidx := 2;
-            xmul := 1;
-            ymul := 1;
-
-        GID_PLANK_EXTENDED_FACING_EAST:
-            if (! (who.facing in { DIR_E, DIR_NE, DIR_SE }))
-                return;
-            endif
-            xidx := 1;
-            yidx := 2;
-            xmul := -1; // flip across x-axis
-            ymul := 1;
-
-        GID_PLANK_EXTENDED_FACING_NORTH:
-            if (! (who.facing in { DIR_N, DIR_NE, DIR_NW }))
-                return;
-            endif
-            xidx := 2;
-            yidx := 1;
-            xmul := 1;
-            ymul := +1;
-
-        GID_PLANK_EXTENDED_FACING_SOUTH:
-            if (! (who.facing in { DIR_S, DIR_SE, DIR_SW }))
-                return;
-            endif
-            xidx := 2;
-            yidx := 1;
-            xmul := 1;
-            ymul := -1; // flip across y-axis
-
-        default:
-            return;
-    endcase
-    if (CanMove( who,
-                 searchoffset[1][xidx] * xmul / 2,
-                 searchoffset[1][yidx] * ymul / 2 ))
-        return;                     // doesn't need our help!
-    endif
-
-
-    foreach offset in searchoffset
-        if (TryMove( who, offset[xidx] * xmul, offset[yidx] * ymul ))
-            return;
-        endif
-    endforeach
-endprogram
-
-function TryMove( who, dx, dy )
-    var res := 0;
-    set_critical( 1 );
-
-    var tryx := who.x + dx;
-    var tryy := who.y + dy;
-    var h := GetStandingHeight( tryx, tryy, who.z, who.realm );
-    if (h &amp;&amp; (not h.multi)) // CHECKME should check line of sight?
-        MoveCharacterToLocation( who, tryx, tryy, h.z );
-        res := 1;
-    endif
-
-    set_critical(0);
-    return res;
-endfunction
-
-function CanMove( who, dx, dy )
-    var tryx := who.x + dx;
-    var tryy := who.y + dy;
-    var h := GetStandingHeight( tryx, tryy, who.z, who.realm );
-    if (h)
-        return 1;
-    else
-        return 0;
-    endif
-endfunction
\ No newline at end of file

Deleted: trunk/096/pkg/multis/boat/shipDeed.src
===================================================================
--- trunk/096/pkg/multis/boat/shipDeed.src	2005-12-29 09:18:56 UTC (rev 1085)
+++ trunk/096/pkg/multis/boat/shipDeed.src	2006-01-05 11:23:07 UTC (rev 1086)
@@ -1,128 +0,0 @@
-// $Id: shipDeed.src 905 2005-11-05 08:20:50Z muaddiblsd $
-
-use cfgfile;
-use uo;
-use os;
-
-include &quot;util/key&quot;;
-include &quot;:itemutils:objtype&quot;;
-include &quot;:itemutils:canAccess&quot;;
-
-program useshipdeed(who, deed)
-  if(DeedAlreadyBuiltFrom(deed))
-    PrintTextAbovePrivate(deed, &quot;That ship has already been built.&quot;, who);
-  elseif(can_access(who, deed))
-    BuildShip(who, deed);
-  endif
-endprogram
-
-function BuildShip(who, deed)
-  var shiptype := GetShipObjtype(deed.objtype);
-  if(!shiptype)
-    PrintTextAbovePrivate(deed, &quot;That ship deed appears to be broken.&quot;, who);
-    return;
-  endif
-  var flags := ShipFacingFlags(who.facing);
-  var where := TargetMultiPlacement(who, shiptype, flags);
-  if(!where)
-    if(deed.graphic == 5363)
-      deed.graphic := 5364;
-    elseif(deed.graphic == 5364)
-      deed.graphic := 5363;
-    endif
-    return;
-  elseif((where.x == deed.x) &amp;&amp; (where.y == deed.y))
-    if(deed.graphic == 5363)
-      deed.graphic := 5364;
-    elseif(deed.graphic == 5364)
-      deed.graphic := 5363;
-    endif
-    return;
-  endif
-  set_critical(1);
-  if((where.x &lt; who.x - 10) || (where.y &lt; who.y - 10) || (where.x &gt; who.x + 10) || (where.y &gt; who.y + 10))
-    SendSysMessage(who, &quot;You cannot place a boat that far away.&quot;);
-    return;
-  endif
-  var created := CreateShipKeysAndBuiltDeed(who, shiptype, where.x, where.y, where.z, flags);
-  if(created)
-    var ship := created.ship;
-    var deedtype := deed.objtype;
-    if((deed.name != &quot;a toy boat&quot;) &amp;&amp; (!deed.name[&quot;deed&quot;]))
-      ship.tillerman.name := deed.name;
-    endif
-    if(DestroyItem(deed))
-      ship.starboardplank.locked    := 1;
-      ship.portplank.locked         := 1;
-      ship.hold.locked              := 1;
-      var lockid := AllocLockId();
-      SetObjProperty(ship.starboardplank, &quot;lockid&quot;,      lockid);
-      SetObjProperty(ship.starboardplank, &quot;owner&quot;,       who.serial);
-      SetObjProperty(ship.starboardplank, &quot;tillermanid&quot;, ship.tillerman.serial);
-      SetObjProperty(ship.portplank,      &quot;lockid&quot;,      lockid);
-      SetObjProperty(ship.portplank,      &quot;owner&quot;,       who.serial);
-      SetObjProperty(ship.portplank,      &quot;tillermanid&quot;, ship.tillerman.serial);
-      SetObjProperty(ship.hold,           &quot;lockid&quot;,      lockid);
-      SetObjProperty(ship.tillerman,      &quot;owner&quot;,       who.serial);
-      SetObjProperty(ship.tillerman,      &quot;shipserial&quot;,  ship.serial);
-      SetObjProperty(ship.tillerman,      &quot;lockid&quot;,      lockid);
-      SetObjProperty(ship.tillerman,      &quot;shiptype&quot;,    deedtype);
-      SetObjProperty(created.packkey,     &quot;lockid&quot;,      lockid);
-      SetObjProperty(created.packkey,     &quot;shipserial&quot;,  ship.serial);
-      SetObjProperty(ship.tillerman,      &quot;decay&quot;,       (ReadGameClock()+ 864000));
-      ship.tillerman.usescript := &quot;:boat:tillerman&quot;;
-    else
-      DestroyItem(created.packkey);
-      DestroyMulti(ship);
-      SendSysMessage(who, &quot;There was an error creating the boat.&quot;);
-    endif
-  endif
-endfunction
-
-function ShipFacingFlags(facing)
-  var flags := 0;
-  case (facing)
-    DIR_N:  flags := CRMULTI_FACING_NORTH;
-    DIR_NE: flags := CRMULTI_FACING_NORTH;
-    DIR_E:  flags := CRMULTI_FACING_EAST;
-    DIR_SE: flags := CRMULTI_FACING_SOUTH;
-    DIR_S:  flags := CRMULTI_FACING_SOUTH;
-    DIR_SW: flags := CRMULTI_FACING_SOUTH;
-    DIR_W:  flags := CRMULTI_FACING_WEST;
-    DIR_NW: flags := CRMULTI_FACING_NORTH;
-  endcase
-  return flags;
-endfunction
-
-function CreateShipKeysAndBuiltDeed(who, shiptype, x, y, z, flags)
-  var packkey := CreateItemInBackpack(who, UOBJ_COPPER_KEY);
-  if(!packkey)
-    PrintTextAbovePrivate(who, &quot;My backpack is too full!&quot;, who);
-    return 0;
-  endif
-  var ship := CreateMultiAtLocation(x, y, z, shiptype, flags, who.realm);
-  if(!ship)
-    PrintTextAbovePrivate(who, &quot;I can't place the ship there.&quot;, who);
-    DestroyItem(packkey);
-    return 0;
-  else
-    var result := struct;
-    result.+packkey := packkey;
-    result.+ship    := ship;
-    return result;
-  endif
-endfunction
-
-function DeedAlreadyBuiltFrom(deed)
-  if(GetObjProperty(deed, &quot;builtserial&quot;))
-    return 1;
-  else
-    return 0;
-  endif
-endfunction
-
-function GetShipObjtype(objtype)
-    var cfg := ReadConfigFile(&quot;:boat:itemdesc&quot;);
-    var ot := GetObjtypeByName(cfg[objtype].ShipObjType);
-    return Cint(ot);
-endfunction
\ No newline at end of file

Deleted: trunk/096/pkg/multis/boat/tillerman.src
===================================================================
--- trunk/096/pkg/multis/boat/tillerman.src	2005-12-29 09:18:56 UTC (rev 1085)
+++ trunk/096/pkg/multis/boat/tillerman.src	2006-01-05 11:23:07 UTC (rev 1086)
@@ -1,22 +0,0 @@
-use os;
-use uo;
-
-include &quot;util/key&quot;;
-include &quot;:itemutils:objtype&quot;;
-include &quot;plankUtil&quot;;
-
-program renameboat(you, tillerman)
-  if((GetObjProperty(tillerman,&quot;owner&quot;) != you.serial) &amp;&amp;(you.cmdlevel &lt; 2))
-	PrintTextAbove(tillerman,&quot;Stop that, or I'll throw ye overboard!&quot;);
-	return;
-  endif
-    var boatname := RequestInput(you, tillerman, &quot;Enter a new name for this boat.(max 40 characters)&quot;);
-  if(boatname)
-	if(len(boatname) &lt;= 40)
-	  tillerman.name := boatname;
-	  SendSysMessage(you, &quot;Boat is renamed.&quot;);
-	else
-	  SendSysMessage(you, &quot;Too many characters in name.&quot;);
-	endif
-  endif
-endprogram
\ No newline at end of file


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	
	<LI>Next message: <A HREF="001058.html">[Poldistro-svn] r1087 - in trunk/096/pkg/multis/boat: . config deed multi plank tiller
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1057">[ date ]</a>
              <a href="thread.html#1057">[ thread ]</a>
              <a href="subject.html#1057">[ subject ]</a>
              <a href="author.html#1057">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/poldistro-svn">More information about the Poldistro-svn
mailing list</a><br>
</body></html>
